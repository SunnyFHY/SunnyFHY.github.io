<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>uCOSIII（二）</title>
      <link href="/2018/12/10/ucosiii2/"/>
      <url>/2018/12/10/ucosiii2/</url>
      
        <content type="html"><![CDATA[<h1 id="UCOSIII知识点小结"><a href="#UCOSIII知识点小结" class="headerlink" title="UCOSIII知识点小结"></a>UCOSIII知识点小结</h1><p>1、其中最有用的功能应该是时间片轮转法（ roundrobin), 这个是 uC/OS-II 中不支持的，但是现在已经是 uC/OS-III 的一个功能了 </p><p>2、uC/OS-III 被设计用于 32 位处理器， 但是它也能在 16 位或 8 位处理器中很好地工作。</p><p>3、一共有 2 种类型的实时系统：软实时系统和硬实时系统。硬实时系统中，运算超时是不允许发生的，运算超时会导致严重后果。但是在软实时系统中 ， 超时不会导致严重后果  </p><p>4、前后台系统：包含一个无限循环的模块实现需要的操作（后台）。中断处理程序实现异步事件（前台）。前台也叫做中断级，后台也叫作任务级。 </p><p>5、临界操作应该在任务级中被执行，不可避免地必须在中断处理程序中执行也要确保是在很短的时间内完成。 因为这会导致 ISR 占用更长的时间。 通常的， ISR 中使能相关的信息而在后台程序中执行相应的操作。 </p><p>6、ucos-iii中的任务（也叫做线程） 是一段简单的程序， 运行时完全地占用 CPU 。在单 CPU 中，任何时候只有 1 个任务被执行。 </p><p>7、内核的责任是管理任务，协调和切换多个任务依次享用 CPU 。让我们感觉是多个 CPU 在同时运行，也有利于处理模块化的应用 它也负责管理任务间的交流， 系统资源的管理（内存 和I/O ）等。 </p><p>8、uC/OS-III 是一个抢占式内核， 这意味着 uC/OS-III 总是执行最</p><p>重要的就绪任务 </p><p>9、ISR 响应中断请求设备， 但是 ISR 只做非常少的工作。 ISR </p><p>应该标记或发送消息到一个高优先级的任务， 让中断能够快速处理完毕 </p><p>10、系统中加入内核需要额外的支出，因为内核提供服务时需要时间</p><p>去处理。内核占用 CPU 的时间介于 2% 到 4% 之间。 因为 uC/OS-III是一个软件，添加到目标系统中需要额外的 ROM 和 RAM 。 </p><p>11、。 uC/OS-III 内核需要 1K 到 4K 之间的 RAM ， 加上每个任务自己所需的堆栈空间。 至少有 4K 大小 RAM 的处理器才有可能成功移植 uC/OS-III 。 </p><p>12、： uC/OS-III 允许多个任务拥有相同的优先级。 当多个相同优先级的任务就绪时， 并且这个优先级是目前最高的uC/OS-III 会分配用户定义的时间片给每个任务去运行。 每个任务可以定义不同的时间片 。</p><p>13、uC/OS-III 保护临界段可以通过锁定调度器代替关中断。 因此关中断的时间会非常少。这样就使 uC/OS-III 可以响应一些非常快的中断源了。 </p><p>14、 uC/OS-III 允许用户在运行时配置内核。特别的，所有的内核对象如任务、堆栈、信号量、事件标志组、消息队列、 消息、 互斥信号量、 内存分区、 软件定时器等都是在运行时分配的 , 以免在编译时的过度分配。 </p><p>15、uC/OS-III 对任务数量、任务大小、优先级数量无限制。每一个任务需要有自己的堆栈空间。实际上， 任务的数量和大小限制于处理器能提供的内存大小。 </p><p>16、uC/OS-III 支持任何数量的任务、信号量、 互斥信号量、 事件标志组、 消息队列、 软件定时器、 内存分区。 用户在运行时分配所有的内核对象。 </p><p>17、互斥信号量用于资源管理。它是一个内置优先级的特殊类型信号量， 用于消除优先级反转。 互斥信号量可以被嵌套，因此，任务可申请同一个互斥信号量多达 250 次。当然， 互斥信号量的占有者需要释放同等次数。 </p><p>18、： uC/OS-III 允许任务停止自身或者停止另外的任务。 停止一个任务意味着这个任务将不再执行直到被其他的任务复。 停止可以被嵌套到 250 级。 换句话说， 一个任务可以停止另外的任务多达 250 次。 当然， 这个任务必须被恢复同等次数才有资格再次获得 CPU 。 </p><p>19、可以定义任意数量的一次性的、周期性的、或者两者兼有的软件定时器。 定时器是倒计时的， 执行用户定义的行为一直到计数减为 0 。 每一个定时器可以有自己的行为， 如果一个定时器是周期性的，计数减为 0 时会自动重装计数值并执行用户定义的行为。 </p><p>20、： uC/OS-III 允许任务等待多个事件的发生。等待中的任务在所有事件发生后被唤醒 </p><p>21、 uC/OS-III 允许 ISR 或者任务直接地发送信号量给其它任务。 这样就避免了必须产生一个中间级内核对象如一个信号量或者事件标志组只为了标记一个任务。提高了内核性能。 </p><p>22、：每一个任务可以拥有用户可定义的任务寄存器，不同于 CPU 寄存器。uC/OS-III 能检测指针是否为 NULL 、 在 ISR 中调用的</p><p>任务级服务是否允许、 参数在允许范围内、 配置选项的有效性、 函数的执行结果等。每一个 uC/OS-III 的 API 函数返回一个对应于函数调用结果的错误代号 </p><p>23： uC/OS-III 有内置性能测量功能。 能测量每一个任务的执行时间 , 每个任务的堆栈使用情况， 任务的执行次数， CPU的使用情况， ISR 到任务的切换时间 , 任务到任务的切换时间， 列表中的对象的峰值数，关中断、锁调度器平均时间等。 </p><p>24 、uC/OS-III 被设计于能够根 CPU 的架构被优化 uC/OS-III 所用的大部分数据类型能够被改变， 以更好地适应 CPU 固有的字大小。 优先级调度法则可以通过编写一些汇编语言而获益于一些 特 殊 的 指令如位设置、位清除、计数器清零指令（ CLZ ）、find-first-one(FF1) 指令</p><p>25、uC/OS-III 中所有的挂起服务都可以有时间限制， 预防死锁。</p><p>26、uC/OS-III 有时基任务， 时基 ISR 触发时基任务。 uC/OS-III 使27、uC/OS-III使用了哈希列表结构， 可以大大减少处理延时和任务超时所产生的开支。 </p><p>28、uC/OS-III 允许程序员定义 hook 函数。hook 函数允许用户扩展 uC/OS-III 的功能。 </p><p>29、为了测量时间， uC/OS-III 需要一个 16 位或者 32 位的时时间戳计数器。 </p><p>30、 每个 uC/OS-III 的内核对象有一个相关联的名字。 这样</p><p>就能很容易的识别出对象所指定的作用。对象的名字长度没有限制，但是必须以空字符结束。 </p><p>31、每个任务需要创建自己的堆栈。 堆栈的数据类型 CPU_STK 。堆栈可以被静态地分配或者通过 malloc() 动态地分配。若任务将不会被删除，堆栈将一直被使用。 </p><p>32、在大部分处理器中， 中断在启动时是关闭的。 无论如何， 在启动时关闭所有的外设中断是最安全的。 </p><p>33、uC/OS-III 须创建空闲任务 OS_IdleTask （）， 当没有其他任务运行时就运行空闲任务。根 据 配 置 文 件 中 所 uC/OS-III 会 创 建 统 务OS_StatTask() 、 定 时 器任务 OS_TmrTask() 、 中 断队 列 处 理任务OS_IntQTask() 。</p><p>34、 OSTaskCreate() 的第四个参数， 第一次被调用时OSTaskCreate() 接收这个变量， 传递给所创建的任务中的唯一参数”p_arg”。该参数可以是任意类型的指针。 </p><p>35、参数值越小优先级越高。 可以设置优先级数值为 1 到 OS_CFG_PRIO_MAX-2 。 要避免使用优先级 #0 和优先级 </p><p>OS_CFG_PRIO_MAX-1 。 因 为 这些是为 uC/OS-III保留的。</p><p>36、任务的堆栈大 ( 以 CPU_STK 为数据类型而不是字节 ) 。 例如， 如果要分配 1KB 大小的堆栈空间，因为 CPU_STK 是 32 位的，所以这个其值为 256. </p><p>37、）所有的 uC/OS-III 任务需要被设置为无限循环。 </p><p>38、互斥信号量（ mutex ）是一个内核对象，用于保护共享资源。 任务要访问共享资源就必须先获得 mutex 。mutex的拥有者使用完这个资源后就必须释放这个 mutex 。 </p><p>39、消息队列是一个内核对象， ISR 或任务可以直接发送消息到另一个任务。 发送者制定一个消息并将其发送到目标任务的消息 队列。 目标任务等待消息的到达。 </p><p>40、定义消息队列可接受消息的个数。 这个值必须大于 0 。如果</p><p>消息者发送消息数超过了消息接收任务的承受能力。那么消息将会被丢失。可以通过增加消息队列的大小或者提供消息接收任务的优先级提升其承受能力。 </p><p>41、uC/OS-III 定义了一个进入临界段的宏和两个出临界段的宏（退出临界段后是否调用调度器）。 </p><p>42、测得消息是什么时候被发送的， 用户就能测得任务接收这</p><p>个消息所用的时间。 读取现在的时间戳并减去消息被发送时的时</p><p>戳。需注意的是， 消息被发送时， 等待消息的任务可能不会立即接收到消息，因为 ISR 或更高优先级的任务可能抢占了当前任务。显然，测出的时间还包括了测量时消耗的额外时间。 然而减掉测量时所耗时间就是实际上的时间。 </p><p>43、时间戳的控制单元位于 CPU_TS 中。 例如， 如果 CPU 速率为 1MHz ， 时间戳的速率为 1MHz 。 那么CPU_TS 的分辨率为 1 微秒 </p><p>44、当任务第一次执行时， 会传入一个变量 “p_arg” 。这是一个指向 void的指针。 用于变量的地址、 结构体地址、 或者函数的地址等。 如果需要，可以创建多个相同的任务，使用相同的代码（相同任务体），而产生有不同的运行结果。</p><p>45、只运行一次的任务结束时必须通过调用 OSTaskDel() 删除自己。 这样可以使系统中的任务数减少。 </p><p>46、一个任务可以创建其它任务（ 调 OSTaskCreate() ）、 停止或者恢复其它 ( 调用 OSTaskSuspned() 和 OSTaskResume()) 、 提交信号量到其它任务、 发送消息到其它任务、 提供共享资源等。 换句话说， 任务不是只被限制于“等待事件”。 </p><p>47、在嵌入式系统中动态地分配堆栈是被允许的，但是，一旦堆栈被动态分配，它就不能被回收。 换句话说， 对于有些不需要被删除的任务， 动态分配它们的堆栈是一种很好的解决方法。</p><p>48、可以人工地计算出任务需要的堆栈空间大小，逐级嵌套所有可能</p><p>被调用的函数， 添加被调用函数中所有的参数， 添加上下文切换时的CPU 寄存器空间， 添加切换到中断时所需的 CPU 寄存器空间，添加处理 ISRs 所需的堆栈空间。 把上述的全部相加， 得到的值定义为最小的需求空间。 因为我们不可能计算出精确的堆栈空间。 通常是再乘以 1.5 以确保任务的安全运行。</p><p>49、另一种防止堆栈溢出的方法是分配的空间远大于可能需要的。  首先， 当任务创建时其堆栈被清零。 程序运行一段时间后，通过一个低优先级任务， 计算该任务整个堆栈中值为 0 的内存大小。 这是一种非常有效的方法。 注意的是， 程序需用运行很长的时间以让堆栈达到其需要的最大值。 </p><p>50、从用户的观点来看，任务可以是有 5 种状态，休眠状态，就绪状态，运行状态，挂起状态，中断状态 。</p><p>51、调用 OSTaskSuspend() 会任务无条件地停止运行。 有些时候调用 OSTaskSuspend() 不是为了等待某个事件的发生，而是等待另一个任务调用 OSTaskResume() 函数恢复这个任务。 </p><p>52、任务控制块是被 uC/OS-III 用于维护任务的一个结构体。 每个任务都必须有自的己 TCB 。TCB 中的一些变量可以根据具体应用进行裁剪。用户程序不应该访问这些变量（尤其不能更改它们） </p><p>53、有些处理器有硬件寄存器可以自动地检测并确保堆栈不发生溢出， 如果处理器没有这些硬件施，ucos-iii的堆栈检测可以用软件模拟。 然而， 软件模拟不如硬件可靠。</p><p>54、在 uC/OS-III 初始化的时候，它会创建至少 2 个内部的任务 (OS_IdleTask() 和 OS_TickTask()) ， 3 个可选择的任务（ OS_StatTask() ，OS_TmrTaks() ， OS_IntQTask() ）。这些可选择的任务在编译时由OS_CFG.H 中的配置决定。 </p><p>55、当 CPU 中没有其它就绪任务运行时，空闲会被运行。空闲任务是一个无限循环的不会等待任何事件的任务。空闲任务的每次循环，都会调用 OSIdleTaskHook() 函数，这个函数提供给用户扩展应用，如让处理器进入低功耗模式等。</p><p>56、） 使用硬件定时器并被设置为以 10 到 1000Hz 之间的频率</p><p>产生时基中断，时基中断并不是一定要用 CPU 产生， 事实上， 它可以从其他的具有较精确的周期性时间源中获得，比如电源线（ 50-60Hz ）等。 </p><p>57、当时基任务执行时，它会遍历挂起队列中所有等待期满的任务或等待事件超时的任务。 它会就绪时基列表中的那些期满、超时的任务。使用轮转法遍历队列（此队列为二维数组的形式）大大减少了遍历队列所占用CPU的时间。</p><p>58、统计任务能够统计总的 CPU 使用率, 每个任务的 CPU使用率，每个任务的堆栈使用量。 </p><p>59软件定时器通常需要的频率可由用户设置， 通过软件将时基分频。 换句话说如果时基速率为 1000Hz, 但是想要的定时器速率为 10Hz, 软件定时器任务会每 100 个时基被标记一次。时基任务的优先级要高于定时器任务，定时器任务的优先级需要于统计任务 </p><p>60、当一个任务创建了一个具有相同优先级的任务，这个新任务会被</p><p>添加到该优先级队列的尾部（因为具有相同优先级情况下， 没有理由让新任务先运行）。然而，当一个任务创建了一个具有不同优先级的任务时，这个新的任务就会放到对应优先级列表中的首部。注意：正在运行的任务也被放在就绪列表中。 </p><p>61会发生调度的调度点：任务被标记或发送消息给另一个任务 </p><p>、任务调用 OSTimeDly() 或 OSTimeDlyHMSM()、任务所等待的事件发生或超时、任务被取消挂起 、新任务被创建 、任务被删除 、内核对象被删除 、任务改变自身的优先级或其它任务的优先级 、任务通过调用OSTaskSuspend() 停止自身、任务调用OSTaskResume() 恢复其它停止了的任务、退出中断服务程序 、通过调用 OSSchedUnlock() 调度器被解锁、调用OSSchedRoundRobinYield() 任务放弃了分配给它的时间片、用户调用OSSched() </p><p>62、任务提交一个事件后调用调度器。 当然， 任务可以一次性提交多个事件， 但在最后一个事件提交后才调用调度器。 </p><p>63、uC/OS-III 有 2 种调度方式： OSSched() 被用于任务级。 OSIntExit()被用于中断级。由于中断产生时已经将任务 A 的状态保存在任务 A 的堆栈中，所以 ISR 返回时无需再保存任务 A 的状态，而是直接载入任务 B 的 CPU 寄存器到硬件CPU 寄存器中即可 </p><p>64、当 uC/OS-III 转向执行另一个任务的时候，它保存了当前任务的 CPU 寄存器到堆栈。并从新任务堆栈中 相关内容载入CPU 寄存器。这个过程叫做上下文切换。上下文切换需要一些开支。 CPU 的寄存器越多， 开支越大。 上下文切换的时间基本取决于有多少个 CPU 寄存器需要被存储和载人。保存状态寄存器和程序指针寄存器到当前的任务堆栈。保存的顺序与中断发生时 CPU 保存寄存器的顺序相同。</p><p>65、CPU 处理中断有两种模式： 1 所有的中断指向同一个 ISR2 每个中断指向各自的 ISR 。） ISR 的工作完成后， 用户必须调用 OSIntExit() 告诉 uC/OS-III中断服务程序已经完成。</p><p>66、uC/OS-III 有两种方法处理来自于中断的时间； 直接提交和延迟提交。其区别在于如何处置中断中所产生的事件。延迟提交的方式为事件不是直接发送给任务， 而是先发送到中断队列。 然后中断处理任务（其优先级为0）被就绪，这样，事件的提交便可在任务级完成，从而减少了ISR处理的时间。</p><p>67、uC/OS-III 必须有系统时基是普遍的误解。 事实上， 很多低功耗应用中没有系统时基，因为需额外的能量用于维护时基源。换句话说 ，将能量用于维护时基源是不合理的。因为 uC/OS-III 是一个可抢占式内核， 一个事件可以唤醒进入低功耗模式处理器（按键或其它事件）没有时基意味着用户不能再对任务进行延时或超时设置。 用户在研发低功耗产品时可以考虑这个特性。 </p><p>68、任务在挂起队列中是根据优先级分类的。 高优先级任务被</p><p>放置在队列的头部，低优先级任务被放置在队列的尾部。 </p><p>69、任务不是直接链接到挂起队列中， 而是通过叫OS_PEND_DATA 的结构体作为媒介。 这个媒介在任务被挂起时分配到任务堆栈的。挂起队列中的对应指针指向该结构体。</p><p>70、延时函数OSTimeDly()，任务调用这个函数后就会被挂起直到期满。以时基为单位，但需注意，当任务在时基中断将要到来时被挂起，那么实际的延时时基会少 1 个时基。这个函数可以有设置为三种模式：相对延时模式，周期性延时模式，绝对延时模式（用于对时间要求很高的应用）。 </p><p>71、uC/OS-III 定 时 器 的 分 辨 率 决 定 于 时 基 频率。定时器可以被设置为 3 种模式：一次性定时模式， 无初始定时周期模式，有初始定时周期模式 。如果定时器被停止， 那其定时值也将被停止， 直到定时器被恢复时，定时器值继续被递减。不能在定时器的执行代码中等待事件发生。否则定时器任务会被挂起，导致定时器任务崩溃。 </p><p>72、uC/OS-III 可能要维护上百个定时器。 使用定时器列表会大大降低更新定时器列表所占用的 CPU 时间。 定时器列表类似于时基列表，以二维数组的形式存储记录。</p><p>73、uC/OS-III提供关中断方式、锁调度器方式、、信号量方式、mutex方式保护共享资源。只有任务才允许使用信号量，ISR是不允许的。用信号量保护共享资源不会导致中断延迟。当任务在执行信号量所保护的共享资源时，ISR或高优先级任务可以抢占该任务。</p><p>74、信号量经常被过度使用。很多情况下，访问一个简短的共享资源时不推荐使用信号量，请求和释放信号量会消耗CPU时间。通过关/开中断能更有效地执行这些操作。信号量会导致一种严重的问题：优先级反转。</p><p>75、优先级反转是实时系统中的一个常见问题，仅存在于基于优先级的抢占式内核中。uC/OS-III支持一种特殊类型的二值信号量叫做mutex，用于解决优先级反转问题。</p><p>76、死锁，就是两个任务互相等待对方所占用的资源的情况。除一般的防死锁方式外，uC/OS-II还可以在申请信号量或mutex时允许设置其期限，这样能防止死锁，但是同样的死锁可能稍后再次出现。</p><p>77、uC/OS-III中用于同步的两种机制：信号量和事件标志组。两个任务间可以用一个信号量实现单向同步，用两个信号量实现双向同步。当任务要与多个事件同步时可以使用事件标志。若其中的任意一</p><p>个事件发生时任务被就绪，叫做逻辑或(OR)。若所有的事件都发生时任务被就绪，叫做逻辑与（AND）。</p><p>78、有些情况下任务或ISR与另一个任务间进行通信，这种信息交换叫做作业间的通信。可以有两种方法实现这种通信：全局变量、发送消息。需注意的是：任务与ISR通信只能通过全局变量。如果全局变量被ISR改变，任务将不会知道全局变量被改变，除非该任务检测该变量或者ISR标记任务告知该变量被改变。</p><p>79、消息可以被发送到媒介—消息队列中，也可以直接发送给任务，因为uC/OS-III中每个任务都有其内建的消息队列。如果多个任务等待这个消息时建议将该消息发送到外部的消息队列。当只有一个任务等待该消息时建议直接将消息发送给任务。</p><p>80、消息中包含一个指向数据的指针、该数据的大小、时间戳变量。该指针可以指向数据区域甚至是一个函数。当然，消息的发送方和消息的接收方都应该知道消息所包含的意义。</p><p>81、消息队列是先入先出模式（FIFO）。然而，uC/OS-III也可以将其设置为后入先出模式（LIFO）。若任务或ISR发送紧急消息给另一个任务时，后入先出模式是非常有用的，在这种情况下，该紧急消息绕过消息队列中的其他消息。</p><p> 82、任务A发送多个消息给任务B，如果更高优先级的任务抢占了任务B，那么任务A所存放在消息队列中的数据就可能被溢出。解决这个问题的一种方法是在处理中添加流量控制：所有任务在发送消息给任务B之前必须获得信号量。任务B消息队列的空余量为多少，信号量计数值就为多少。</p><p>83、任务可以等待多个内核对象。然而，uC/OS-III只允许任务同时等待多个信号量或消息队列。换句话说，不能同时等待多个事件标志组或mutex。但这将花费uC/OS-III较多时间去处理。</p><p>84、可以通过使用编译器提供的函数malloc()和free()动态地分配和释放内存快。然而，在嵌入式实时系统中使用malloc()和free()可能是非常危险的。因为它可能会导致很多内存碎片。</p><p>85、ucos-iii可以创建多个大小不同的内存分区，一个内存分区可被设置为多个大小相同的任务块，用于存储临时性的数据。根据需求设置，但内存块被分配后必须返回给它所在的内存分区，这种管理方式仅会导致内存块块内的碎片。从而减少了内存碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vivadoHLS（二）</title>
      <link href="/2018/12/09/hls2/"/>
      <url>/2018/12/09/hls2/</url>
      
        <content type="html"><![CDATA[<p>#HLS学习</p><p><img src="/2018/12/09/hls2/1539354344835.png" alt="1539354344835"></p><p>上图是HLS完整工作过程，其中Contraints/Directives是在软件里设置的，可以对同一份C语言转电路设计的时候实现全并行或全串行设计等设置。HLS最后生成IP核，可以在Vivado里打开。</p><h2 id="部分HLS-C语言约束（不完全版）"><a href="#部分HLS-C语言约束（不完全版）" class="headerlink" title="部分HLS C语言约束（不完全版）"></a>部分HLS C语言约束（不完全版）</h2><p><strong>HLS C语言体系中不支持的元素</strong></p><p>虽然在HLS中C语言的大部分特性被广泛支持，但是仍存在一部分不可综合的C语言代码。这些代码在向底层的设计转化过程中会产生错误。接下来将讨论HLS中C语言代码设计时的可综合性和在器件中的可执行性。</p><p>可综合的C语言代码具有以下特性：</p><p>1、C语言程序的组成部分全部为函数。</p><p>2、对操作系统层面有需求的函数不能被综合。</p><p>3、C语言构造必须是定长或者有边界的。</p><p>4.C语言构造的设计面对FPGA硬件执行层面是明确的。</p><p><strong>System Calls 系统调用</strong></p><p>系统调用的函数不能被综合的原因在于它们往往会在C语言程序执行的过程中执行基于操作系统层面的任务,而在FPGA底层不存在操作系统。</p><p>Vivado HLS在综合的时候自动忽视掉对算法不产生影响的常用系统调用函数，这些函数不需要在综合之前被移除，例如：</p><p>• abort()  • atexit()  • exit()  • fprintf()  • printf() </p><p>• perror()  • putchar()  • puts()  • time()  • sleep()  • getc()</p><p>不过通常来说，不可综合的代码理应在综合前被移除。可以利用如下的宏，确保不可综合的C代码不会被vivado HLS综合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macro:  __SYNTHESIS__</div></pre></td></tr></table></figure><p>具体例子，参见如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func4.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsub_func</span><span class="params">(<span class="keyword">din_t</span> *in1, <span class="keyword">din_t</span> *in2, <span class="keyword">dint_t</span> *outSum, <span class="keyword">dint_t</span> *outSub)</span></span></div><div class="line">&#123;</div><div class="line">*outSum = *in1 + *in2;</div><div class="line">*outSub = *in1 - *in2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_func</span><span class="params">(<span class="keyword">dint_t</span> *in1, <span class="keyword">dint_t</span> *in2, <span class="keyword">dout_t</span> *outA, <span class="keyword">dout_t</span> *outB)</span></span></div><div class="line">&#123;</div><div class="line">*outA = *in1 &gt;&gt; <span class="number">1</span>;</div><div class="line">*outB = *in2 &gt;&gt; <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func4</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">dint_t</span> apb, amb;</div><div class="line">sumsub_func(&amp;A,&amp;B,&amp;apb,&amp;amb);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYNTHESIS__</span></div><div class="line">FILE *fp1;<span class="comment">// The following code is ignored for synthesis</span></div><div class="line"><span class="keyword">char</span> filename[<span class="number">255</span>];</div><div class="line"><span class="built_in">sprintf</span>(filename,Out_apb_%<span class="number">03</span>d.dat,apb);</div><div class="line">fp1=fopen(filename,w);</div><div class="line"><span class="built_in">fprintf</span>(fp1, %d \n, apb);</div><div class="line">fclose(fp1);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">shift_func(&amp;apb,&amp;amb,C,D);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>值得注意的是</strong>：上述的宏仅作用于被综合的C代码，不适用于 test bench。因为这个宏不遵循C仿真和C/RTL仿真的规则。</p><p><strong>Dynamic Memory Usage 动态内存使用</strong></p><p>调用内存分配管理函数都是基于系统层面的，例如malloc(),alloc(),和free()函数都是在程序运行过程中利用操作系统内存的资源去创建和释放存储空间。为了可被综合，在硬件执行的设计上必须脱离操作系统支持，并且明确资源需求。</p><p>内存分配的系统调用代码必须在综合之前被移除。因为动态内存操作在设计流程中属于特有功能点，它们必须被转化为等价的有边界构造。接下来的例程将会展示如何设计一段可被综合的malloc()代码，顺带重点提示一下两点十分有用的代码设计技巧：</p><p>1.例程设计没有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__SYNTHESIS__    这个宏</div></pre></td></tr></table></figure><p>用户自定义宏NO_SYNTH用于选择可综合和不可综合代码版本。这样子就可以用同样的代码进行C仿真和Vivado HLS综合。</p><p>2.原本设计中用于malloc()函数的指针不用修改就可以指向有定长的数据结构。</p><p>有定长的数据结构可以被创建，现存的指针用于指向新的数据结构即可。这个技巧可以避免人为地对代码进行大篇幅改动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"malloc_removed.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="comment">//#define NO_SYNTH</span></div><div class="line"><span class="keyword">dout_t</span> malloc_removed(<span class="keyword">din_t</span> din[N], <span class="keyword">dsel_t</span> width) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_SYNTH</span></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> *out_accum = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</div><div class="line"><span class="keyword">int</span>* array_local = <span class="built_in">malloc</span> (<span class="number">64</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> _out_accum;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> *out_accum = &amp;_out_accum;</div><div class="line"><span class="keyword">int</span> _array_local[<span class="number">64</span>];</div><div class="line"><span class="keyword">int</span>* array_local = &amp;_array_local[<span class="number">0</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="keyword">int</span> i,j;</div><div class="line">LOOP_SHIFT:<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>; i++) &#123;</div><div class="line"><span class="keyword">if</span> (i&lt;width)</div><div class="line">*(array_local+i)=din[i];</div><div class="line"><span class="keyword">else</span></div><div class="line">*(array_local+i)=din[i]&gt;&gt;<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">*out_accum=<span class="number">0</span>;</div><div class="line">LOOP_ACCUM:<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>; j++) &#123;</div><div class="line">*out_accum += *(array_local+j);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> *out_accum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Pointer Limitations 指针限制</strong></p><p><strong><em>General Pointer Casting常规指针类型转换</em></strong>  </p><p>Vivado HLS 不支持常规意义上的指针类型转化。例如，当一个结构体被初始化，且其中的成员变量被定义为有符号数据类型时，结构体指针不能被转换为无符号数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line"><span class="keyword">short</span> first;</div><div class="line"><span class="keyword">short</span> second;</div><div class="line">&#125; pair;</div><div class="line"><span class="comment">// Not supported for synthesis</span></div><div class="line">*(<span class="keyword">unsigned</span>*)pair = <span class="number">-1</span>U;</div></pre></td></tr></table></figure><p>在这种情况下，结构体指针只能用原定义数据类型。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line"><span class="keyword">short</span> first;</div><div class="line"><span class="keyword">short</span> second;</div><div class="line">&#125; pair;</div><div class="line"><span class="comment">// Assigned value</span></div><div class="line">pair.first = <span class="number">-1</span>U;</div><div class="line">pair.second = <span class="number">-1</span>U;</div></pre></td></tr></table></figure><p>指针数组也能被综合，见下面例程：此例程中的指针数组用于存储一个全局数组第二维度的起始地址。指针数组的指针只能指向标量或标量数组，而不能指向其他指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pointer_array.h"</span></span></div><div class="line"><span class="keyword">data_t</span> A[N][<span class="number">10</span>];</div><div class="line"><span class="keyword">data_t</span> pointer_array(<span class="keyword">data_t</span> B[N*<span class="number">10</span>]) &#123;</div><div class="line"><span class="keyword">data_t</span> i,j;</div><div class="line"><span class="keyword">data_t</span> sum1;</div><div class="line"><span class="comment">// Array of pointers</span></div><div class="line"><span class="keyword">data_t</span>* PtrA[N];</div><div class="line"><span class="comment">// Store global array locations in temp pointer array</span></div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line">PtrA[i] = &amp;(A[i][<span class="number">0</span>]);</div><div class="line"><span class="comment">// Copy input array using pointers</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10</span>; ++j)</div><div class="line">*(PtrA[i]+j) = B[i*<span class="number">10</span> + j];</div><div class="line"><span class="comment">// Sum input array</span></div><div class="line">sum1 = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10</span>; ++j)</div><div class="line">sum1 += *(PtrA[i] + j);</div><div class="line"><span class="keyword">return</span> sum1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Recursive Functions递归函数</strong></p><p>无穷递归的递归函数不可被综合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">foo</span> <span class="params">(<span class="keyword">unsigned</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> (foo(n<span class="number">-2</span>) + foo(n<span class="number">-1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Vivado HLS不支持对数值进行无尽调用的尾递归函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">foo</span> <span class="params">(<span class="keyword">unsigned</span> m, <span class="keyword">unsigned</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</div><div class="line"><span class="keyword">return</span> foo(n, m%n);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>C Test Bench C测试台</strong></p><p>任何模块综合的第一步都是验证C函数的功能是否正确。这个步骤由测试台完成。设计一个好的测试台代码能极大程度上增加你的效率。</p><p>C函数执行比RTL仿真快。在综合之前使用C语言去开发和验证算法比开发RTL级代码更有效率。</p><p>Vivado HLS 重复利用C测试台去验证RTL设计。在使用Vivado HLS时不需要设计任何RTL测试台代码。如果测试台验证过了顶层函数的结果，RTL仿真也会同时通过验证。  </p><p><strong>注意：</strong>为测试台代码提供参数的时候，选择 Project &gt; Project Settings,点击Simulation ,使用Input Arguments 选项。Test Bench文件不支持交互式用户输入。Vivado HLS图形界面没有命令行控制台，也不支持在测试台程序执行的过程中接收用户输入。</p><p>Xilinx建议在综合的时候从测试台文件中将顶层函数分离出来，可以使用头文件。接下来的例程中hier_func函数对两个子函数进行调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsub_func</span><span class="params">(<span class="keyword">din_t</span> *in1, <span class="keyword">din_t</span> *in2, <span class="keyword">dint_t</span> *outSum, <span class="keyword">dint_t</span> *outSub)</span></span></div><div class="line">&#123;</div><div class="line">*outSum = *in1 + *in2;</div><div class="line">*outSub = *in1 - *in2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_func</span><span class="params">(<span class="keyword">dint_t</span> *in1, <span class="keyword">dint_t</span> *in2, <span class="keyword">dout_t</span> *outA, <span class="keyword">dout_t</span> *outB)</span></span></div><div class="line">&#123;</div><div class="line">*outA = *in1 &gt;&gt; <span class="number">1</span>;</div><div class="line">*outB = *in2 &gt;&gt; <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">dint_t</span> apb, amb;</div><div class="line">sumsub_func(&amp;A,&amp;B,&amp;apb,&amp;amb);</div><div class="line">shift_func(&amp;apb,&amp;amb,C,D);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顶层函数可以包含多个子函数。只能有一个顶层函数被综合。为了综合多个函数，可以把这些函数都放在一个顶层函数里调用。</p><p>为了综合hier_func这个函数：</p><p>1.添加上述例程到Vivado HLS工程里作为设计文件。</p><p>2.声明hier_func为顶层函数。</p><p>综合之后：</p><p>• 传递给顶层函数的参数被综合为RTL引脚。</p><p>• 顶层函数里包含的子函数被综合成分层次的模块。</p><p>下述头文件为上述例程的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HIER_FUNC_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _HIER_FUNC_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_TRANS 40</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">din_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">dint_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">dout_t</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>这个头文件包含了很多原设计文件里面没有的定义（比如NUM_TRANS）。这些定义是用于测试台文件，测试台文件同样包含这个头文件。</p><p>下述代码是这个工程里的测试台文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// Data storage</span></div><div class="line"><span class="keyword">int</span> a[NUM_TRANS], b[NUM_TRANS];</div><div class="line"><span class="keyword">int</span> c_expected[NUM_TRANS], d_expected[NUM_TRANS];</div><div class="line"><span class="keyword">int</span> c[NUM_TRANS], d[NUM_TRANS];</div><div class="line"><span class="comment">//Function data (to/from function)</span></div><div class="line"><span class="keyword">int</span> a_actual, b_actual;</div><div class="line"><span class="keyword">int</span> c_actual, d_actual;</div><div class="line"><span class="comment">// Misc</span></div><div class="line"><span class="keyword">int</span> retval=<span class="number">0</span>, i, i_trans, tmp;</div><div class="line">FILE *fp;</div><div class="line"><span class="comment">// Load input data from files</span></div><div class="line">fp=fopen(tb_data/inA.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">a[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line">fp=fopen(tb_data/inB.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">b[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line"><span class="comment">// Execute the function multiple times (multiple transactions)</span></div><div class="line"><span class="keyword">for</span>(i_trans=<span class="number">0</span>; i_trans&lt;NUM_TRANS<span class="number">-1</span>; i_trans++)&#123;</div><div class="line"><span class="comment">//Apply next data values</span></div><div class="line">a_actual = a[i_trans];</div><div class="line">b_actual = b[i_trans];</div><div class="line">hier_func(a_actual, b_actual, &amp;c_actual, &amp;d_actual);</div><div class="line"><span class="comment">//Store outputs</span></div><div class="line">c[i_trans] = c_actual;</div><div class="line">d[i_trans] = d_actual;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Load expected output data from files</span></div><div class="line">fp=fopen(tb_data/outC.golden.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">c_expected[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line">fp=fopen(tb_data/outD.golden.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">d_expected[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line"><span class="comment">// Check outputs against expected</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_TRANS<span class="number">-1</span>; ++i) &#123;</div><div class="line"><span class="keyword">if</span>(c[i] != c_expected[i])&#123;</div><div class="line">retval = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(d[i] != d_expected[i])&#123;</div><div class="line">retval = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Print Results</span></div><div class="line"><span class="keyword">if</span>(retval == <span class="number">0</span>)&#123;</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line"><span class="built_in">printf</span>( Results are good \n);</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line"><span class="built_in">printf</span>( Mismatch: retval=%d \n, retval);</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Return 0 if outputs are correct</span></div><div class="line"><span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="池化和卷积HLS-C语言代码"><a href="#池化和卷积HLS-C语言代码" class="headerlink" title="池化和卷积HLS C语言代码"></a>池化和卷积HLS C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//池化代码main函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pool_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE 0<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_WIDTH 6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_HEIGHT 6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_CH 1</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_WIDTH 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_HEIGHT 3</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_WIDTH (IN_WIDTH/KERNEL_WIDTH)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_HEIGHT (IN_HEIGHT/KERNEL_HEIGHT)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">Dtype_f feature_in[IN_HEIGHT][IN_WIDTH][IN_CH];</div><div class="line">Dtype_f feature_out[OUT_HEIGHT][OUT_WIDTH][IN_CH];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;IN_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;IN_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line">feature_in[i][j][<span class="built_in">cin</span>]=i*IN_WIDTH+j;</div><div class="line"></div><div class="line">Pool(IN_CH,IN_HEIGHT,IN_WIDTH,</div><div class="line">KERNEL_WIDTH,KERNEL_HEIGHT,MODE,</div><div class="line">feature_in[<span class="number">0</span>][<span class="number">0</span>],feature_out[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">);<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;OUT_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;OUT_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;IN_CH;<span class="built_in">cout</span>++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OUT[%d][%d][%d]=%f\n"</span>,i,j,<span class="built_in">cout</span>,feature_out[i][j][<span class="built_in">cout</span>]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//池化代码池化函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pool_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a&gt;b)?a:b)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a&gt;b)?b:a)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pool</span><span class="params">(ap_uint&lt;<span class="number">16</span>&gt; CHin,ap_uint&lt;<span class="number">16</span>&gt; Hin,ap_uint&lt;<span class="number">16</span>&gt; Win,</span></span></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; Kx,ap_uint&lt;<span class="number">8</span>&gt; Ky,ap_uint&lt;<span class="number">2</span>&gt; mode,</div><div class="line">Dtype_f feature_in[],Dtype_f feature_out[]</div><div class="line">)<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_out offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_in offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Win</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Kx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Hin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=mode</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Ky</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=return</span></div><div class="line">ap_uint&lt;<span class="number">16</span>&gt; Hout,Wout;</div><div class="line">Wout=Win/Kx;</div><div class="line">Hout=Hin/Ky;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;CHin;c++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hout;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Wout;j++)</div><div class="line">&#123;</div><div class="line">Dtype_f sum;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)</div><div class="line">sum=<span class="number">99999999999999999</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">sum=<span class="number">-99999999999999999</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;Ky;ii++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;Kx;jj++)</div><div class="line">&#123;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; h=i*Ky+ii;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; w=j*Kx+jj;</div><div class="line"><span class="keyword">switch</span>(mode)</div><div class="line">&#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;sum+=feature_in[h*CHin*Win+w*CHin+c];<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;sum=min(sum,feature_in[h*CHin*Win+w*CHin+c]);<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;sum=max(sum,feature_in[h*CHin*Win+w*CHin+c]);<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">sum=sum/(Kx*Ky);</div><div class="line">feature_out[i*Wout*CHin+j*CHin+c]=sum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//卷积代码main函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conv_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_WIDTH 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_HEIGHT 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_CH 16</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_WIDTH 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_HEIGHT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> X_STRIDE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_STRIDE 1</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RELU_EN  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE     0          <span class="comment">//0:VALID, 1:SAME</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> X_PADDING (MODE?(KERNEL_WIDTH-1)/2:0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_PADDING (MODE?(KERNEL_HEIGHT-1)/2:0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_CH 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_WIDTH ((IN_WIDTH+2*X_PADDING-KERNEL_WIDTH)/X_STRIDE+1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_HEIGHT ((IN_HEIGHT+2*Y_PADDING-KERNEL_HEIGHT)/Y_STRIDE+1)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">Dtype_f feature_in[IN_HEIGHT][IN_WIDTH][IN_CH];</div><div class="line">Dtype_w W[KERNEL_HEIGHT][KERNEL_WIDTH][IN_CH][OUT_CH];</div><div class="line">Dtype_w bias[OUT_CH];</div><div class="line">Dtype_f feature_out[OUT_HEIGHT][OUT_WIDTH][OUT_CH];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;IN_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;IN_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line">feature_in[i][j][<span class="built_in">cin</span>]=i*IN_WIDTH+j;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;KERNEL_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;KERNEL_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">W[i][j][<span class="built_in">cin</span>][<span class="built_in">cout</span>]=i*KERNEL_WIDTH+j;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">bias[<span class="built_in">cout</span>]=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"1234\n"</span>);</div><div class="line"></div><div class="line">Conv(IN_CH,IN_HEIGHT,IN_WIDTH,OUT_CH,</div><div class="line">KERNEL_WIDTH,KERNEL_HEIGHT,X_STRIDE,Y_STRIDE,MODE,RELU_EN,</div><div class="line">feature_in[<span class="number">0</span>][<span class="number">0</span>],W[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>],bias,feature_out[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;OUT_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;OUT_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OUT[%d][%d][%d]=%f\n"</span>,i,j,<span class="built_in">cout</span>,feature_out[i][j][<span class="built_in">cout</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//卷积代码卷积函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conv_core.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//Feature: [H][W][C]</span></div><div class="line"><span class="comment">//kernel: [Ky][Kx][CHin][CHout]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conv</span><span class="params">(ap_uint&lt;<span class="number">16</span>&gt; CHin,ap_uint&lt;<span class="number">16</span>&gt; Hin,ap_uint&lt;<span class="number">16</span>&gt; Win,ap_uint&lt;<span class="number">16</span>&gt; CHout,</span></span></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; Kx,ap_uint&lt;<span class="number">8</span>&gt; Ky,ap_uint&lt;<span class="number">8</span>&gt; Sx,ap_uint&lt;<span class="number">8</span>&gt; Sy,ap_uint&lt;<span class="number">1</span>&gt; mode,ap_uint&lt;<span class="number">1</span>&gt; relu_en,</div><div class="line">Dtype_f feature_in[],Dtype_w W[],Dtype_w bias[],Dtype_f feature_out[]</div><div class="line">)<span class="comment">//mode: 0:VALID, 1:SAME</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//#pragma HLS PIPELINE enable_flush</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_out offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=bias offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=W offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_in offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=relu_en</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHout</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Sx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Hin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Kx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=mode</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Sy</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Ky</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Win</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=return</span></div><div class="line"></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; pad_x,pad_y;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">pad_x=<span class="number">0</span>;pad_y=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">pad_x=(Kx<span class="number">-1</span>)/<span class="number">2</span>;pad_y=(Ky<span class="number">-1</span>)/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">ap_uint&lt;<span class="number">16</span>&gt; Hout,Wout;</div><div class="line">Wout=(Win+<span class="number">2</span>*pad_x-Kx)/Sx+<span class="number">1</span>;</div><div class="line">Hout=(Hin+<span class="number">2</span>*pad_y-Ky)/Sy+<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;CHout;<span class="built_in">cout</span>++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hout;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Wout;j++)</div><div class="line">&#123;</div><div class="line">Dtype_acc sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;Ky;ii++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;Kx;jj++)</div><div class="line">&#123;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; h=i*Sy-pad_y+ii;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; w=j*Sx-pad_x+jj;</div><div class="line"><span class="keyword">if</span>(h&gt;=<span class="number">0</span> &amp;&amp; w&gt;=<span class="number">0</span> &amp;&amp; h&lt;Hin &amp;&amp; w&lt;Win)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;CHin;<span class="built_in">cin</span>++)</div><div class="line">&#123;</div><div class="line"><span class="comment">//Feature [H][W][C]</span></div><div class="line"><span class="comment">//kernel: [Ky][Kx][CHin][CHout]</span></div><div class="line"><span class="comment">//Dtype_mul tp=feature_in[h][w][cin]*w[ii][jj][cin][cout];</span></div><div class="line"><span class="comment">//std::cout&lt;&lt;"h:"&lt;&lt;h&lt;&lt;",w"&lt;&lt;w&lt;&lt;",cin"&lt;&lt;cin&lt;&lt;"\n";</span></div><div class="line"><span class="comment">//std::cout&lt;&lt;"feature_in["&lt;&lt;h*CHin*Win+w*CHin+cin&lt;&lt;"]*W["&lt;&lt;ii*Kx*CHin*CHout+jj*CHin*CHout+cin*CHout+cout&lt;&lt;"]\n";</span></div><div class="line">Dtype_mul tp=feature_in[h*CHin*Win+w*CHin+<span class="built_in">cin</span>]*W[ii*Kx*CHin*CHout+jj*CHin*CHout+<span class="built_in">cin</span>*CHout+<span class="built_in">cout</span>];</div><div class="line">sum+=tp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sum+=bias[<span class="built_in">cout</span>];</div><div class="line"><span class="keyword">if</span>(relu_en &amp; sum&lt;<span class="number">0</span>)</div><div class="line">sum=<span class="number">0</span>;</div><div class="line"><span class="comment">//feature_out[i][j][cout]=sum;</span></div><div class="line">feature_out[i*Wout*CHout+j*CHout+<span class="built_in">cout</span>]=sum;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VivadoHLS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>四旋翼PID调参笔记</title>
      <link href="/2018/10/30/%E5%9B%9B%E6%97%8B%E7%BF%BCPID%E8%B0%83%E5%8F%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/30/%E5%9B%9B%E6%97%8B%E7%BF%BCPID%E8%B0%83%E5%8F%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="飞行器PID整定学习"><a href="#飞行器PID整定学习" class="headerlink" title="飞行器PID整定学习"></a>飞行器PID整定学习</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>以下仅为学习笔记整理，资料整理自 <a href="http://www.yanjuntech.cn/" target="_blank" rel="external">http://www.yanjuntech.cn/</a> 以及 <a href="http://blog.sina.com.cn/antinformation" target="_blank" rel="external">http://blog.sina.com.cn/antinformation</a></p><h2 id="一、PID控制器的简介"><a href="#一、PID控制器的简介" class="headerlink" title="一、PID控制器的简介"></a>一、PID控制器的简介</h2><p>目前工业自动化水平已经成为衡量各行各业现代化水平的一个重要标志。同时控制理论的发展也经历了古典控制理论-现代控制理论-智能控制理论三个阶段。自动控制系统可分为开环控制系统和闭环控制系统。整个控制系统包括：控制器（CPU）、传感器、输入输出接口、执行机构等部分组成。</p><p>工业生产过程中，对于生产装置的温度、压力、流量、液位等工艺变量常常要求维持在恒定的数值上，或按一定的规律变化，以满足生产工艺的要求。PID控制器是根据PID控制原理对整个控制系统进行偏差调节，从而使被控变量的实际值与工艺要求的给定值一致。</p><p>而PID的是英文Proportion（比例）-Integral（积分）-Differential（微分）的英文首字母，其中文名称是：比例-积分-微分控制器。</p><p>PID 可谓是相当经典的一种控制策略，据我所知目前涉及到自动控制的很多场景都在使用 PID 控制器。（也有其他高级控制器，比如自抗扰ADRC控制算法）PID控制器的问世至今已有70年历史，它以结构简单、稳定性好、工作可靠、调整方便而成为工业控制的主要技术之一。而当被控对象的结构和参数不能完全掌握，或者说得不到精确的数学模型的时候，控制理论的其他技术将难以采用，系统控制器的结构和参数必须依靠经验和现场调试来确定时，PID控制技术可能是比较理想的控制方案。也就是说当我们不了解一个系统和被控制对象，或者不能通过有效的手段来获得系统参数时，最适用使用PID控制技术。PID控制技术根据实际需要还可以分为P控制PI控制PD控制以及其他的优化变形。PID控制器其实就是根据系统的偏差，利用比例环节、积分环节、微分环节计算出控制量进行控制的。</p><p>PID控制器的算法实现不是难点，难点是 PID参数的整定调试。一般工程人员采用的都是经验法调试，如果经验不足则可能很难找到合适的参数。本文我们将使用微型四轴以及自平衡小车为PID调试载体，带大家了解PID的参数整定过程。</p><h2 id="二、PID相关名词解释"><a href="#二、PID相关名词解释" class="headerlink" title="二、PID相关名词解释"></a>二、PID相关名词解释</h2><p>首先给大家解释一下相关的名词，我们下面会用到这些东西。</p><p><strong>1.PID</strong></p><p>PID的是英文Proportion（比例）-Integral（积分）-Differential（微分）的英文首字母，其中文名称是：比例-积分-微分控制器。</p><p><strong>2.被控对象</strong></p><p>在本篇文章中的控制对象就是微型四轴和我们的自平衡小车。我们将在第5部分和第六部分带着大家整定微型四轴和自平衡小车的PID参数。</p><p><strong>3.开环系统</strong></p><p>开环系统指的是被控对象的输出（被控制量）对控制器的输出没有影响， 在这种控制系统中，没有形成闭环回路。本次输出量没有进行反馈，不影响下次输出量。</p><p><strong>4.闭环系统</strong></p><p>闭环系统的特点是系统被控对象的输出（被控制量），会通过反馈通道返送回来影响控制器的输出，形成一个或者多个闭环系统（单环就是一个闭环，串级一般就是指两个闭环。而我们的微型四轴和自平衡小车使用的均是串级双环PID，其内环为角速度环，其外环为角度环）。闭环控制系统有正反馈和负反馈，如果反馈回来的信号数值符号与给定的信号相反，则称为负反馈。如果极性相同就称为正反馈，一般的闭环控制系统使用的都是负反馈。闭环控制系统用处特别特别的多，其不仅仅局限在技术领域，非技术领域比如一个团队的管理，一个公司的组织运营等等都离不开闭环系统。</p><p><strong>5.阶跃信号</strong></p><p>如下图，在t0时刻突然给一个信号，让其稳定在另一个值，这就是阶跃信号。信号从0变到1然后稳定为1，我们就称这个信号为单位阶跃信号。而当这个阶跃信号输入到一个系统中，我们会得到相应的输出而这个输出我们就称之为阶跃响应。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID2.jpg" alt="img"></p><p>图2.1 阶跃信号</p><p><strong>6.期望值</strong></p><p>期望值又称为给定值，或者说是目标值。在我们的四轴中期望值就是遥控器给定的值，我们四轴中遥控器的给定值就是目标角度和目标角速度。我们自平衡小车中的给定值也是给定的目标角度和目标角速度。与其对应的就是我们的传感器测量得出的实际值。</p><p><strong>7.偏差</strong></p><p>上述说到的目标值减去实际值就是我们的偏差值。</p><p><strong>8.系统中的稳态误差</strong></p><p>&amp;emsp&amp;emsp系统的稳态误差，我们平常又称之为静差。稳态误差指的是系统的响应进入问题后，系统的期望输出与实际输出之差。比如说我们的期望输出是1，但是输入信号经过了系统之后稳定下来的输出是0.9左右，这里的0.9就是实际值，而1就是期望的目标值。图2.2中，这三条响应曲线稳定后的输出均没有达到期望值，图上从5s之后的，期望值减去实际值就是系统的稳态误差又称静差。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID3.jpg" alt="img"></p><p>图2.2 稳态误差示意图</p><p><strong>9.控制系统的性能</strong></p><p>&amp;emsp&amp;emsp控制系统的性能可以用稳、准、快三个字来描述。稳指的是系统的稳定性，一个系统要能正常工作首要条件就是必须是稳定的。从阶跃响应来看应该是收敛的。准指的是系统的准确性，控制系统的精确度，通常我们使用稳态误差来描述，稳态误差越小其精确度越高也就是我们说的比较准确。快指的是控制系统响应的快速性，通常用上升时间来定量描述，下面这个图3种参数下的系统性能。</p><p>我们在进行PID参数整定的目的其实就是为了调节系统的稳、准、快这三个特性。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID4.jpg" alt="img"></p><p>图2.3不同参数下的系统性能</p><p>红线：</p><p>​    从图上，我们可以看出红线的超调比较大也就是稳定性最差，但是响应速度最快，稳态误差也很小。所以总结一下就是红线稳定性比较差，快速性很好，稳定性也很好。</p><p>紫线：</p><p>​    快速性还不错，就是稳态误差很大说明其准确性不好，其超调不大说明稳定性还不错。</p><p>绿线：</p><p>​    快速性最差，稳定性比较好，准确性也比较好。</p><p><strong>10.上升时间</strong></p><p>这里我们直接认为是 从一开始0% 到第一次达到目标值的时间100%。</p><h2 id="三、PID的理论基础"><a href="#三、PID的理论基础" class="headerlink" title="三、PID的理论基础"></a>三、PID的理论基础</h2><p>连续-时间PID控制系统如图3-1所示。图中D(s)为控制器，在PID控制系统中，D(s)完成PID控制规律，称之为PID控制器。PID控制器是一种线性控制器，PID控制器是偏差的时间函数。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID5.png" alt="img"></p><p>图3.1连续-时间PID控制系统</p><p>图3.1中的比例（Proportion）、积分（Integrate）、微分（Differentiation）的线性组合，构成控制量u(t),称为比例-积分-微分控制，简称PID控制。实际应用中，可以根据受控对象的特性和控制的性能要求，灵活的采用不同的控制组合。比如：</p><p>比例（P）控制器</p><p>​    u(t) = Kp e(t)        (公式-1)</p><p>比例+积分（PI）控制器</p><p>比例+积分+微分（PID）控制器</p><p>当然我们平常控制电机的时候也经常使用PD控制器，这里就不给大家列公式了。</p><p>​    上述公式是连续时间的函数，而我们的单片机运行程序实际上都是离散化的。我们在微型四轴和自平衡小车中调用PID函数调用周期就是2ms调用一次，也就是2ms离散化采样运算。</p><h2 id="四、数字PID算法"><a href="#四、数字PID算法" class="headerlink" title="四、数字PID算法"></a>四、数字PID算法</h2><p>在数字计算机直接数字控制中，PID控制器是通过计算机或者单片机实现的。计算机直接数字控制系统大多数都是采样-数据控制系统。进入计算机的连续-时间信号，必须经过采样和量化处理后，编程数质量，才能进入计算机的存储器和寄存器，而在数字计算机中的计算和处理，不论是积分还是微分，智能用数值计算去逼近。</p><p>在数字计算机中，PID控制规律的实现，也必须用数值逼近的方法。当采样周期相当短的时候，可以用求和代替积分，用差商代替微分，使PID算法离散化，将描述连续-时间PID算法的微分方程，变为描述离散-时间PID算法的差分方程。</p><p>A、位置式PID控制算法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID6.png" alt="img"></p><p>图4.1位置式PID控制算法的简化示意图</p><p>上式中我们使用替换法，用矩形积分时有：</p><p>​    如下图4.2所示，上式中就是矩形面积之和，得到的值近似于下图所示图形的面积。同时我们能知道只要Ts足够小，那么我们得到的近似值就越精确这就是积分的思想。</p><p>​    我们知道，微分实际上就是斜率，用差分代替微分有：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID7.jpg" alt="img"></p><p>图 4.2 矩形积分示意图</p><p>将上述积分和微分的代换公式代入PID控制器的全公式有：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID8.png" alt="img"></p><p>图4.3离散化PID公式1</p><p>或者写成如下形式：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID9.png" alt="img"></p><p>图4.4离散化PID公式2</p><p>式中u0—控制系统的控制量基准值，既k0时刻的控制量</p><p>u(k)    —— 第k时刻的控制量</p><p>Kp    —— 比例系数</p><p>Ki    —— 积分系数</p><p>Kd    —— 微分系数</p><p>Ts    —— 采样周期</p><p>​    上式中是数字位置式PID形式，称为全量算法。算法中为了积分求和，我们需要在程序中设置一个变量将系统过去的所有偏差都加起来。这种控制算法得出的控制量是全量输出u(k),是控制量的绝对数值。在控制系统中，这种控制量确定了执行机构的位置例如阀门控制中，这种算法的输出对应的就是阀门开关的位置角度。所以我们称这种算法为”位置式PID”</p><p>B、增量式PID控制算法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID10.png" alt="img"></p><p>图4.5增量式PID控制算法的简化示意图</p><p>​    由位置式算法可以求出u(k)：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID11.png" alt="img"></p><p>​    我们接下来再求出u(k-1)</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID12.png" alt="img"></p><p>两式相减，得到控制量的增量算法：</p><p>代入并化简合并得：</p><p>从上式可以看出，上式已经看不出P、I、D左右的直接关系。我们只要储存最近的三个误差采样值e(k)、e(k-1)、e(k-2)就够了</p><h2 id="五、改进的PID控制器"><a href="#五、改进的PID控制器" class="headerlink" title="五、改进的PID控制器"></a>五、改进的PID控制器</h2><p>在实际的应用中，基本的PID控制器往往效果不够完美。我们需要使用改进型的PID控制器，下面将给大家介绍几种实用的PID控制器的变形。这里我们YJ团队常用的就是位置式PID控制器</p><p><strong>A、PID输出饱和限幅</strong></p><p>实际的系统中，存在着饱和特性。当输入量达到一定值之后，控制系统的输出将不再增长，系统进入饱和区。这就要求控制系统的输出必须在谋和范围之内，也就是：</p><p>Umin &lt; U &lt; Umax</p><p>在程序中，在最后输出时使用if-else判断即可实现上述的PID输出饱和限幅。代码如下：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID13.png" alt="img"></p><p>图4.6 PID输出饱和限幅</p><p><strong>B、积分饱和</strong></p><p>在位置式PID中，”饱和”主要是由积分项过大引起的。这里我们称之为”积分饱和”，通常积分项不应该太大，我们应该限制其值。这里我们使用的是抗饱和积分法：</p><p>当我们的积分项大于最大的积分值的时候，我们的积分项只负责累加负的偏差值。而当我们的积分项小于最小的积分值的时候，我们的积分项只负责累加正的偏差值。从而实现抗饱和积分。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID14.png" alt="img"></p><p>图4.7PID抗饱和积分</p><p><strong>C、积分分离</strong></p><p>在偏差较大的时候不进行积分作用，只有当偏差在一定的范围时才进行积分作用。这里我们采用的就是积分分离的方法。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/E:/FileRecv\hexo\PortableHexo\hexo\source\_posts\四旋翼PID调参笔记\070118_0724_PID15.png" alt="img"></p><p>式中，我们K1就是计算的输出结果是否需要积分的标志位。</p><p>式中就是偏差的阈值。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID16.png" alt="img"></p><p>图4.8积分分离效果图</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID17.png" alt="img"></p><p>4.9积分分离c语言代码1</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID18.png" alt="img"></p><p>图4.10积分分离c语言代码2</p><h2 id="六、PID的c语言实现"><a href="#六、PID的c语言实现" class="headerlink" title="六、PID的c语言实现"></a>六、PID的c语言实现</h2><p>这里我建议大家根据位置式离散化的PID公式读一下下面的代码，很简单的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*                               YanJunFly V1.0 - Copyright (c) 2017</div><div class="line">* All rights reserved.More information please browse www.yanjun.tech</div><div class="line">*                  燕骏智控——以极客技术推进工程教育</div><div class="line">*             手把手教你，如何从头开始做一个电子设计类项目。</div><div class="line">* 我们将以 四轴飞行器 为项目载体，带领大家进行项目式学习,做出属于自己的四旋翼。</div><div class="line">*</div><div class="line">* 文件名称：Pid.c, Pid.h</div><div class="line">* 文件摘要：无</div><div class="line">* 注意事项：无</div><div class="line">*                       </div><div class="line">* 当前版本：v1.0</div><div class="line">* 当前作者：石雄涛</div><div class="line">* 完成日期：2017-3-16 17:45:05</div><div class="line">* 改动说明：创建文件</div><div class="line">*</div><div class="line">* 取代版本：无</div><div class="line">* 原 作 者：石雄涛</div><div class="line">* 完成日期：2017-3-16 17:45:05</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Pid/pid.h"</span></span></div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*函数名称：void vCleanxp_Pid(PID_Typedef * xp_Pid)</div><div class="line">*函数功能：xp_Pid清除函数,把历史的xp_Pid计算值，清零</div><div class="line">*</div><div class="line">*使用说明：无</div><div class="line">*入口参数：xp_Pid:要进行清零的xp_Pid指针</div><div class="line">*返 回 值：无</div><div class="line">*</div><div class="line">*当前作者：石雄涛</div><div class="line">*创建日期：2017-3-16 17:45:12</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCleanPid</span><span class="params">(PID_Typedef * xp_Pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* 清除偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除上一次的偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err_last = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除上上次的偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err_last_last = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除微分值 */</span></div><div class="line">    xp_Pid-&gt;f_differential = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除积分值 */</span></div><div class="line">    xp_Pid-&gt;f_integral = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除是否需要积分标志位 */</span></div><div class="line">    xp_Pid-&gt;ui_isNeedKi = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除PID输出值 */</span></div><div class="line">    xp_Pid-&gt;f_OUT = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*函数名称：void vCalculatexp_Pid(PID_Typedef * xp_Pid)</div><div class="line">*函数功能：pid计算函数</div><div class="line">*</div><div class="line">*使用说明：无</div><div class="line">*入口参数：xp_Pid计算函数</div><div class="line">                    在调用这个函数之前 xp_Pid 应该提前准备好</div><div class="line">                    1.偏差值</div><div class="line">                    2.微分值</div><div class="line">                    在这个函数里面不再进行计算，在外面直接计算好</div><div class="line">                    关于xp_Pid参数正负的说明</div><div class="line">                    假如现在偏差值是5，上次偏差值是10，这是调节器在作用，这是真实的情况</div><div class="line">                    假如P参数是+的</div><div class="line">                    那么I参数是+的</div><div class="line">                    那么D参数是-的</div><div class="line">*返 回 值：无</div><div class="line">*</div><div class="line">*当前作者：石雄涛</div><div class="line">*创建日期：2017-3-16 17:45:12</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCalculatexp_Pid</span><span class="params">(PID_Typedef * xp_Pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* 先来判断是否要使用微分先行 微分先行使用与输入经常性的变动的xp_Pid控制 */</span></div><div class="line">    <span class="keyword">if</span>(xp_Pid-&gt;ui_isUseDifferentialAhead)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 使用微分先行策略 积分分离 抗饱和积分 */</span></div><div class="line">        <span class="comment">/* 暂时还没有实现 微分先行 因为 这块 一直没有用到 */</span></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 不使用微分先行策略 积分分离 抗饱和积分 */</span></div><div class="line">        </div><div class="line">        <span class="comment">/* 如果此时的偏差值太大了，那么取消积分项 */</span></div><div class="line">        <span class="keyword">if</span>(((xp_Pid -&gt;f_err) &gt; (xp_Pid -&gt; f_IntegralSeparation)) || ((xp_Pid -&gt; f_err) &lt; (-(xp_Pid -&gt; f_IntegralSeparation))))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 取消积分项 */</span></div><div class="line">            xp_Pid -&gt; ui_isNeedKi = <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 保留积分项 */</span></div><div class="line">            xp_Pid -&gt; ui_isNeedKi = <span class="number">1</span>;</div><div class="line">           <span class="comment">/*-------------------积分分离和抗饱和积分----------------------------*/</span></div><div class="line">            <span class="comment">/* xp_Pid积分达到最大值，如果xp_Pid的输出大于抗饱和积分的输出了 */</span></div><div class="line">            <span class="keyword">if</span>((xp_Pid -&gt; f_integral) &gt; (xp_Pid -&gt; f_AntiSaturationIntegral))                                                   </div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 抗饱和积分 */</span></div><div class="line">                <span class="keyword">if</span>((xp_Pid -&gt; f_err) &lt; <span class="number">0</span>)                                           </div><div class="line">                &#123;</div><div class="line">                    <span class="comment">/* 只累加负值 */</span></div><div class="line">                    xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                          </div><div class="line">                &#125;</div><div class="line">            <span class="comment">/* xp_Pid积分达到负的最大值，如果xp_Pid的输出大于负的抗饱和积分的输出了 */</span></div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((xp_Pid -&gt; f_integral) &lt; -(xp_Pid -&gt; f_AntiSaturationIntegral))</div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 抗饱和积分 */</span></div><div class="line">                <span class="keyword">if</span>((xp_Pid -&gt; f_err) &gt; <span class="number">0</span>)                                           </div><div class="line">                &#123;</div><div class="line">                    <span class="comment">/* 只累加正值 */</span></div><div class="line">                    xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                          </div><div class="line">                &#125;</div><div class="line">            <span class="comment">/* xp_Pid积分正常，如果xp_Pid的输出正常 */</span></div><div class="line">            &#125;<span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 积分值得大小正常，累加误差积分 */</span></div><div class="line">                xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                              </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/* 计算xp_Pid输出 */</span></div><div class="line">        <span class="keyword">if</span>(xp_Pid -&gt; ui_isNeedKi)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* xp_Pid输出 = 比例*偏差 + 积分*偏差积分 + 微分*偏差微分 */</span></div><div class="line">            xp_Pid -&gt; f_OUT = (((xp_Pid -&gt; f_Kp) * (xp_Pid -&gt; f_err)) + ((xp_Pid -&gt; f_Ki) * (xp_Pid -&gt; f_integral)) + ((xp_Pid -&gt; f_Kd) * (xp_Pid -&gt; f_differential)));</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* xp_Pid输出 = 比例*偏差 + 微分*偏差微分 */</span></div><div class="line">            xp_Pid -&gt; f_OUT = (((xp_Pid -&gt; f_Kp) * (xp_Pid -&gt; f_err)) + ((xp_Pid -&gt; f_Kd) * (xp_Pid -&gt; f_differential)));                                   </div><div class="line">        &#125;   </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/* xp_Pid输出限幅 */</span></div><div class="line">    <span class="keyword">if</span>(xp_Pid-&gt;ui_isNeedLimitPidOut)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 判断PID输出和正负限幅值之间的关系 */</span></div><div class="line">        <span class="keyword">if</span>((xp_Pid-&gt;f_OUT) &gt; (xp_Pid-&gt;f_pidOutLimitPlus)) </div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果大于正限幅值 就让PID输出值是正限幅值 */</span></div><div class="line">            xp_Pid-&gt;f_OUT = xp_Pid-&gt;f_pidOutLimitPlus;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((xp_Pid-&gt;f_OUT) &lt; (xp_Pid-&gt;f_pidOutLimitMinus))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果小于负限幅值 就让PID输出值是负限幅值 */</span></div><div class="line">            xp_Pid-&gt;f_OUT = (xp_Pid-&gt;f_pidOutLimitMinus);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* end of file cppyright reserve by team of yanjun ,More information please browse www.yanjun.tech */</span></div></pre></td></tr></table></figure><p>头文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PID_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _PID_H</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Sys/system.h"</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Kp;                                                   <span class="comment">//比例系数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Ki;                                                   <span class="comment">//积分系数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Kd;                                                   <span class="comment">//微分系数</span></div><div class="line">    <span class="keyword">float</span> f_integral;                                                   <span class="comment">//积分值</span></div><div class="line">    <span class="keyword">float</span> f_err;                                                                <span class="comment">//本次偏差</span></div><div class="line">    <span class="keyword">float</span> f_err_last;                                                       <span class="comment">//上次偏差</span></div><div class="line">    <span class="keyword">float</span> f_err_last_last;                                          <span class="comment">//上上次偏差</span></div><div class="line">    <span class="keyword">uint32_t</span> ui_isNeedKi;                                               <span class="comment">//是否需要积分，用于积分分离</span></div><div class="line">    <span class="keyword">float</span> f_differential;                                               <span class="comment">//本次微分值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_IntegralSeparation;                       <span class="comment">//积分分离阈值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_AntiSaturationIntegral;               <span class="comment">//抗饱和积分阈值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> ui_isUseDifferentialAhead;       <span class="comment">//是否使用微分先行的PID策略</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> ui_isNeedLimitPidOut;                    <span class="comment">//是否需要限制PID输出幅度</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_pidOutLimitPlus;                          <span class="comment">//PID正限幅值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_pidOutLimitMinus;                         <span class="comment">//PID负限幅值</span></div><div class="line">    <span class="keyword">float</span>   f_OUT;                                                              <span class="comment">//PID输出</span></div><div class="line">&#125;PID_Typedef;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCleanPid</span><span class="params">(PID_Typedef * xp_Pid)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCalculatexp_Pid</span><span class="params">(PID_Typedef * xp_Pid)</span></span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="comment">/* end of file cppyright reserve by team of yanjun ,More information please browse www.yanjun.tech */</span></div></pre></td></tr></table></figure><h2 id="七、PID的各参数规律"><a href="#七、PID的各参数规律" class="headerlink" title="七、PID的各参数规律"></a><strong>七、PID的各参数规律</strong></h2><p>这里以前我写过一篇博文不够完善，在这篇文章中我重新分析一遍。同时在我们文件夹中也提供了一个PID算法模拟软件，大家可以玩一下。原博客链接在这里：</p><p><a href="http://blog.csdn.net/zzw5945/article/details/53998859" target="_blank" rel="external">http://blog.csdn.net/zzw5945/article/details/53998859</a></p><p>这里先推荐大家看一个PID参数整定的gif，很形象生动大家一定要看。链接如下：</p><p><a href="https://en.wikipedia.org/wiki/PID_controller" target="_blank" rel="external">https://en.wikipedia.org/wiki/PID_controller#/media/File:PID_Compensation_Animated.gif</a></p><p><strong>A、Kp比例系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID19.jpg" alt="img"></p><p>图 7.1 分析Kp参数对系统响应的影响</p><p>如图：当Ki,Kd保持为常量时，改变Kp。图上在t = 1s时，给系统一个阶跃信号，然后调节Kp比例项的值。图中红线为Kp = 0.5时候的响应曲线，绿线为Kp = 1.1时候的响应曲线，紫线为Kp = 1.6时的响应曲线。（注：我认为上图有问题，纯比例Kp环节我认为是存在静差的。所以上图稳定的时候 应该和期望值之间有一定的稳态误差，如下图7.2所示。但是我没找到合适的图所以就用这个了）</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID20.png" alt="img"></p><p>图7.2 纯比例环节系统输出响应曲线</p><p>从图7.1进行分析，可以得到以下信息：</p><p>红线：</p><p>当Kp比例项较小时，响应无超调无震荡，上升时间较长，但是稳定时间很长，延时时间长。</p><p>绿线：</p><p>当Kp比例项增大时，响应有较小超调，上升时间明显缩短，稳定时间缩短。</p><p>紫线：</p><p>当Kp比例项足够大时，响应曲线超调较大，震荡很多次，上升时间继续缩短，但是稳定时间却增长了。</p><p>如果继续增大Kp值呢？？这里图上没有反应，但是我们可以推测一下：上升时间继续减小，超调继续增大，震荡次数增大，最终系统失控发散，系统性能恶化。所以调PID参数时一定要小心，Kp值不能过大。总结以下：Kp在一定范围内可以调节系统的快速性，但是会影响系统的稳定性，Kp也会影响到系统的准确性。</p><p><strong>B、Ki积分系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID21.png" alt="img"></p><p>图7.3 Kp = 5 Ki = 0时系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID22.png" alt="img"></p><p>图7.4 Kp = 5 Ki = 0.4时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID23.png" alt="img"></p><p>图7.5 Kp = 5 Ki = 1.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID24.png" alt="img"></p><p>图7.6 Kp = 5 Ki = 2.9时的系统输出响应</p><p>​    从图7.3、7.4、7.5、7.6这四幅图中，我们能从图上可以看出Ki是用来消除静差的。静差其实就是我们名词解释中的稳态误差。我们这里几幅图都使用的是控制变量法，控制Kp一致然后在不同的Ki参数下观察曲线的变化规律。我们可以看出在一定范围内，Ki增大将减小稳态误差（静差），但是从上面几幅图中我们也能看出Ki其实和Kp的作用类似，属于”+”作用，ki虽然在能减小静差，但是系统也会不稳定。总结一下ki的作用如下：</p><p>​    Ki在一定范围内调节能减小系统静差，增加系统的快速性，但是会降低系统的稳定性。当Ki过大时会引起系统的不稳定。</p><p><strong>C、Kd微分系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID25.png" alt="img"></p><p>图7.7 Kp Ki为定值，kd = 0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID26.png" alt="img"></p><p>图7.8 Kp Ki为定值，kd = 0.5时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID27.png" alt="img"></p><p>图7.9 Kp Ki为定值，kd = 1.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID28.png" alt="img"></p><p>图7.10 Kp Ki为定值，kd = 3.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID29.png" alt="img"></p><p>图7.11 Kd对系统输出响应影响</p><p>Kd的作用总结：Kd可以理解成阻尼系数。也就是在一定程度上可以抑制超调，减小超调量。但是能增强系统的稳定性，但是会稍微延长一定的上升时间也就是说会影响一点快速性。</p><h2 id="八、四轴与自平衡小车PID参数整定调试台"><a href="#八、四轴与自平衡小车PID参数整定调试台" class="headerlink" title="八、四轴与自平衡小车PID参数整定调试台"></a>八、四轴与自平衡小车PID参数整定调试台</h2><p><strong>A.微型四轴PID调试设备</strong></p><p>需要大家购买：6<em>6mm内径万向节</em>1如图8.1所示、M3<em>10mm铜柱</em>2个（外径是4.7mm），2020型材或者碳杆。要求2020型材中间的孔径能插入一个4.7mm外径的M3铜柱。这里型材至少买一根，如果买的多的话还应该买点2020型材角件进行固定，然后可以搭出一个底座架如图8.4所示。这里我们买的万向节是二维运动的，我们在做我们的微型四轴PID调试台的时候，调PID应该是单轴运动的。所以我们要通过铜柱将万向节的其中一个轴固定住，只让它一个轴运动（让铜柱抵住万向节，就能实现）如下图8.5所示，连接四轴和万向节使用的就是铜柱和螺母，连接万向节和型材使用的也是铜柱。</p><p>我们这调试台是为了微型四轴的调试而搭建的，如果是其他大型的四轴可能不能适用。得想其他办法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID30.png" alt="img"></p><p>图8.1万向节</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID31.png" alt="img"></p><p>图8.2型材</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID32.png" alt="img"></p><p>图8.3 2020角件型材铝</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID33.png" alt="img"></p><p>图8.4型材架</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID34.png" alt="img"></p><p>图8.5微型四轴PID调试架示意图</p><p><strong>B.Qav250穿越机PID调试设备</strong></p><p>这里我们的QAV250算是小型无人机，但是用上面那种调试设备就不是特别适合了。这里我们使用的是如下图所示的调试架，我们买了一个丝杠，然后将四轴绑在丝杠上进行调试的。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID35.jpg" alt="img"></p><p>图8.6 QAV250穿越机PID调试架示意图</p><p><strong>C.自平衡小车PID调试设备</strong></p><p>自平衡小车的调试最简单方便，不需要购买任何配件。调试的时候我们直接用腿直接夹住自平衡小车的车轮，让车的上部分运动就可以进行PID调试了。</p><h2 id="九、单级PID参数整定经验"><a href="#九、单级PID参数整定经验" class="headerlink" title="九、单级PID参数整定经验"></a>九、单级PID参数整定经验</h2><p>单级PID由于效果不如串级PID完美，我们以前使用过单级PID。但是自从串级PID玩习惯了之后一直都在用串级PID，所以我们讲解的重点是串级pid的调试方法。关于单级PID的整定经验，我这里简单给大家讲讲：（单级PID没有留下调试图片，所以不是特别好描述）。</p><p>​    调试PID时，我们需要使用电脑串口上位机显示出实际值曲线和目标给定值曲线。这里我们使用的上位机是YJ_Chart YJ串口上位机，单片机的串口与电脑YJ_Chart上位机通信的接口程序详见我们的debug.c文件。或者大家打开我们提供的四轴驱动工程代码，找到debug驱动工程即可进行学习了解。更多资料请访问我们的网站——www.yanjuntech.cn下载了解。</p><p>​    先总结一下我们的PID参数整定方法：</p><ol><li>如果只需要调节一个环的PID，也就是所谓的单级PID，我们直接使用下面这几点经验即可。如果是串级PID我们需要先调试内环，再调试外环。</li><li>首先我们通过写程序以及搭硬件调试设备，先单独的调试一个轴的PID参数</li><li>调节PID参数之前，我们需要明确我们的PID结构，需要明确输入量期望值，实际值的物理意义。比如四轴单级PID，输入量就是遥控器给定的目标角度，实际值就是通过姿态传感器解算出来的姿态角度。</li><li>调试PID参数之前，最最重要的就是一定要确定反馈回来的数据是正确的，如果反馈值不正确，再怎么调试PID参数都是徒劳的。所以调试之前一定要确定反馈量正确。</li><li>调节PID参数的时候，我们需要看 具体现象以及 实际值与目标期望值的曲线。（使用串口上位机，将数据发送到电脑上位机上打印曲线）</li><li>在调试Kp Ki Kd的时候，第一步要做的就是要确定好Kp Ki Kd参数的”+-“必须先确定正负，然后再开始调节PID参数。我们常用2种方法分析”+-“号，一种是理性分析法，一种是经验调试法。</li><li>理性分析法，比如四轴，总共4个电机，顺时针方向分别为1.2.3.4，也就是23和14在x轴方向上，12和34在y轴方向上。先假设四轴只单方向运动，假设按x轴方向运动，也就是向23或者14边运动。假设向23边偏此时实际的x轴角度数据为+23度，目标值是0度，那么偏差就是-23度。飞行器想稳定到0度，也就是23边的电机需要转动快一点，14边要慢一点。由比例环节就是kp*偏差，那么这时候就能根据这一点和最后的控制量输出来确定Kp的”+-“号。另一种方法就是 参数经验法了，直接控制其他两个系数为0，然后设置一个比较大一点的大概合理的值然后根据实际现象确定正负号。</li><li>单轴PID参数先从Kp进行调节，调节方法是1-2-4-8-16……先二倍法，然后使用二分法调节。观察现象如果发现Kp大了就减小一半，然后再在新的范围内调节。</li><li>Kp调试完成后再考虑是否调节Ki，是否需要消除静差。</li><li>微型四轴单级姿态环PID调试经验</li></ol><p>这里我们仅仅给大家介绍姿态环PID的调试经验，可能有的还需要高度环和位置环PID。我们在讲解的时候仅给大家讲解姿态环PID。</p><p>首先，我们微型四轴单级PID控制框图，了解一下基本的控制原理。这里输入的是期望角度，这个在实际应用中对应的是遥控器给定的目标角度（遥控器遥杆给定的值）。而反馈通道反馈回来的就是实际的姿态角度。然后目标角度和实际角度就存在偏差，偏差送入PID调节器进行调节，调节输出量作用在PWM电机上，电机的转速不同又间接影响到我们四轴的飞行姿态从而实现单级的闭环控制。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID36.png" alt="img"></p><p>图9.1 微型四轴的单级PID框图</p><ol><li>在调试PID参数之前，我们应该把要用到的程序都要搞好，同时确定好反馈量确实正确。也就是说已经做好了调试PID参数的所有准备工作。（再说一句：调试PID参数之前一定要确定好反馈量一定是正确的，这个很重要很重要）。</li><li>将微型四轴固定在我们准备好的硬件调试台上（只能绕一个轴运动，我们调试PID的时候都是一个轴一个轴调试-分轴调试），然后连接上jlink下载器和USB转串口线，打开YJ_Chart（我们将YJ_Chart也完全开源了）用于显示实际值和期望值曲线。在调试的过程中可以参考。</li><li>写好调试程序，可以将实际值和目标期望值打印到电脑上位机上这样我们就能定性的观看参数调试的效果曲线了。同时我们应该写好相应的基础程序，包括PID运算相关的程序。</li><li>我们要修改程序，调试四轴PID的时候，我们调试经验是一个轴一个轴的调试，所以我们需要注释掉其他轴代码，或者在最后的输出的时候，不加上其他轴的PID输出如下：</li></ol><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID37.png" alt="img"></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID38.png" alt="img"></p><p>图9.2 单轴PID代码片段</p><p>​    上面这个+-号实际是根据四轴的空气动力学来确定的，关于四轴中的空气动力学请见本文的第11部分。</p><p>​    整定四轴的姿态环PID，实际上整定的就是三轴姿态角的PID——俯仰角、横滚角、偏航角。整定时正如我们上面说的修改程序固定到调试架上用串口打印曲线，然后一个轴一个轴的调试。</p><p>单级PID参数整定举例——x轴参数整定</p><p>​    下面我拿x轴举例子，来进行PID调试。</p><p>​    我们的实际值其实就是遥控器给定的值，也就是所谓的期望值x_AttitudeTargetData.f_X（也要写相应的程序，用来获取遥控器的设定值）。而我们的实际值其实就是我们四轴的实际姿态x_AttitudeNow.x_AngleNow.f_X。计算PID运算伪代码就如下：</p><p>​    本次偏差 = 目标值 – 实际值;</p><p>​    本次微分 = 本次偏差 – 上次偏差;</p><p>​    上次偏差 = 本次偏差;</p><p>​    PID计算()函数，传入上述参数;</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID39.png" alt="img"></p><p>图9.3PID参数结构体</p><p>​    如图9.3所示，红框中的参数都是我们都是能进行手动设定的。最上面三个参数分别是Kp、Ki、Kd——比例积分微分系数。如果我们需要使用积分分离功能，则还要设置积分分离阈值同时也应该设置抗饱和积分阈值。最后的PID输出，我们应该设置好PID的输出阈值。</p><p>​    微型四轴的单级PID调试经验如下所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID40.png" alt="img"></p><p>图9.4微型四轴调试设备</p><ol><li>调试之前，一定要确定反馈值（实际值）是正确无误的。如果反馈信号有问题，根本就调不出来参数。</li><li>修改好程序，打开串口调试曲线软件。（单级的我没留调试过程中的图片，单级就简单口头说说，大家去看下面我写的串级的PID参数整定经验，那篇比较全）</li><li>目标值由遥控器设定的值，实际值是四轴的实际姿态角，修改Kp，使用2倍2分法。先确定好Kp的”+-“号。然后按1-2-4-8-16-32-64…这样二倍法调试，然后比如64的时候参数效果有点小，但是改成128的时候，发现效果有点过头了。那么我们需要使用二分法进行调试，找64和128的中间值：96然后再64-96内调试确定如果小了，在96-128中间进行二分法调试。</li><li>Kp调试效果简述：四轴调试角度应该是-30度–+30度范围内，如果角度比较大的时候，受到重力的影响比较大，参数整定就不准确效果不好了。我们把四轴放到-20度方向，然后改Kp参数，当Kp比较小的时候四轴表现的效果是软趴趴，到不了目标值0。当Kp比较大的时候，也就是快速超过目标值，停不下来。当参数比较合适的时候会在中心位置震荡（0度附近运动）。</li><li>大概能在目标值附近停住或者震荡，此时我们稍微再加Kd微分系数（也要确定好±），注意Kd效果是阻尼的效果，实际四轴效果是：当只有Kd比较大的时候，向x轴正方向运动假如4个电机顺时针分别是1.2.3.4号电机。假如向23电机方向快速运动，那么Kd正确的效果应该是 使电机的2.3号电机转动。以此确定Kd的方向。然后开始调试Kd的值，如果微分项没有除以采样时间（我们用的是0.002s采样时间），那么Kd值就比较大可能上百上千。如果微分项除以了采样时间，那么Kd值就比较小了。不加Kd，只有合适的Kp能在平衡位置震荡。而加上Kd之后，效果就很好了，能比较稳定了。</li><li>大家在上面的调试过程中，将目标值曲线和实际值曲线打印出来。来看看PID的整定规律。看曲线看看稳定后的实际值和目标值之间的静差（稳态误差）是否比较大。如果比较大，可能就需要加Ki参数，来调试。Ki调试过程实际看的是，稳定后的目标值与实际值之间静差的大小。把曲线打印出来，就能很好的观察调试参数。</li></ol><p>好了关于单级PID整定方法，我们就讲简单分享到这里。没有留下太多图片可能大家不是特别好理解，下面的串级PID参数整定，我留下的图片比较多，大家去看看串级PID参数的整定，相信你会有很大收获的。</p><ol><li><p>自平衡小车单级PID调试经验</p><p>自平衡小车的单级PID和微型四轴的单级PID参数调试经验差不多，这里不过多介绍了。自平衡小车的姿态环单级PID（自立PID） 目标值一般情况下都是0度，实际值就是小车的实际角度。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID41.png" alt="img"></p></li></ol><p>图9.2 自平衡小车的单级PID框图</p><h2 id="十、串级PID参数整定经验"><a href="#十、串级PID参数整定经验" class="headerlink" title="十、串级PID参数整定经验"></a>十、串级PID参数整定经验</h2><p>调试PID时，我们需要使用电脑串口上位机显示出实际值曲线和目标给定值曲线。这里我们使用的上位机是YJ_Chart YJ串口上位机，单片机的串口与电脑YJ_Chart上位机通信的接口程序详见我们的debug.c文件。或者大家打开我们提供的四轴驱动工程代码，找到debug驱动工程即可进行学习了解。更多资料请访问我们的网站——www.yanjuntech.cn下载了解</p><p>​    建议大家先读一下单级PID上面总结的一些实用经验。</p><ol><li>自平衡小车串级PID调试经验</li></ol><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID44.png" alt="img"></p><p>图10.1 自平衡小车串级PID框架</p><p>​    首先我们已经写好了所有基础程序，做好了准备工作。这里自平衡小车的PID整定过程中的效果曲线我记录的比较完整，所以这部分可以比较清晰的看明白。如图10.1所示，自平衡小车的姿态环串级PID有两个闭环，分别是内环——角速度环、外环角度环。我们在整定的时候是先整定内环角速度环，整定好了之后再来整定外环角度环的。</p><p>​    当然如果想实现自平衡小车稳定自立以及前进和拐弯的话，除了姿态环PID还需要速度环和转向环PID。这里我们为了省事，就拿姿态环的PID参数整定过程给大家讲解PID参数的整定经验。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID45.png" alt="img"></p><p>图10.2两轮自平衡小车实物图</p><p>​    我们插上USB线（板子上已经集成USB转串口芯片了），修改程序准备开调PID参数。我们调试的时候是先调内环也就是角速度环的PID参数，调试好后再调外环的PID参数。</p><ol><li>角速度内环整定经验</li></ol><p>首先改代码，改成内环调试用的代码。如下图10.3所示，内环调试时PID的内环给定设置成遥控器的给定值，也就是遥控器的给定设置成目标角速度。而实际值就是我们自平衡小车的实际运动角速度（陀螺仪测量出来的经过低通滤波的角速度）。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID46.png" alt="img"></p><p>图10.3角速度内环参数调试</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID47.png" alt="img"></p><p>图10.4角速度环发送到上位机</p><p>​    图10.4就是我们将目标角速度（遥控器设定的值）和实际角速度发送到电脑上位机上用曲线显示出来便于我们调试用。见下图10.5所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID48.png" alt="img"></p><p>图10.5遥控器给定值曲线-蓝线</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID49.png" alt="img"></p><p>图10.6小车实际角速度-黄线</p><p>​    如上图10.5和10.6所示，蓝线为遥控器控制的值也就是我们所说的目标值。黄线为平衡小车的实际角速度值打印出来的曲线也就是我们所说的实际值。看10.6，我们遥控器没有设置给定值，目标期望也就为0弧度/s，实际值是我们晃动小车，小车打印出来的实际角速度值。下面我们用腿夹住平衡小车的两个轮子，我们要开始调试平衡小车的内环角速度环的PID参数了如图10.7所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID50.png" alt="img"></p><p>图10.7用腿夹住小车两轮</p><p>​    我们下面开始调PID参数，先调Kp确定好Kp的符号，其他值保持为0：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID51.png" alt="img"></p><p>图10.8Kp = 10实际值与目标值曲线</p><p>​    当Kp = 10，太小了，改变目标期望值的时候，实际的角速度并没有变化，所以是Kp太小，效果太软。我们继续加Kp = 20；二倍法，如下图10.9所示：发现Kp = 20时，改变目标角速度，但是实际的角速度也并没有任何变化。所以值还是小，我们继续增大Kp 的值。继续使用二倍法，增加到Kp = 40；</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID52.png" alt="img"></p><p>图10.9 Kp = 20内环角速度调试</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID53.png" alt="img"></p><p>图10.9 Kp = 40内环角速度调试</p><p>​    我们可以看到Kp = 40，有效果了，但是力量依然不够还是小我们继续加大Kp = 80：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID54.png" alt="img"></p><p>图10.9 Kp = 80内环角速度调试</p><p>​    从图上我们可以看出，Kp = 80时还是有点小。我们继续增大一倍到160：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID55.png" alt="img"></p><p>图10.9 Kp = 160内环角速度调试</p><p>​    感觉效果有点过头，有点大了我们需要使用二分法砍到120然后看看效果。不够我们先继续增大到320，看看Kp过大是什么效果：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID56.png" alt="img"></p><p>图10.9 Kp = 320内环角速度调试</p><p>​    可以看到，Kp = 320时。系统已经很不稳定了崩溃了……，我们将Kp改小然后调试，我们发现的不错的效果值是Kp = 130。然后让我们加一点Kd，看看实际效果</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID57.png" alt="img"></p><p>图10.10 Kp = 130 Kd = 500内环角速度调试</p><p>​    当然大家如果再好好调调参数，效果比这个还好还是有可能的毕竟我们这里只是粗略的调试，到这个程度实际的效果就是用遥控器控制平衡小车，小车能按遥控器设置的角速度运动，我们可以通过遥控器控制小车停在竖直位置。下</p><p>​    到这个程度，就说明我们的内环就已经调试完毕了，下面我们要开始调试外环的角度环PID参数。</p><ol><li><p>角度外环参数整定经验</p><p>首先也是改程序，改成外环角度环调试的代码。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID58.png" alt="img"></p></li></ol><p>图10.11 角度外环调试代码</p><p>发送目标角度和实际角度数据到上位机。然后下面我们要开始调试了：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID59.png" alt="img"></p><p>图10.12 角度发送到上位机代码</p><p>​    首先要确定是外环的Kp系数的符号，外环一般只需要Kp比例系数就可以了。Kp可以增加系统的快速性，合适的外环Kp参数可以快速稳定到目标角度。一般外环的Kp比较小，内环的Kp比较大（系统有关和程序写的方式有关），大家可以使用PID的输出除以大概的偏差大致的得到PID的Kp参数的数量级。比如PID输出量是300，而偏差大概是3左右，那么Kp的数量级就是100左右（内环的数量级），而外环数量街：PID的输出量是2.0左右，偏差为20度的话，则kp的范围大致为0.1左右，所以在调试PID的时候可以首先通过简单计算确定出参数的大致范围。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID60.png" alt="img"></p><p>图10.13 角度外环Kp = 0.1时的目标角度和实际角度</p><p>​    由图可以看出，参数有点小，实际值追不上目标值的变化。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID61.png" alt="img"></p><p>图10.14 角度外环Kp = 0.2时的目标角度和实际角度</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID62.png" alt="img"></p><p>图10.15 角度外环Kp = 0.3时的目标角度和实际角度</p><p>​    由图可以看出，Kp = 0.3的时候效果很好，快速性很高响应速度很快。跟随给定的效果很好，而且没有太多超调。效果很好，于是姿态环外环角度环的PID参数就调试出来了。当外环角度环Kp过大的时候，效果如下图所示10.16：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID63.jpg" alt="img"></p><p>图10.16外环Kp比较大系统崩溃</p><p>​    </p><p>​    总结一下：有的串级PID的参数整定还是比较容易的，借用串口显示曲线的软件将比较方便的的调试我们的PID参数。</p><ol><li>先调试内环，再调试外环</li><li>修改程序，使用串口助手打印曲线</li><li>自平衡小车电机控制内环使用PD，外环使用P就能实现很好效果</li><li>调试PID参数的时候先调试P参数再调试D参数最后根据效果调试I参数</li><li></li></ol><p>B、微型四轴串级PID调试经验</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID64.png" alt="img"></p><p>图10.17四轴串级PID框架</p><p>四轴的串级PID参数调试，过程和上面差不多。只不过四轴的姿态是3个姿态角，而自平衡小车的姿态角只有1个。但是我们在调试的时候，实际上也是使用调试架控制四轴只能绕一个轴运动。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID65.png" alt="img"></p><p>图10.18单轴PID调试架</p><p>​    然后我们先调试x轴的PID参数，y轴参数和x轴差不多可以直接复制。调试步骤也是先调P再调D最后调I。</p><h2 id="十一、飞控姿态角调试台和数据分析"><a href="#十一、飞控姿态角调试台和数据分析" class="headerlink" title="十一、飞控姿态角调试台和数据分析"></a>十一、飞控姿态角调试台和数据分析</h2><p><img src="http://s8.sinaimg.cn/mw690/001aRpVkzy77PfzHCppf7&amp;690" alt="åæç¿¼é£äºäºï¼äºï¼ï¼é£æ§å§¿ææ§å¶å°æ¶è¯éª(四旋翼PID调参笔记\001aRpVkzy77PfzHCppf7&amp;690)"></p><p>在飞控自稳飞行之前，都需要在这个台架上对Roll、Pitch的内环（速度闭环）、外环（位置闭环）进行反复的调试，直到性能非常稳定以后，才可会给它解绑，让它飞向天空。</p><p>​        以下仅以 roll 角为例进行性能分析，pitch测试类同。</p><p><strong>1 Roll 内环测试</strong></p><p>​        roll角控制分为外环和内环，内环为速度跟踪环，外环为位置跟踪环。调试时，一般先将内环跟踪调试好，再调试外环。</p><p>​        以下是roll角内环测试时的速度跟踪曲线（目标跟踪速度正负90°/s）。</p><p><img src="http://s2.sinaimg.cn/mw690/001aRpVkzy77PfH49Lr91&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfH49Lr91&amp;690)"></p><p>​        上图我们发现当给定一个期望角速度，实际角速度从0°/s上升到90°/s花费的时间大约为350ms。这个跟踪时间稍微有点长，这个有待进一步优化。</p><p>​        同时通过上图发现角速度往正向跟踪时稍显缓慢，这和试验测试的场景有一定的关系，试验测试场景描述如下：</p><p>​        正向运转测试时，飞行器roll角从-60°经过0°（水平位置）再到+60°位置停下。</p><p>​        反向运转测试时，飞行器roll角从+60°经过0°（水平位置）再到-60°位置停下。 </p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PfPebiYe4&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfPebiYe4&amp;690)"></p><p>​        上图为roll角的变化曲线，基本上roll角的变化斜率（速率）是一定的。由于roll角变化角度非常大，以至于飞行器重心波动非常大，所以给速度跟踪带来了一定影响。下图为速度跟踪时记录的系统阻尼曲线。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PfS15nC84&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfS15nC84&amp;690)"></p><p>​        我们发现正向运动时阻尼大概是0.2，反向运转时阻尼为0.1。这导致正向运转跟踪速度受到一定的影响。</p><p><strong>2 roll外环测试</strong></p><p>​        以下是roll外环测试的曲线（目标跟踪角度正负45°）。</p><p><img src="http://s7.sinaimg.cn/mw690/001aRpVkzy77Pg119Nc56&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pg119Nc56&amp;690)"></p><p><img src="http://s14.sinaimg.cn/mw690/001aRpVkzy77Pg0uAcldd&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pg0uAcldd&amp;690)"></p><p>​        上图我们可以看到，roll角跟踪非常良好，正向跟踪最大2.4°的超调。反向跟踪时最大5°的超调。</p><p>​        下图是角速度的曲线，同时可以看到角度跟踪延时有330ms。这个延时与前面提到的350ms角速度延时基本一致，这个是需要进一步优化的。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PhL14HOb4&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PhL14HOb4&amp;690)"></p><p><strong>3 电机特性分析</strong></p><p>​        在最初开发阶段，我们对飞行器响应特性进行了测试。测试时发现电调、电机的综合响应性能并不理想。以下是我们实验记录的一组指令扭矩与电机角速度响应曲线。</p><p><img src="http://s6.sinaimg.cn/mw690/001aRpVkzy77Pi5kntj25&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pi5kntj25&amp;690)"></p><p>​        我们每5ms采集一个点，从上图曲线中我们发现电机角速度相对指令扭矩之间有100ms左右的相位延时。</p><p>通过多次实验，我们最终确定该电机、电调和螺旋桨的综合响应延时时间100ms，惯性时间常数约40ms（响应频率4hz）。这个参数指标有点让人意外，这样的特性严重降低了我们控制调节的带宽和频率。（关于电机、电调准确延时时间，我暂时还没有做非常严格的测试，严格的测试需要用到我们前不久制作的无刷电机拉力测试台，请参考另外一篇文章：<a href="http://blog.sina.com.cn/s/blog_402c071e0102wyji.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_402c071e0102wyji.html</a>）</p><p>​        由于受现有电调固有特性的限制，电调的调节频率目前为50hz。我们的姿态控制算法运行在200hz频率下，实际电机指令输出频率50hz。</p><p><strong>4 另附一组数据</strong></p><p>​        这是Pitch角的测试结果，下图包含了目标角速度与目标角度的跟踪结果。</p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77Rkuqtpme8" target="_blank" rel="external"><img src="http://s9.sinaimg.cn/mw690/001aRpVkzy77Rkuqtpme8&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Rkuqtpme8&amp;690)"></a><br>        下图为内环（角速度跟踪）<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77RkuXiyide" target="_blank" rel="external"><img src="http://s15.sinaimg.cn/mw690/001aRpVkzy77RkuXiyide&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77RkuXiyide&amp;690)"></a><br>        下图为外环（角度跟踪）<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77Rkv5uiA00" target="_blank" rel="external"><img src="http://s1.sinaimg.cn/mw690/001aRpVkzy77Rkv5uiA00&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Rkv5uiA00&amp;690)"></a></p><p>  <strong>5 yaw测试</strong></p><p>相对roll、pitch测试，Yaw的测试更为容易，所以也没专门为Yaw角测试整一个专业 的台架。刚好手里有一个伺服电机做的圆盘，就地取材，将就着做了个简单测试。（整个测试时间不超过十分钟就搞定了。）</p><p>​      下图中，为一伺服电机，电机固定在一个 长方形的板子上。电机轴上安装一个圆盘，圆盘可以绕电机轴自由旋转。</p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T0aX9E662" target="_blank" rel="external"><img src="http://s3.sinaimg.cn/mw690/001aRpVkzy78T0aX9E662&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0aX9E662&amp;690)"></a></p><p>​      这里做测试并 没有用到电机，只用到了电机的旋转轴和这个圆盘而已。下图黑色的是伺服电机。<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T0bfBTy00" target="_blank" rel="external"><img src="http://s1.sinaimg.cn/mw690/001aRpVkzy78T0bfBTy00&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0bfBTy00&amp;690)"></a></p><p>​      将四旋翼捆绑在圆盘上。轻轻拨动一下机架，基本上可以自由无阻碍的旋转。<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T08vGcled" target="_blank" rel="external"><img src="http://s14.sinaimg.cn/mw690/001aRpVkzy78T08vGcled&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T08vGcled&amp;690)"></a></p><p>​      下面开始实际测试。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy78T0TvCvO84&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0TvCvO84&amp;690)"></p><p>​      测试最大跟踪角速为200°/s。从上图 情况来看，反向目标角速度跟踪比较好，正向跟踪较为缓慢。具体原因在下图中给出了解释。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy78T0VKhzCc4&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0VKhzCc4&amp;690)"></p><p>​      上图Yaw角速度调节扭矩进行了饱和限幅处理。正向运转跟踪速度慢，是因为达到了我人为设定的一个扭矩限制值。而 反向运转未达到这个饱和限制值。这就是为什么正向运转跟踪速度慢，而反向运转跟踪良好。</p><p>​      那么是什么导致了正向反向特性不一样的呢？这是因为这个旋转台带来的正反向阻尼特性不一样造成的，下图曲线给 出了进一步解释。</p><p><img src="http://s2.sinaimg.cn/mw690/001aRpVkzy78T0W4pNLb1&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0W4pNLb1&amp;690)"></p><h2 id="十二、定高测试架设计"><a href="#十二、定高测试架设计" class="headerlink" title="十二、定高测试架设计"></a>十二、定高测试架设计</h2><p>  <strong>定高测试台架（一）</strong></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xti5ACR11" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xti5ACR11&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xti7QAKbe" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xti7QAKbe&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xtia26P9f" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xtia26P9f&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xtic6spd9" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xtic6spd9&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p>​      <strong>定高测试台架（二）</strong></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjGcira7" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjGcira7&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjIAWSc2" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjIAWSc2&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjKAba24" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjKAba24&amp;690.jpg" alt="四旋翼定高测试台架"></a></p>]]></content>
      
      
      <categories>
          
          <category> 四旋翼 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vivadoHLS（一）</title>
      <link href="/2018/10/06/vivadoHLS-0/"/>
      <url>/2018/10/06/vivadoHLS-0/</url>
      
        <content type="html"><![CDATA[<h1 id="HLS学习"><a href="#HLS学习" class="headerlink" title="HLS学习"></a>HLS学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>FPGA又称可编程逻辑门阵列，因为其魔法的并行计算和魔法的可编程逻辑单元阵列，让我产生了兴趣。目前在学数电和verilog。一个月前小伙伴达成共识，要做一个参赛项目。在那个项目里面要全用verilog写的话……恕我直言！太难了(Ｔ▽Ｔ)。所以就开始学这个HLS，在用C转verilog的边缘试探。讲点正经的，这些技术工具本身就是在用户体验感的路上走了！跑了！加速了！底层的东西因为不符合普通人类思维，所以越走越窄。换个角度来说，也可以看做掌握底层的人越来越少。至于这个稀少带来的是价值提升还是被边缘化，这个还是要用发展的眼光去看的。至少现在我认为verilog/VHDL是不能抛弃的，并不是说学了HLS就用不着这些了。HLS也好，verilog/VHDL也好都有其局限性。最关键的还是使用这些工具的人自身的能力和经验。</p><h2 id="HLS基础介绍"><a href="#HLS基础介绍" class="headerlink" title="HLS基础介绍"></a>HLS基础介绍</h2><p>高层次综合（HLS）是指自动综合最初用C、C++或SystemC语言描述的数字设计。工程师之所以对高层次综合如此感兴趣，不仅是因为它能让工程师在较高的抽象层面上工作，而且还因为它能方便地生成多种设计解决方案。利用HLS，您能探索各种可能性，分析面积和性能特点，最终确定一个方案在FPGA芯片上实现算法。举例来说，您能探索将存储器映射到Block RAM（BRAM）或分布式RAM上有什么不同的影响，或者分析回路展开以及其它回路相关优化有什么效果，而且不必手动生成不同的寄存器传输级（RTL）设计。您所要做的仅仅是在C/C++/SystemC设计中设置相关指令而已。</p><p>赛灵思在其最新发布的Vivado™工具套件中推出了HLS工具。Vivado HLS是AutoESL工具的品牌转型重塑，可提供众多技术帮助您优化C/C++/SystemC代码以实现目标性能。这样的HLS工具就能帮助您在FPGA上快速实现算法，无需借助基于Verilog和VHDL等硬件描述语言的非常耗时的RTL设计方法。</p><h2 id="HLS入门学习资料"><a href="#HLS入门学习资料" class="headerlink" title="HLS入门学习资料"></a>HLS入门学习资料</h2><p>第一， 手边的学习资料。</p><p>安装Vivado HLS以后， 既包含了20个design example，50个code example:</p><p><img src="/2018/10/06/vivadoHLS-0/5096-18984-tupian1.png" alt="img"></p><p>第二， step by step教程</p><p>ug871 是xilinx公开提供的HLS教程， 包括11个例子：</p><p>C Validation<br>Interface Synthesis<br>Arbitrary Precision Types<br>Design Analysis<br>Design Optimization<br>RTL Verification<br>Using HLS IP in IP Integrator<br>Using HLS IP in a Zynq Processor Design<br>Using HLS IP in System Generator for DSP</p><p>ug871 ： <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx2013_1/ug871-vivado-high-level-synthesis-tutorial.pdf" target="_blank" rel="external">http://www.xilinx.com/support/documentation/sw_manuals/xilinx2013_1/ug87…</a></p><p>参考设计源代码： <a href="http://www.xilinx.com/cgi-bin/docs/rdoc?v=2013.2;t=vivado+tutorials" target="_blank" rel="external">http://www.xilinx.com/cgi-bin/docs/rdoc?v=2013.2;t=vivado+tutorials</a></p><p><img src="/2018/10/06/vivadoHLS-0/5096-18985-tupian2.png" alt="img"></p><p>第三， 13个Xilinx专家讲解视频， 包括讲座和演示</p><p>地址： <a href="http://www.xilinx.com/training/vivado" target="_blank" rel="external">www.xilinx.com/training/vivado</a></p><p>1.<a href="http://www.origin.xilinx.com/csi/training/vivado/getting-started-with-vivado-high-level-synthesis.htm" target="_blank" rel="external">Getting Started with Vivado High-Level Synthesis</a></p><p>2.<a href="http://www.origin.xilinx.com/csi/training/vivado/verifying-your-vivado-hls-design.htm" target="_blank" rel="external">Verifying your Vivado HLS Design</a></p><p>3.<a href="http://www.origin.xilinx.com/csi/training/vivado/packaging-vivado-hls-ip-for-use-from-vivado-ip-catalog.htm" target="_blank" rel="external">Packaging Vivado HLS IP for use from Vivado IP Catalog</a></p><p>4.<a href="http://www.origin.xilinx.com/csi/training/vivado/generating-vivado-hls-block-for-use-in-system-generator-for-dsp.htm" target="_blank" rel="external">Generating Vivado HLS block for use in System Generator for DSP</a></p><p>5.<a href="http://www.origin.xilinx.com/csi/training/vivado/generating-vivado-hls-pcore-for-use-in-xilinx-platform-studio.htm" target="_blank" rel="external">Generating Vivado HLS pcore for use in Xilinx Platform Studio</a></p><p>6.<a href="http://www.origin.xilinx.com/csi/training/vivado/analyzing-your-vivado-hls-design.htm" target="_blank" rel="external">Analyzing your Vivado HLS design</a></p><p>7.<a href="http://forums.xilinx.com/t5/forums/replypage/board-id/cn-vivado/message-id/%C2%A7%09http:/www.origin.xilinx.com/csi/training/vivado/specifying-axi4-interfaces-for-your-vivado-hls-design.htm" target="_blank" rel="external">Specifying AXI4 interfaces for your Vivado HLS design</a></p><p>8.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-c-in-system-generator.htm" target="_blank" rel="external">Using Vivado HLS C/C++/SystemC block in System Generator</a></p><p>9.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-c-based-pcores-in-xps.htm" target="_blank" rel="external">Using Vivado HLS C/C++/SystemC based pcores in XPS</a></p><p>10.<a href="http://www.origin.xilinx.com/csi/training/vivado/floating-point-design-with-vivado-hls.htm" target="_blank" rel="external">Floating-Point Design with Vivado HLS</a></p><p>11.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-software-libraries-in-your-c-code.htm" target="_blank" rel="external">Using Vivado HLS SW libraries in your C, C++, SystemC code</a></p><p>12.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-tcl-interface.htm" target="_blank" rel="external">Using the Vivado HLS Tcl </a><a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-tcl-interface.htm" target="_blank" rel="external">interface</a></p><p>13.<a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external">Leveraging </a><a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external">OpenCV</a><a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external"> and High Level Synthesis with Vivado</a></p><p>第四， 不停更新的武林秘籍</p><p><a href="http://www.xilinx.com/hls" target="_blank" rel="external">www.xilinx.com/hls</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp745-processor-control-vhls.pdf" target="_blank" rel="external">XAPP745 Processor Control of Vivado HLS Designs</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp793-memory-structures-video-vivado-hls.pdf" target="_blank" rel="external">XAPP793 Implementing Memory Structures for Video Processing in the Vivado HLS Tool</a></p><p><a href="http://www.xilinx.com/support/index.htm" target="_blank" rel="external">XAPP599 </a><a href="http://www.xilinx.com/support/index.htm" target="_blank" rel="external">Floating Point Design with Vivado HLS</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp890-zynq-sobel-vivado-hls.pdf" target="_blank" rel="external">XAPP890 Zynq All Programmable SoC Sobel Filter Implementation Using the Vivado HLS </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp890-zynq-sobel-vivado-hls.pdf" target="_blank" rel="external">Tool</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1163.pdf" target="_blank" rel="external">XAPP1163 - Floating-Point PID Controller Design with Vivado HLS and System Generator for </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1163.pdf" target="_blank" rel="external">DSP</a>、</p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1167.pdf" target="_blank" rel="external">XAPP1167 </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1167.pdf" target="_blank" rel="external">Accelerating OpenCV Applications with Zynq using Vivado HLS Video Libraries</a></p><p><img src="/2018/10/06/vivadoHLS-0/5096-18986-tupian4.png" alt="img"></p><h2 id="第一个Vivado-HLS工程"><a href="#第一个Vivado-HLS工程" class="headerlink" title="第一个Vivado HLS工程"></a>第一个Vivado HLS工程</h2><p><a href="http://xilinx.eetrend.com/d6-xilinx/webinar/2016-07/10340.html" target="_blank" rel="external">http://xilinx.eetrend.com/d6-xilinx/webinar/2016-07/10340.html</a></p><p><a href="http://xilinx.eetrend.com/d6-xilinx/blog/2016-12/10734.html" target="_blank" rel="external">http://xilinx.eetrend.com/d6-xilinx/blog/2016-12/10734.html</a></p><p>对于Vivado Hls来说，输入包括Tesbench，C/C++源代码和Directives，相应的输出为IP Catalog，DSP和SysGen，特别的，一个工程只能有一个顶层函数用于综和，这个顶层函数下面的子函数也是可以被综合的，会生成相应的VHDL和Verilog代码，所以，C综合后的RTL代码结构通常是跟原始C描述的结构是一致的，除非是子函数功能很简单，所需要的逻辑量很小。 通常在main函数以下的函数都可以被综合，也就是说，并不是所有的C/C++都可以被综合，动态内存分配和涉及到操作系统层面的操作不可以被综合。 </p><h3 id="本部分结构框架："><a href="#本部分结构框架：" class="headerlink" title="本部分结构框架："></a>本部分结构框架：</h3><p>Creat New Project新建文档</p><p>C simulation</p><p>C systhesis</p><p>RTL级仿真</p><p>IP封装</p><p>总结</p><h3 id="1-Creat-New-Project新建文档"><a href="#1-Creat-New-Project新建文档" class="headerlink" title="1.Creat New Project新建文档"></a>1.Creat New Project新建文档</h3><p><img src="/2018/10/06/vivadoHLS-0/10734-27136-vivado_-1.png" alt="img"></p><p>​          新建一个Project name，点next（这里选取简单的4选1数据选择器为例，主要是说明流程）</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27137-vivado_-2.png" alt="img"></p><p>​    在Add Files里添加mux41.c文件，点next</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27138-vivado_-3.png" alt="img"></p><p>​    添加mux41_test测试文件，点next</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27139-vivado_-4.png" alt="img"></p><p>点Part，这里选择Board下面的Zedboard Zynq开发板，然后点OK和finish</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27140-vivado_-5.png" alt="img"></p><p>注释：<br>mux41.c代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mux41.h"</span></span></div><div class="line"><span class="function">int1 <span class="title">mux41</span><span class="params">(int1 sig_a, int1 sig_b,int1 sig_c,int1 sig_d, <span class="keyword">int</span> select)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(select==<span class="number">0</span>)</div><div class="line">       <span class="keyword">return</span> sig_a;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">1</span>)</div><div class="line">       <span class="keyword">return</span> sig_b;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">2</span>)</div><div class="line">       <span class="keyword">return</span> sig_c;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">3</span>)</div><div class="line">       <span class="keyword">return</span> sig_d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>mux41.h代码：(头文件)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ap_cint.h&gt;</span></span></div></pre></td></tr></table></figure><p>mux41_tb代码：(testbench)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mux41.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> res1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res2 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res3 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res4 = <span class="number">0</span>;</div><div class="line">  res1=mux41(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    res2=mux41(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">    res3=mux41(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);</div><div class="line">    res4=mux41(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>);</div><div class="line">    <span class="keyword">if</span>(res1 &amp;&amp; res2 &amp;&amp; res3 &amp;&amp; res4)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"test passed, well done!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-C-simulation"><a href="#2-C-simulation" class="headerlink" title="2.C simulation"></a>2.C simulation</h3><p>在菜单里Project&gt;Run C simulation，C simulation可以得到csim文件</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27141-vivado-6.png" alt="img"></p><p>从图中看到，可以看到test passed,well done!，证明结果是正确的：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27142-vivado-7.png" alt="img"></p><h3 id="3-C-systhesis"><a href="#3-C-systhesis" class="headerlink" title="3.C systhesis:"></a>3.C systhesis:</h3><p><img src="/2018/10/06/vivadoHLS-0/10734-27143-vivado_-8.png" alt="img"></p><p>注意综合得到的verilog代码的可读性很差，不需要读懂，所以大多数优化都在C这个层面去做的，下面是综合后的verilog代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// ==============================================================</div><div class="line">// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC</div><div class="line">// Version: 2016.3</div><div class="line">// Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved.</div><div class="line">// </div><div class="line">// ===========================================================</div><div class="line">`timescale 1 ns / 1 ps </div><div class="line">(* CORE_GENERATION_INFO="mux41,hls_ip_2016_3,&#123;HLS_INPUT_TYPE=c,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=1,HLS_INPUT_PART=xc7z020clg484-</div><div class="line">1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=5.258000,HLS_SYN_LAT=0,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=0,HLS_SYN_LUT=41&#125;" *)</div><div class="line">module mux41 (</div><div class="line">        ap_start,</div><div class="line">        ap_done,</div><div class="line">        ap_idle,</div><div class="line">        ap_ready,</div><div class="line">        sig_a,</div><div class="line">        sig_b,</div><div class="line">        sig_c,</div><div class="line">        sig_d,</div><div class="line">        select_r,</div><div class="line">        ap_return</div><div class="line">);</div><div class="line">parameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;</div><div class="line">parameter    ap_const_lv32_1 = 32'b1;</div><div class="line">parameter    ap_const_lv32_2 = 32'b10;</div><div class="line">input   ap_start;</div><div class="line">output   ap_done;</div><div class="line">output   ap_idle;</div><div class="line">output   ap_ready;</div><div class="line">input  [0:0] sig_a;</div><div class="line">input  [0:0] sig_b;</div><div class="line">input  [0:0] sig_c;</div><div class="line">input  [0:0] sig_d;</div><div class="line">input  [31:0] select_r;</div><div class="line">output  [0:0] ap_return;</div><div class="line">wire   [0:0] tmp_fu_60_p2;</div><div class="line">wire   [0:0] tmp_1_fu_66_p2;</div><div class="line">wire   [0:0] sel_tmp1_fu_86_p2;</div><div class="line">wire   [0:0] sel_tmp2_fu_92_p2;</div><div class="line">wire   [0:0] sel_tmp_fu_78_p3;</div><div class="line">wire   [0:0] tmp_2_fu_72_p2;</div><div class="line">wire   [0:0] tmp7_fu_106_p2;</div><div class="line">wire   [0:0] sel_tmp5_fu_112_p2;</div><div class="line">wire   [0:0] p_0_fu_98_p3;</div><div class="line">assign ap_done = ap_start;</div><div class="line">assign ap_idle = 1'b1;</div><div class="line">assign ap_ready = ap_start;</div><div class="line">assign ap_return = ((sel_tmp5_fu_112_p2[0:0] === 1'b1) ? p_0_fu_98_p3 : sig_d);</div><div class="line">assign p_0_fu_98_p3 = ((sel_tmp2_fu_92_p2[0:0] === 1'b1) ? sig_b : sel_tmp_fu_78_p3);</div><div class="line">assign sel_tmp1_fu_86_p2 = (tmp_fu_60_p2 ^ 1'b1);</div><div class="line">assign sel_tmp2_fu_92_p2 = (tmp_1_fu_66_p2 &amp; sel_tmp1_fu_86_p2);</div><div class="line">assign sel_tmp5_fu_112_p2 = (tmp7_fu_106_p2 | tmp_fu_60_p2);</div><div class="line">assign sel_tmp_fu_78_p3 = ((tmp_fu_60_p2[0:0] === 1'b1) ? sig_a : sig_c);</div><div class="line">assign tmp7_fu_106_p2 = (tmp_1_fu_66_p2 | tmp_2_fu_72_p2);</div><div class="line">assign tmp_1_fu_66_p2 = ((select_r == ap_const_lv32_1) ? 1'b1 : 1'b0);</div><div class="line">assign tmp_2_fu_72_p2 = ((select_r == ap_const_lv32_2) ? 1'b1 : 1'b0);</div><div class="line">assign tmp_fu_60_p2 = ((select_r == ap_const_lv32_0) ? 1'b1 : 1'b0);</div><div class="line">endmodule //mux41</div></pre></td></tr></table></figure><h3 id="4-RTL级仿真"><a href="#4-RTL级仿真" class="headerlink" title="4.RTL级仿真"></a>4.RTL级仿真</h3><p>在菜单里Solution&gt;RunC/RTL cosimulation，需要对Co-similation Dialog设置如下：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27144-vivado-9.png" alt="img"></p><p>得到如下结果，我们会发现Verilog的Status是pass，证明C/RTL cosimulation成功:</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27145-vivado-10.png" alt="img"></p><p>然后我们点开波形查看窗口，此时会自动打开Vivado软件，从图中看到，mux41的功能正确：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27146-vivado-11.png" alt="img"></p><h3 id="5-IP封装"><a href="#5-IP封装" class="headerlink" title="5.IP封装"></a>5.IP封装</h3><p>在菜单里Solution&gt;Export TL，设置如下：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27147-vivado-12.png" alt="img"></p><p>IP封装后，会得到impl文件，其中就有我们所需要的三个子文件ip，verilog，vhdl</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27148-vivado-13.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，在整个流程中，用户先创建一个设计 C、C++ 或 SystemC 源代码，以及一个C的测试平台。随后需要用 GCC/G++或 Visual C++ 仿真器验证设计的系统行为。一旦行为设计运行良好，对应的测试台的问题全部解决，就可以通过 Vivado HLS Synthesis 运行设计，生成 RTL 设计，代码可以是 Verilog，也可以是 VHDL。有了 RTL 后，随即可以执行设计的 Verilog 或 VHDL 仿真，或使用工具的C封装器技术创建 SystemC 版本。然后可以进行System C架构级仿真，进一步根据之前创建的 C 测试平台，验证设计的架构行为和功能。设计固化后，就可以通过 Vivado 设计套件的物理实现流程来运行设计，将设计编程到器件上，在硬件中运行和/或使用 IP 封装器将设计转为可重用的 IP。随后使用 IP 集成器将 IP 集成到设计中，或在系统生成器 （System Generator） 中运行 IP。</p><h2 id="HLS进阶学习"><a href="#HLS进阶学习" class="headerlink" title="HLS进阶学习"></a>HLS进阶学习</h2><h3 id="初步学习计划"><a href="#初步学习计划" class="headerlink" title="初步学习计划"></a>初步学习计划</h3><p>HLS说到底是一个工具，作为工具，应用为先。</p><h4 id="第一步-利用教程和例程跑一个hls仿真"><a href="#第一步-利用教程和例程跑一个hls仿真" class="headerlink" title="第一步 利用教程和例程跑一个hls仿真"></a>第一步 利用教程和例程跑一个hls仿真</h4><p>详情参考ug871第二章 create a high-level synthesis project</p><p>以下仅对值得注意的地方进行记录</p><p>很好，我点进上文的参考代码链接，给我出现了以下界面</p><p><img src="/2018/10/06/vivadoHLS-0/1538791324962.png" alt="1538791324962"></p><p>我觉得事情不简单，下拉以后</p><p><img src="/2018/10/06/vivadoHLS-0/1538791380106.png" alt="1538791380106"></p><p>好的吧，出现最新版教程了。左边侧栏勾选tutorials,然后把document type 那边的user guides去掉。往下拉你就可以看到清纯不做作的ug871 2018.2。</p><p><img src="/2018/10/06/vivadoHLS-0/1538791548492.png" alt="1538791548492"></p><p>………………换文档肯定要跑路的啊！（不是）换文档肯定要看看有什么区别的啊！</p><p><img src="/2018/10/06/vivadoHLS-0/1538791799084.png" alt="1538791799084"></p><p>​                                                                           2018.2</p><p><img src="/2018/10/06/vivadoHLS-0/1538749785686.png" alt="1538749785686"></p><p>​                                                                              2013.1</p><p>初步判断没什么实质性区别，那好，我去看看操作。其实本来差别就不可能很大，主要是怕有一些操作不同。这个时候第一步就是打开我的<del>垃圾</del> vivado hls 2016.1，暗中观察一下初始GUI页面跟哪一版的教程更像。</p><p>然后我觉得我应该用新版教程了(っ•̀ω•́)っ✎⁾⁾。接下来这句话：详情参考ug871 2018.2 ch.2 hls introduction</p><p>哦好的吧，我本来想搞一个能看Waveforms的工程出来，然后发现ch2这章introduction的三个lab是在教软件使用方法。好吧，那我放一个我lab 2成功的截图好了。</p><p><img src="/2018/10/06/vivadoHLS-0/TIM图片201810061220.png" alt="TIM图片201810061220"></p><p>说一下体验，教程还是很详细的，基本都很顺。除了lab 2用commad prompt的时候，出了一点小问题。因为第一步要定位到introduction文件夹里，我一开始用cd 命令……然后就一点都不ok,查了才发现windows cd命令只能切当前盘内路径。</p><p>然后如果像我一样不按原设定路径安装的话，这部分修改大致如下：</p><p><img src="/2018/10/06/vivadoHLS-0/TIM图片20181006122457.png" alt="TIM图片20181006122457"></p><p>因为我混乱的路径就是……</p><p>E:\FileRecv\fpga\ug871-design-files\ug871-design-files\Introduction</p><p>这样的啊，然后我又习惯性地把fir_prj放到我平常放代码的地方，就不在lab1目录下。为了完成这个实验，那当然是！复制过来！！！</p><p>之后操作就一切正常。</p><p>总之官方教程文档很详细。只是编一个初始的小工程编译就花了不少时间，我已经感受到了来自vivado的威胁(Ｔ▽Ｔ)</p><p>心怀电路写C第一步，完成。</p><h4 id="第二步-利用手上的ug871和ug902文档研究官方例程和语法约束"><a href="#第二步-利用手上的ug871和ug902文档研究官方例程和语法约束" class="headerlink" title="第二步 利用手上的ug871和ug902文档研究官方例程和语法约束"></a>第二步 利用手上的ug871和ug902文档研究官方例程和语法约束</h4><p>ug871官方例程教程</p><p><img src="/2018/10/06/vivadoHLS-0/1538749785686.png" alt="1538749785686"></p><p>ug902语法约束</p><p><img src="/2018/10/06/vivadoHLS-0/1538789542511.png" alt="1538789542511"></p><h4 id="第三步-将hls运用在参赛项目上"><a href="#第三步-将hls运用在参赛项目上" class="headerlink" title="第三步 将hls运用在参赛项目上"></a>第三步 将hls运用在参赛项目上</h4><p>过程记录如下</p><h4 id="第四步-后期完善学习，记录一些可优化技巧"><a href="#第四步-后期完善学习，记录一些可优化技巧" class="headerlink" title="第四步 后期完善学习，记录一些可优化技巧"></a>第四步 后期完善学习，记录一些可优化技巧</h4>]]></content>
      
      
      <categories>
          
          <category> VivadoHLS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>uCOSIII(一)</title>
      <link href="/2018/10/04/uCOSIII1/"/>
      <url>/2018/10/04/uCOSIII1/</url>
      
        <content type="html"><![CDATA[<h1 id="UCOSIII学习"><a href="#UCOSIII学习" class="headerlink" title="UCOSIII学习"></a>UCOSIII学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学了一年单片机，从51到tm4以及stm32,基本都是在while(1)里面“裸奔”。18年暑假的时候突然想玩一下操作系统，就操作了一下。原来有一个官方移植的tm4c1294例程。本来是想改一改移植到tm4c123g上然后用ccs作为开发环境，研究了一天发现micrium官方对于tiva-c系列只提供了IAR和realview开发工具的startup.c。我猜直接把ccs的startup_ccs.c换掉realview的或许可以吧。不过我的首要目的是学单片机上操作系统的原理和使用方法，所以就直接用官方移植的例程上手了。</p><h2 id="基于tm4c1294的UCOSIII系统搭建"><a href="#基于tm4c1294的UCOSIII系统搭建" class="headerlink" title="基于tm4c1294的UCOSIII系统搭建"></a>基于tm4c1294的UCOSIII系统搭建</h2><h3 id="官方例程下载"><a href="#官方例程下载" class="headerlink" title="官方例程下载"></a>官方例程下载</h3><h3 id="1-进入micrium官网"><a href="#1-进入micrium官网" class="headerlink" title="1.进入micrium官网"></a>1.进入micrium官网</h3><p>国外网站打开有点慢，等个半分钟到一分钟就行。</p><p><a href="https://www.micrium.com/" target="_blank" rel="external">https://www.micrium.com/</a></p><p><img src="/2018/10/04/uCOSIII1/1538641804364.png" alt="1538641804364"></p><h3 id="2-点击导航栏的Downloads进入下载页面"><a href="#2-点击导航栏的Downloads进入下载页面" class="headerlink" title="2.点击导航栏的Downloads进入下载页面"></a>2.点击导航栏的Downloads进入下载页面</h3><p>下拉页面找到根据MCU生产商浏览，找到Texas Instrument。</p><p><img src="/2018/10/04/uCOSIII1/1538642099029.png" alt="1538642099029"></p><h3 id="3-选中tm4c1294进入下载界面"><a href="#3-选中tm4c1294进入下载界面" class="headerlink" title="3.选中tm4c1294进入下载界面"></a>3.选中tm4c1294进入下载界面</h3><p><img src="/2018/10/04/uCOSIII1/1538642588422.png" alt="1538642588422"></p><h3 id="4-直接点击资源这一栏"><a href="#4-直接点击资源这一栏" class="headerlink" title="4.直接点击资源这一栏"></a>4.直接点击资源这一栏</h3><p>值得注意的是micrium提供的keil MDK是v4，所以导入到v5会有警告提示，管它呢。反正最后不影响使用就是了。</p><p><img src="/2018/10/04/uCOSIII1/1538642688315.png" alt="1538642688315"></p><h3 id="5-登录账号并下载"><a href="#5-登录账号并下载" class="headerlink" title="5.登录账号并下载"></a>5.登录账号并下载</h3><p>注册一个micrium账号，Log in to Download</p><p><img src="/2018/10/04/uCOSIII1/1538643022452.png" alt="1538643022452"></p><h3 id="文件结构解析"><a href="#文件结构解析" class="headerlink" title="文件结构解析"></a>文件结构解析</h3><h4 id="文件夹初探"><a href="#文件夹初探" class="headerlink" title="文件夹初探"></a>文件夹初探</h4><p>文件夹解压出来如下</p><p><img src="/2018/10/04/uCOSIII1/1538643201614.png" alt="1538643201614"></p><h5 id="第一个EvalBoards就是MCU板子移植的相关代码"><a href="#第一个EvalBoards就是MCU板子移植的相关代码" class="headerlink" title="第一个EvalBoards就是MCU板子移植的相关代码"></a>第一个EvalBoards就是MCU板子移植的相关代码</h5><p>我们要找的keil工程文件在EvalBoards-&gt;TI-&gt;EK-TM4C1294XL-&gt;OS3-&gt;KeilMDK这条路径下。</p><p>在OS3那一层并列一个”BSP”的文件夹，这是micrium写的tm4c1294板子驱动的相关代码。不过我采用的是tiva-ware，这个BSP驱动后续可能只用一部分，不然会重定义然后打架。</p><p><img src="/2018/10/04/uCOSIII1/1538643385032.png" alt="1538643385032"></p><h5 id="剩下三个就是UCOSIII的资源文件"><a href="#剩下三个就是UCOSIII的资源文件" class="headerlink" title="剩下三个就是UCOSIII的资源文件"></a>剩下三个就是UCOSIII的资源文件</h5><p>这部分详细介绍参考《嵌入式实时操作系统uCOS-3》（北航出版社）。</p><p><strong>uC-CPU</strong></p><p>文件结构如下</p><p>\uC-CPU</p><p>​    \cpu_core.c(包含适用所有CPU架构的C代码 包含用来测量中断关闭时间的函数)</p><p>​    \cpu_core.h（包含用于测量中断关闭时间的变量定义）</p><p>​    \cpu_def.h（包含uC/CPU模块使用的宏定义）</p><p>​    \ARM-Cortex-M4\RealView</p><p>​        \cpu.h(包含一些数据类型定义)</p><p>​        \cpu_a.asm（汇编语言实现开关中断、计算前导零、使能缓存、建立MPUs、MMU的函数，其中函数可以直接在C代码里调用）</p><p>​        \cpu_c.c（基于特定cpu架构的代码）</p><p><strong>uC-LIB</strong></p><p>可移植库函数如下</p><p>\lib_ascii.c及其头文件（其中函数可以替代大小字母转化和数字字母互化的库函数）</p><p>\lib_def.h(定义许多常量)</p><p>\lib_math.c及其头文件（其中函数可以替代rand()、srand()）</p><p>\lib_mem.c及其头文件（其中函数可以替代memclr()、memset()、memcpy()、memcmp()）等</p><p>lib_str.c及其头文件（其中函数可以以替代strlen()、strcpy()、strcmp()）等</p><p><strong>uCOS-III</strong></p><p>其中与处理器类型无关文件如下</p><p>\Source</p><p>​    \os_cfg.app.c（根据os_cfg_app.h中宏定义定义变量和数据）</p><p>​    \os_core.c（包含uCOSIII内核功能模块）</p><p>​    \os_dbg.c（包含内核调试器）</p><p>​    \os_flag.c（包含事件标志管理代码）</p><p>​    \os_int.c（包含中断处理任务代码）</p><p>​    \os_mem.c（包含存储分区代码）</p><p>​    \os_msg.c（包含消息处理代码）</p><p>​    \os_mutex.c（包含互斥信号量代码）</p><p>​    \os_pend.multi.c（包含允许任务同时等待多个信号量和多个消息队列代码）</p><p>​    \os_prio.c（用于追踪已就绪任务）</p><p>​    \os_q.c（包含消息队列管理代码）</p><p>​    \os_sem.c（包含信号量管理代码）</p><p>​    \os_stat.c(包含统计任务代码)</p><p>​    \os_task.c（包含任务的管理代码）</p><p>​    \os_tick.c（包含可管理正在延时和超时等待任务）</p><p>​    \os_time.c（包含延时代码）</p><pre><code>\os_tmr.c（包含软件定时器代码）</code></pre><p>​    \os_var.c（包含uCOSIII的全局变量）</p><p>​    \os.h（uCOSIII主要头文件）</p><p>​    \os_type.h（包含数据类型声明）</p><h3 id="keil环境配置"><a href="#keil环境配置" class="headerlink" title="keil环境配置"></a>keil环境配置</h3><p>在第一次导入工程的时候一般会提示识别到器件为tm4c1294,直接按提示下支持包就行。</p><p>器件型号为TM4C1294NCPDT。</p><p>我记得只要器件型号对上了，其他配置在这个例程下基本都是配好的。</p><p>只需要在魔术棒的C/C++选项卡把Preprocessor Symbols的Define填上     rvmdk PART_TM4C1294NCPDT     就行。<img src="/2018/10/04/uCOSIII1/1538653394096.png" alt="1538653394096"></p><p>如果出现什么问题，参照以下文档配置keil下的tm4开发环境：</p><p><a href="https://wenku.baidu.com/view/6d23b80dbc64783e0912a21614791711cc7979f4.html" target="_blank" rel="external">https://wenku.baidu.com/view/6d23b80dbc64783e0912a21614791711cc7979f4.html</a></p><h3 id="tiva-ware联动"><a href="#tiva-ware联动" class="headerlink" title="tiva-ware联动"></a>tiva-ware联动</h3><p>tiva-ware是一个ti的软件开发包，里面有bsp板级支持以及tiva-c系列各型号开发板的库函数和例程。</p><p>在keil里面使用tiva-ware只需要将tiva-ware包里面针对realview开发工具的driverlib.lib添入工程就行。</p><p>顺便在魔术棒的C/C++选项卡里的 Include Paths一栏加入你的tiva-ware包的路径。</p><p><img src="/2018/10/04/uCOSIII1/1538653571710.png" alt="1538653571710"></p><h2 id="第一个UCOSIII工程"><a href="#第一个UCOSIII工程" class="headerlink" title="第一个UCOSIII工程"></a>第一个UCOSIII工程</h2><p>下好例程，配好环境，来试试水</p><p>软件设计如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"app_cfg.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cpu_core.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;os.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_led.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_sys.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_misc.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_ascii.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_mem.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_str.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inc/hw_memmap.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driverlib/gpio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driverlib/sysctl.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> START_TASK_PRIO3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> START_STK_SIZE 128</span></div><div class="line">OS_TCB StartTaskTCB;</div><div class="line">CPU_STK START_TASK_STK[START_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_TASK_PRIO4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_STK_SIZE 128</span></div><div class="line">OS_TCB Task1_TaskTCB</div><div class="line">CPU_STK TASK1_TASK_STK[TASK1_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_TASK_PRIO5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_STK_SIZE 128</span></div><div class="line">OS_TCB Task2_TaskTCB;</div><div class="line">CPU_STK TASK2_TASK_STK[TASK2_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    OS_ERR  err;</div><div class="line">    CPU_SR_ALLOC();                                              <span class="comment">/* Disable all interrupts.*/</span></div><div class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</div><div class="line">    <span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF))</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0|GPIO_PIN_4);</div><div class="line">    OSInit(&amp;err);                                               <span class="comment">/* Init uC/OS-III. */</span></div><div class="line">    OS_CRITICAL_ENTER();</div><div class="line">   OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"start task"</span>, </div><div class="line">                 (OS_TASK_PTR )start_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )START_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;START_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)START_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)START_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP, </div><div class="line">                 (OS_ERR * )&amp;err);</div><div class="line">OS_CRITICAL_EXIT(); </div><div class="line">OSStart(&amp;err);      </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT32U  cpu_clk_freq;</div><div class="line">    CPU_INT32U  cnts;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   (<span class="keyword">void</span>)&amp;p_arg;</div><div class="line"></div><div class="line">    BSP_Init();                                           <span class="comment">/* Initialize BSP functions */</span></div><div class="line"></div><div class="line">    cpu_clk_freq = BSP_SysClkFreqGet();                <span class="comment">/* Determine SysTick reference freq.*/</span></div><div class="line">    cnts         = cpu_clk_freq                          <span class="comment">/* Determine nbr SysTick increments*/</span></div><div class="line">                 / (CPU_INT32U)OSCfg_TickRate_Hz;</div><div class="line"></div><div class="line">    OS_CPU_SysTickInit(cnts);</div><div class="line">    CPU_Init();  </div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line">OSTaskCreate((OS_TCB * )&amp;Task1_TaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"Task1 task"</span>, </div><div class="line">                 (OS_TASK_PTR )task1_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )TASK1_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;TASK1_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)TASK1_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)TASK1_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP,</div><div class="line">                 (OS_ERR * )&amp;err);</div><div class="line"> </div><div class="line"></div><div class="line">OSTaskCreate((OS_TCB * )&amp;Task2_TaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"task2 task"</span>, </div><div class="line">                 (OS_TASK_PTR )task2_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )TASK2_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;TASK2_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)TASK2_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)TASK2_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP, </div><div class="line">                 (OS_ERR * )&amp;err); </div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"> </div><div class="line">OSTaskDel((OS_TCB*)<span class="number">0</span>,&amp;err);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT08U task1_num=<span class="number">0</span>;</div><div class="line">CPU_INT32U ui32Loop1;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line">p_arg = p_arg;</div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line"></div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">task1_num++;</div><div class="line"> <span class="comment">//BSP_LED_Toggle(1);</span></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_PIN_4);</div><div class="line">        <span class="keyword">for</span>(ui32Loop1 = <span class="number">0</span>; ui32Loop1 &lt; <span class="number">20000</span>; ui32Loop1++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, <span class="number">0x0</span>);</div><div class="line">        <span class="keyword">for</span>(ui32Loop1 = <span class="number">0</span>; ui32Loop1 &lt; <span class="number">20000</span>; ui32Loop1++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">if</span>(task1_num==<span class="number">5</span>) </div><div class="line">&#123;</div><div class="line">OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err); </div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT08U task2_num=<span class="number">0</span>;</div><div class="line">CPU_INT32U ui32Loop;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line">p_arg = p_arg;</div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line"></div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">task2_num++;</div><div class="line">     <span class="comment">//BSP_LED_Toggle(2);  </span></div><div class="line"></div><div class="line">       GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);</div><div class="line">        <span class="keyword">for</span>(ui32Loop = <span class="number">0</span>; ui32Loop &lt; <span class="number">20000</span>; ui32Loop++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, <span class="number">0x0</span>);</div><div class="line">        <span class="keyword">for</span>(ui32Loop = <span class="number">0</span>; ui32Loop &lt; <span class="number">20000</span>; ui32Loop++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err); </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下载现象为：任务一运行5次后删掉任务二。所以可以看到本来是两个led几乎同时闪烁，闪烁4次后，有一个led停止闪烁，另一个继续闪烁。</p><p>至此，你就在tm4c1294上拥有了一个基于tiva-ware固件库可以跑的uCOSIII。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>阿月月，现就读于南京邮电大学，每日沉迷学习和玩技术无法自拔。作为一个琴棋（飞行棋）书画都会又能歌善舞（全国中学生广播体操——舞动青春）的女孩子，我为什么要跑来学工科呢？犹记邓布利多，邓校的那句：“你想成为什么样的人比你具备什么样的特质更能决定你的未来。”</p><p>人的一生就是个不停拾取灵魂碎片的过程。你来人间走一趟，不玩点好玩的，不做点有意思的事，不试着自己衡量世事，不去和一些有梦想的魔鬼混在一起，怎么会甘心呢？</p>]]></content>
      
    </entry>
    
  
</search>
