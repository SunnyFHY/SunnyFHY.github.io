<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MATLAB通信仿真（二）</title>
      <link href="/2019/11/09/MATLAB2/"/>
      <url>/2019/11/09/MATLAB2/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB通信仿真（二）"><a href="#MATLAB通信仿真（二）" class="headerlink" title="MATLAB通信仿真（二）"></a>MATLAB通信仿真（二）</h1><p>​                            此系列资料为我的matlab通信仿真学习笔记以及通院科协授课用资料</p><p>​                                              内容参考杜勇老师的书和蔡凡老师的公众号</p><h2 id="通信仿真基础知识"><a href="#通信仿真基础知识" class="headerlink" title="通信仿真基础知识"></a>通信仿真基础知识</h2><h3 id="数字通信系统基础概念"><a href="#数字通信系统基础概念" class="headerlink" title="数字通信系统基础概念"></a>数字通信系统基础概念</h3><h4 id="与频谱相关的概念"><a href="#与频谱相关的概念" class="headerlink" title="与频谱相关的概念"></a>与频谱相关的概念</h4><p> 在数字通信系统中，我们会经常提到频谱的概念，频域分析也是信号分析最基本和最 广泛使用的方法，通信人员最直接的体验就是用频谱分析仪分析测试信号的频谱。与频谱 相关的概念有很多，如幅度谱、相位谱、功率谱和能量谱等，常常让人很糊涂，搞不清其中的关系。在信号分析中经常会出现负频率成分，这又到底是怎么回事呢？现实中会存在 具有负频率成分的信号吗？ </p><p><strong>1.傅里叶变换</strong></p><p>我们知道，傅里叶级数其实是用不同频率的正弦信号来表示各种信号（或曲线）。为什 么我们要用正弦曲线来代替原来的曲线呢？比如我们也还可以用方波或三角波来代替呀。 分解信号的方法是无穷多的，但分解信号的目的是为了更加简单地处理原来的信号。用正余弦来表示原信号会更加简单，因为正余弦拥有原信号所不具有的性质：正弦曲线保真度。 一个正余弦曲线信号输入后，输出仍然是正余弦曲线，只有幅度和相位可能发生变化，但是频率和波的形状仍是一样的。由于只有正余弦曲线才拥有这样的性质，我们才不用方波或三角波来表示。 </p><p><img src="/2019/11/09/MATLAB2/1573289232933.png" alt="1573289232933"></p><p>关于傅里叶变换的原理在此不再多做讨论，在任何一本讨论信号与系统的书籍中均可以找到其详细的理论推导。这里，我们起码需要确立关于信号处理中的一个基本概念 如果信号在频域是离散的，则该信号在时域就表现为周期性的时间函数；相反，在时域上 是离散的，则该信号在频域必然表现为周期性的频率函数。不难设想，如果时域信号不仅是离散的，而且是周期的，那么由于它时域离散，其频谱必是周期的，又由于时域是周期的，相应的频谱必是离散的。换句话说，一个离散周期时间序列，它一定具有既是周期又是离散的频谱。我们还可以得出一个结论：一个域的离散就必然造成另一个域的周期延拓， 这种离散变换，本质上都是周期的。</p><p><strong>2.功率谱与能量谱</strong></p><p>对一个时域信号进行傅里叶变换，就可以得到信号的频谱，信号的频谱由两部分构成: 幅度谱和相位谱。那么，什么是功率谱呢？什么又是能量谱呢？功率谱、能量谱与信号的频谱有什么关系呢？</p><p>要区分功率谱和能量谱，首先要清楚两种不同类型的信号：功率有限信号和能量有限信号。</p><p>信号的归一化能量（简称信号的能量）定义为信号电压或电流f(t)加到1Ω电阻上所消耗的能量，表示为</p><p><img src="/2019/11/09/MATLAB2/1573289434777.png" alt="1573289434777"></p><p>通常把能量为有限值的称为能量有限信号或简称能量信号。在实际应用中，一般的非周期信号属于能量信号。然而，对于像周期信号、阶跃信号，以及符号函数等这一类的信号，显然其能量积分无穷大，此时，一般不再研究其能量，而是研究信号的平均功率。 </p><p>信号的平均功率（简称信号的功率）是指信号电压或电流在1Ω电阻上所消耗的功率， 表示为 </p><p><img src="/2019/11/09/MATLAB2/1573289646702.png" alt="1573289646702"></p><p>f(t)在一个时间段[T1,T2]上的平均功率为 </p><p>​                                      <img src="/2019/11/09/MATLAB2/1573289788553.png" alt="1573289788553"></p><p>如果信号的功率是有限的，那么称为功率有限信号，简称功率信号。系统中的波形要么具有能量值，要么具有功率值，因为能量有限的信号功率为零，而功率有限的信号能量为无穷大。一般来说，周期信号和随机信号是功率信号，而非周期的确定信号是能量信号。将信号区分为能量信号和功率信号可以简化对各种信号和噪声的数学分析。还有一类信号 的功率和能量都是无限的，如f(t)=t这类信号很少会用到。 </p><p>了解信号可能是能量信号，也可能是功率信号后，就可以很好地理解功率谱和能量谱的概念。对于能量信号，常用能量谱来描述。所谓的能量谱，也称为能量谱密度，是指用密度的概念表示信号能量在各频率点的分布情况。也就是说，对能量谱在频域上积分就可 以得到信号的能量。能量谱是信号幅度谱的模的平方，其量纲是焦/赫。对于功率信号，常 用功率谱来描述。所谓的功率谱，也称为功率谱密度，是指用密度的概念表示信号功率在 各频率点的分布情况。对功率谱在频域上积分就可以得到信号的功率。从理论上来说，功率谱是信号自相关函数的傅里叶变换。因为功率信号不满足傅里叶变换条件，其频谱通常不存在，维纳-辛钦定理证明了自相关函数和傅里叶变换之间的对应关系。在工程应用中， 即便是功率信号，由于持续的时间有限，可以直接对信号进行傅里叶变换，然后对得到的幅度谱的模求平方，再除以持续时间来估计信号的功率谱。 </p><p>对于确定性的信号，特别是非周期的确定性信号，常用能量谱来描述。而对于随机信号，由于持续时间无限长，不满足绝对可积与能量可积的条件，因此不存在傅里叶变换， 所以通常用功率谱来描述。周期性的信号，也同样不满足傅里叶变换的条件，常用功率谱 来描述，这些在前面己经有所说明。只有如单频正弦信号等很少的特殊信号，在引入冲激函数之后，才可以求解信号的傅里叶变换。 </p><p>对于用功率谱描述的随机信号而言，白噪声是一个特例。根据定义，白噪声是指功率谱密度在整个频域内均匀分布的噪声。严格地说，白噪声只是一种理想化模型，因为实际 噪声的功率谱密度不可能具有无限宽的带宽，否则它的功率将是无限大，是物理上不可实现的。然而，白噪声在数学处理上比较方便，因此它是系统分析的有力工具。一般来讲， 只要一个噪声过程所具有的频谱宽度远远大于它所作用系统的带宽，并且在该带宽中其频 谱密度基本上可以作为常数来考虑，就可以把它作为白噪声来处理。例如，热噪声和散弹噪声在很宽的频率范围内具有均匀的功率谱密度，通常可以认为它们是白噪声。 </p><p>再回过头来讨论一下频谱仪上所测试到的信号。经过前面的分析，显然频谱仪观测到的信号均是功率信号，且所观测到的频谱其实只是幅度谱，并没有相位与频率的关系。 而采用MATLAB很容易设计出满足需求的滤波器，并绘出滤 波器的幅频响应和相频响应。 </p><p>虽然在数学分析上，根据傅里叶变换公式会产生负频率成分的信号，以及出现虚信号, 但现实中显然是不会出现这样的信号的。因此，这些信号仅仅是方便进行数学分析而已。 例如，根据傅里叶变换公式，任何实信号的频谱均是相对于纵坐标对称的，采用本地载波 信号进行混频时，很容易根据傅里叶变换的性质推导出混频后的所有频率分量。 </p><h4 id="带宽是如何定义的"><a href="#带宽是如何定义的" class="headerlink" title="带宽是如何定义的"></a>带宽是如何定义的</h4><p>信号带宽、滤波器带宽、3 dB带宽、半功率带宽、信道带宽，这些概念的准确定义是什么？它们是一回事吗，或者之间有什么关联？ </p><p><strong>1.信号带宽 </strong></p><p>对于一个经载波调制的脉冲信号：Xc(t)  来讲，其频率范围覆盖了整个频域，单边带功率谱密度具有如下的表达形式</p><p>​                                          <img src="/2019/11/09/MATLAB2/1573290623222.png" alt="1573290623222"></p><p>式中，fc是载波频率，T为脉冲持续时间。Xc(t)的功率谱密度如图示，大多数数字调制方式产生的信号频谱形状大致如此。 </p><p> <img src="/2019/11/09/MATLAB2/1573307475798.png" alt="1573307475798"></p><p>(a)半功率带宽；（b)等效噪声带宽；（c)零点到零点带宽；（d)99%功率带宽；（e)限制带外衰减35dB带宽 </p><p>以下是图中几种信号带宽的定义。</p><p>(1)  半功率带宽（Half-Power Bandwidth):指Gx(f)的功率下降到峰值的一半，或此峰值下降3 dB的两频率点之间的间隔。因此，半功率带宽也叫作3 dB带宽。</p><p>(2) 等效矩形或等效噪声带宽（Equivalent Rectangular or Noise Equivalent Bandwidth):</p><p>等效带宽概念的出现，最初是为了从具有宽带噪声输入的放大器中快速计算输出噪声功率， 这个概念也可以推广到信号带宽。信号的等效带宽Bn=Px/Gx(fc),其中Px是所有频率上的信号总功率，Gx(fc)是Gx(f)在带宽中心点的值（假设该值是最大值）。</p><p>(3) 零点到零点带宽（Null-to-Null Bandwidth):这个带宽也叫作主瓣宽度，是数字通信中最常用的带宽定义。在没有特别指明的情况下，通常所说的信号带宽就是指主瓣宽度, 在这个频带包含了信号的大部分信号功率。</p><p>(4) 部分功率保留带宽（Fractional Power Containment Bandwidth):这个带宽定义己被联邦通信委员会（FCC)采纳，此带宽定义要求在正截止频率以上和负截止频率以下各留0. 5%的信号功率，因此该带宽内包含了 99%的信号功率。</p><p>(5)有界功率谱密度带宽（Bounded Power Spectral Density Bandwidth):该定义指在确定带宽之外的任意频率处，Gx(f)必须比带宽中心点的值低一个确定数，典型的衰减电平值 为 35dB 或 50dB。</p><p>(6)绝对带宽（Absolute Bandwidth):指在该带宽之外的频谱全部为零的频率间隔。该定义在理论上很有用，但对于可实现的信号，绝对带宽为无穷大。</p><p>经过前面的讨论，我们对信号带宽、3 dB带宽、半功率带宽的概念有了更为明确的认识。众所周知，滤波器是一个频率选择性器件，它的带宽是指能够通过滤波器的频率范围。 半功率带宽，是指与最大功率增益相比，功率衰减量下降一半(3 dB)处的频率带宽。滤波器的另外一个重要带宽概念对应于信号带宽中的有界功率谱密度带宽，也叫作通带带宽， 指功率衰减下降了某个典型值（35 dB或50 dB)处的频率带宽，此时的频率值通常也叫作 截止频率或阻带频率。 </p><p><strong>2.信道带宽</strong></p><p>接下来再讨论一下通信中经常碰到的信道带宽的概念。从电子电路角度的出发，带宽 本意指的是电子电路中存在一个固有通频带。这个概念或许比较抽象，我们有必要做进一 步的解释。大家都知道，各类复杂的电子电路无一例外都存在电感、电容或相当功能的储 能元件，即使没有采用现成的电感线圈或电容，导线自身就是一个电感，而导线与导线之 间、导线与地之间便可以组成电容——这就是通常所说的杂散电容或分布电容。不管是哪种 类型的电容、电感，都会对信号起着阻滞作用，从而消耗信号能量，严重的话会影响信号 品质。这种效应与交流电信号的频率成正比关系，当频率髙到一定程度、令信号难以保持 稳定时，整个电子电路自然就无法正常工作。为此，电子学上就提出了带宽的概念，它指 的是电路可以保持稳定工作的频率范围。而这里所说的带宽，可以更确切地理解为模拟信 道的带宽。模拟信道可以理解为某个具体的电路，组成信道的电路制成了，信道的带宽就 决定了，为了使信号的传输失真小些，信道就需要有足够的带宽。</p><p>有了模拟信道带宽，自然就有与之对应的数字信道带宽的概念，这个概念也更接近于本书所要讨论的数字通信范畴。数字通信中离我们最近的概念是无线通信，无线通信的信道其实就是空间。显然，我们生活的周围不仅充满了无处不在的空气，同时也充满了无处 不在的电磁波，为了不至于使通信发生干扰，各个应用领域都有自己所能使用的频率范围， 这个频率范围就是信道的带宽。数字信道的带宽决定了信道能不失真地传输脉冲序列的最高速率。</p><p>既然信道带宽决定了传输脉冲序列的最高速率，因此两者之间必然存在一定的关系。 实际上这个关系可以用数学公式表达出来，更确切地讲，这个关系可以用两个定理来描述: 奈奎斯特（Nyquist)定理和香农（Shannon)定理。</p><p>早在1924年，贝尔实验室的研究员亨利•奈奎斯特就推导出了有限带宽无噪声信道的极限波特率，称为奈奎斯特定理。奈奎斯特定理指出，若信道带宽为W,则最大码元速率(Baud)。数据速率和波特率是两个不同的概念。若码元取两个离散值， 则一个码元携带1比特（bit)信息。若码元可取四种离散值，则一个码元携带2比特信息。 总之一个码元携带的信息量n(bit)与码元的种类数N的关系为n=logN（以2为底）。请大家注意，奈奎斯特定理与我们更为熟悉的奈奎斯特采样定理的区别。采样定理是描述模拟/数字信号的转换 过程中，采样频率与信号最高频率之间的关系。</p><p> 奈奎斯特定理仅描述了无噪声情况下信道带宽与波特率的关系，根据这一理论，只要增加每个码元的离散值数量，就可以增加信道中可以传输的信息量。然而无噪声的情况在现实中是不存在的。1948年香农定理的提出解决了有噪声情况下带宽与数据速率的关系问题，香农也因此被称为信息论和数字通信时代的奠基人。</p><p>香农定理表明，在高斯白噪声条件下实现无差错传输的信道容量（通常等同于最大数据速率）C可由下面的公式计算。 </p><p><img src="/2019/11/09/MATLAB2/1573291829918.png" alt="1573291829918"></p><p>式中，W为信道带宽，S为信号的平均功率，N为噪声的平均功率，S/N为信噪比。当噪声 为高斯白噪声时（功率谱密度为N0), N=WN0。这个公式与信号取的离散值无关，也就是说 无论用什么方式调制，只要给定了信噪比，则单位时间内最大的信息传输量就确定了。例如，信道带宽为3 000 Hz，信噪比为30 dB，则最大数据速率C≈30 000 bps。这是极限值, 只有理论上的意义。实际上在3 000 Hz带宽的电话线上数据速率能达到9 600 bps就很不错了。</p><p>从专业的角度去描述，带宽的意思是指波长、频率或能量带的范围，特指频带的上、 下边界频率之差。这里可以打个比喻，带就像高速公路的路面宽度和允许的最大车速，而数据流则相当于公路上的车流。当车的数量很少时，路面宽一些和窄一些，对车速都没有任何影响；随着车流的逐渐增大，直至某个临界点，路面宽度对车流量的影响才一 下子凸显出来，路面窄的话，就不能让更多的车辆在同一时间内通过，甚至造成大塞车。 当然，我们也可以提高允许的最大车速，这样也能使得在单位时间内通过更多的车。也就 是说带宽是用来描述频带宽度的，但是在数字传输方面，也常用带宽来衡量传输数据的能力。例如，用它来表示单位时间内传输数据容量的大小、数据吞吐的能力，而数据传输能力与信道带宽的关系又可以通过香农定理联系起来。</p><h4 id="噪声与信噪比"><a href="#噪声与信噪比" class="headerlink" title="噪声与信噪比"></a>噪声与信噪比</h4><p><strong>1.白噪声与高斯白噪声</strong></p><p>在讨论信噪比之前，先回顾一下噪声的概念。在通信中，噪声是无处不在的，正因为有噪声的存在，才使得信息的传输存在各种限制。一般来讲，我们将自然界中存在的随机信号称为噪声，将人为施加的无用信号称为干扰。如何有效避免干扰信号的影响是另外一 个复杂的研究课题，我们只讨论噪声在数字通信中的影响。</p><p>噪声，通常的概念指的是白噪声（WhiteNoise）白噪声是一种功率频谱密度为常数的随机信号或随机过程。换句话说，此信号在各个频段上的功率是一样的。相对地，其他不具有这一性质的噪声信号被称为有色噪声。理想的白噪声具有无限带宽，因而其能量无限大，这在现实世界是不可能存在的。实际上，我们常常将有限带宽的平整信号视为白噪声， 因为这样在数学分析上更加方便。一般来讲，只要一个噪声过程所具有的频谱宽度远远大 于它所作用系统的带宽，并且在该带宽中其频谱密度基本上可以作为常数来考虑，就可以 把它作为白噪声来处理。例如，热噪声和散弹噪声在很宽的频率范围内具有均匀的功率谱 密度，通常可以认为它们是白噪声。</p><p>另外一个经常提到的概念是高斯白噪声（White Gaussian Noise，WGN)。如果一个噪声， 它的幅度分布服从高斯分布，而它的功率谱密度又是均匀分布的，则称它为高斯白噪声。 也就是说，高斯白噪声也属于白噪声，只是其幅度分布服从高斯分布而已。高斯白噪声在仿真中应用十分广泛，因为实际系统（包括雷达和通信系统等大多数电子系统）中的主要噪声来源是热噪声，而热噪声是典型的高斯白噪声。</p><p>这里还需要再说明一下高斯白噪声对通信解调影响的直观理解。我们知道，数字通信中信噪比的大小直接会影响到解调端检测的错误概率。对于某个具体的通信体制及解调方 法，信噪比与误码率理论上有固定的换算关系。对于二进制调制方式来讲，检测端只需判 断出两种波形的区别即可正确解调出数据。例如，解调后的数据波形类似于正弦波形，这时，一定功率的噪声信号叠加上去，只要噪声的幅度大小不至于影响到信号波形的判决（判断时刻一般选在波峰或波谷处），也就是噪声的大小不会使波峰的值或波谷的值接近零值， 就不会出现误码检测的问题。我们用MATLAB仿真时，一般信噪比，如10dB,会感觉到 噪声的幅度好像根本不会出现很大值，也就是说根本不会影响到波形的判决。事实上是这 样吗？回想一下高斯分布的特征，虽然信号的大部分幅值都分布在零值附近，叠加到信号 上不会产生大的影响，但理论上每个噪声的幅度都可能是无限大的，只是大幅度的噪声值 出现的概率较小而已，当仿真的数据长度不够时，可能无法出现大幅度值的噪声值，当仿真数据长度足够时，大幅度值的噪声值将按照高斯分布的概率出现。这些大幅度值的噪声值叠加到信号上，就会引起检测的错误，产生一定的误码率。</p><p><strong>2.SNR与Eb/N0</strong></p><p>在模拟通信系统中，衡量信号质量的一个最重要的指标是信噪比（或称为SNR),指的是信号平均功率和噪声平均功率的比值，通常用dB单位表示。在数字通信中也有信噪比的概念，但与模拟通信不同，通常用信噪比的归一化形式(Eb/N0)作为性能指标。Eb为每比特信号的能量，等于信号功率S与每比特持续时间T的乘积 ; N0是噪声功率谱密度，等于噪声功率N与信道带宽W之比 ; 由于每比特持续时间T与比特速率R互为倒数，因此有下列表达式成立 </p><p><img src="/2019/11/09/MATLAB2/1573293152736.png" alt="1573293152736"></p><p>显然，只有当信道带宽W与比特速率R相等时，数字通信中的信噪比概念Eb/N0才与 S/N相同。作为数字通信系统性能的一个重要指标，可以将系统所需的Eb/N0作为比较两个通信系统性能优劣的量度。在给定的差错概率条件下，所需的Eb/N0越小，则系统性能越好。   </p><p>为什么数字通信要用Eb/N0作为衡量信号质量的指标，而不用呢S/N？接下来我们就这 个问题进行解释。</p><p>根据前面的讨论，功率信号定义为平均功率有限而能量无穷大的信号，而将能量信号定义为平均功率等于零而能量有限的信号。这样的分类在对模拟信号和数字信号进行比较时是非常有用的。我们将模拟信号归类为功率信号。这有什么意义呢？通常模拟波形的持续时间为无限长，不需要做分割或加时间窗。 简单说来，加时间窗会引起时域信号在频域的扩展，为减少这种频谱扩展，需要加减小扩展性能的时间窗，如汉明窗等）。对时域无限的电信号波形而言，其能量无穷大，因此不能用能量来描述该信号，而功率则是一个更有用的参数。</p><p>然而，数字通信系统采用时间长度为码元间隔的波形来发送和接收码元。每个码元的平均功率（在整个时间轴上取平均）等于零，所以功率不能用于描述数字信号。对于数字信号，应该采用能在时间窗内度量信号的测度来描述。也就是说，码元能量（功率在一个码元间隔内的积分）是一个更适于描述数字信号波形的参数。</p><p>接收能量可以很好地描述数字信号，但这还没有说明为什么Eb/N0是数字系统的一个很好的指标。数字波形是代表数字信息的媒介，消息可能包含1比特（二进制）、2比特（四 进制），甚至10比特（1024进制）等。与这种离散信息结构完全不同，模拟通信系统的信源是无限量化的连续波。数字系统的衡量指标必须在比特级上比较两个系统的性能。因为数字信号波形只可能包含1比特、2比特等以比特为单位的信息，所以无法用S/N对数字信号进行描述。例如，若给定差错概率，其二进制信号所需的S/N为20 dB,因为二进制波形包含1比特信息，所以每比特所需的S/N是20dB。若信号是1024进制的，所需的S/N仍为20 dB。由于该波形包含10比特信息，所以每比特所需的S/N为2 dB。由此产生一个问题，为什么不用更适合的参数——比特级别上的能量相关参数Eb/N0来描述这个指标呢？这正是数字通信采用Eb/N0来衡量信号质量的主要原因。</p><h3 id="蒙特卡洛仿真概念"><a href="#蒙特卡洛仿真概念" class="headerlink" title="蒙特卡洛仿真概念"></a>蒙特卡洛仿真概念</h3><h4 id="蒙特卡洛方法概述"><a href="#蒙特卡洛方法概述" class="headerlink" title="蒙特卡洛方法概述"></a>蒙特卡洛方法概述</h4><p><strong>蒙特卡洛(Monte Carlo)方法</strong>，又称随机抽 样或统计模拟方法，泛指所有基于统计采样进行数值计算的方法 。</p><p>蒙特卡洛方法是用于两类问题： –本身就具有随机性的问题； –能够转化为概率模型进行求解的确定性问题。 </p><h4 id="蒙特卡洛方法一般步骤"><a href="#蒙特卡洛方法一般步骤" class="headerlink" title="蒙特卡洛方法一般步骤"></a>蒙特卡洛方法一般步骤</h4><p>• 蒙特卡洛方法求解问题的三个步骤： </p><p>–构造或描述概率过程 </p><p>–从已知概率分布抽样</p><p> –建立估计量 </p><h4 id="蒙特卡洛方法特点"><a href="#蒙特卡洛方法特点" class="headerlink" title="蒙特卡洛方法特点"></a>蒙特卡洛方法特点</h4><p>• 蒙特卡洛方法不需要对输入过程和模型本身做太多 假设，具有通用性。</p><p> • 但是，蒙特卡洛方法估计的准确性与两方面的因素 有密切关系： </p><p>–一方面依赖于对输入随机变量或随机过程的采样方 法，比如上例中如果产生的随机数不是(0,1)区间上 的均匀分布，那么估计将是有偏的；</p><p> –另一方面依赖于随机试验次数，只有随机试验次数 足够多，才能够获得较准确的结果。 </p><h4 id="一个简单的通信仿真实例"><a href="#一个简单的通信仿真实例" class="headerlink" title="一个简单的通信仿真实例"></a>一个简单的通信仿真实例</h4><p>二进制反极性基带通信系统的蒙特卡洛仿真<br>我们用反极性信号波形和来发送二进制信息0和1，s(t)是能量为的任意波形，通过AWGN（高斯白噪声）信道之后接收信号波形可以表示为</p><p><img src="/2019/11/09/MATLAB2/1573307688214.png" alt="1573307688214"></p><p>这里n(t)是高斯白噪声，其功率谱密度为</p><p><img src="/2019/11/09/MATLAB2/1573307780877.png" alt="1573307780877"></p><p>用最佳接收机接收到的信号为</p><p><img src="/2019/11/09/MATLAB2/1573307816072.png" alt="1573307816072"></p><p>此处</p><p><img src="/2019/11/09/MATLAB2/1573307854985.png" alt="1573307854985"></p><p>n的数学期望与方差</p><p><img src="/2019/11/09/MATLAB2/1573307889116.png" alt="1573307889116"></p><p><img src="/2019/11/09/MATLAB2/1573307918352.png" alt="1573307918352"></p><p>系统误码率可用下式计算（推导详见《通信原理》）</p><p><img src="/2019/11/09/MATLAB2/1573307962488.png" alt="1573307962488"></p><p> 下面我们用蒙特卡洛仿真方法来估计该系统的误码率。<br>首先，建立仿真模型。由于假设接收机为理想的最佳接收机，因此没必要模拟整个信号的传输过程，而只关心最佳接收机输出端的信号组成。</p><p><img src="/2019/11/09/MATLAB2/1573287167758.png" alt="1573287167758"></p><p>该模型中包括对两个随机过程的采样，一个是模拟二进制信源的贝努里分布，另一个是模拟最佳接收机输出端所包含高斯噪声。<br>由于假设信源和信道均无记忆，且信源和信道相互独立，因此我们对这两个随机过程进行采样，只需要产生一系列相互独立、满足概率分布的随机变量即可。我们所关心的事件是判决结果与实际传送比特相反，建立的估计量使用错误事件的出现相对频率近似系统的误码率，即</p><p><img src="/2019/11/09/MATLAB2/1573308066999.png" alt="1573308066999"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%Monte Carlo Simulation to estimate bit error rate</span></div><div class="line">performance of a binary</div><div class="line"><span class="comment">%antipodal communication system</span></div><div class="line">clc</div><div class="line">clear</div><div class="line">N = [<span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>,<span class="number">1000000</span>];</div><div class="line">EbN0_indB = <span class="number">-2</span>:<span class="number">2</span>:<span class="number">8</span>;<span class="comment">%</span></div><div class="line">Ebn0 = <span class="number">10.</span>^(EbN0_indB/<span class="number">10</span>);</div><div class="line">E=<span class="number">1</span>;</div><div class="line">times = <span class="number">50</span>;</div><div class="line">err_rate = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Ebn0),<span class="built_in">length</span>(N),times);</div><div class="line"><span class="keyword">for</span> iiii=<span class="number">1</span>:<span class="built_in">length</span>(N)</div><div class="line">   <span class="keyword">for</span> iii=<span class="number">1</span>:<span class="built_in">length</span>(Ebn0)</div><div class="line">      sigma = E/sprt(<span class="number">2</span>*Ebn0(iii));</div><div class="line">      <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="number">10</span></div><div class="line">        r = <span class="built_in">rand</span>(<span class="number">1</span>,N(iiii));</div><div class="line">        source = double(r&gt;=<span class="number">0.5</span>);</div><div class="line">        x=<span class="number">1</span><span class="number">-2</span>*source;</div><div class="line">        noise = <span class="built_in">randn</span>(<span class="number">1</span>,N(iiii))*sigma;</div><div class="line">        y=E*x+noise;</div><div class="line">        result = double(y&lt;=<span class="number">0</span>);</div><div class="line">        error_num = sum(result-source&gt;<span class="number">1.e-6</span>);</div><div class="line">        err_rate(iii,iiii,ii) = error_num/N(iiii);</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p><img src="/2019/11/09/MATLAB2/1573287768315.png" alt="1573287768315"></p><p>可以看出，在同一信噪比条件下，仿真量越大相对误差的偏差越小；如果固定仿真量，相对误差的方差则随着信噪比的提高而迅速增大。</p><h3 id="通信系统仿真一般结构"><a href="#通信系统仿真一般结构" class="headerlink" title="通信系统仿真一般结构"></a>通信系统仿真一般结构</h3><p>matlab通信仿真的代码遵循模块化设计思想，属于不同模块的代码段与代码段间应隔开并附上代码段功能注释。</p><p>一个<strong>完整的matlab通信仿真程序</strong>一般由以下模块构成</p><p><strong>参数设定</strong></p><p><strong>信源</strong></p><p><strong>发射机</strong></p><p><strong>信道</strong></p><p><strong>接收机</strong></p><p><strong>信宿</strong></p><p><strong>仿真结果（比特信噪比 眼图 星座图等）</strong></p><p><strong>结论</strong></p><h3 id="通信仿真函数集"><a href="#通信仿真函数集" class="headerlink" title="通信仿真函数集"></a>通信仿真函数集</h3><p>以下函数可使用help&lt;函数名&gt;的命令查询帮助文档，此处仅列出以供查用</p><h4 id="数字信号处理部分"><a href="#数字信号处理部分" class="headerlink" title="数字信号处理部分"></a>数字信号处理部分</h4><p><a href="https://blog.csdn.net/reborn_lee/article/details/82868837" target="_blank" rel="external">https://blog.csdn.net/reborn_lee/article/details/82868837</a></p><h4 id="通信系统部分"><a href="#通信系统部分" class="headerlink" title="通信系统部分"></a>通信系统部分</h4><p><a href="http://bbs.21ic.com/icview-386187-1-1.html?_dsign=3d24a5ed" target="_blank" rel="external">http://bbs.21ic.com/icview-386187-1-1.html?_dsign=3d24a5ed</a></p>]]></content>
      
      
      <categories>
          
          <category> 通信仿真 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MATLAB通信仿真（一）</title>
      <link href="/2019/11/09/MATLAB1/"/>
      <url>/2019/11/09/MATLAB1/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB通信仿真（一）"><a href="#MATLAB通信仿真（一）" class="headerlink" title="MATLAB通信仿真（一）"></a>MATLAB通信仿真（一）</h1><p>​                            此系列资料为我的matlab通信仿真学习笔记以及通院科协授课用资料</p><p>​                                              内容参考蔡凡老师的公众号和CSDN博客</p><h2 id="MATLAB基础知识"><a href="#MATLAB基础知识" class="headerlink" title="MATLAB基础知识"></a>MATLAB基础知识</h2><h3 id="MATLAB概述"><a href="#MATLAB概述" class="headerlink" title="MATLAB概述"></a>MATLAB概述</h3><h4 id="MATLAB简介"><a href="#MATLAB简介" class="headerlink" title="MATLAB简介"></a>MATLAB简介</h4><p>​       MATLAB（matrix&amp;laboratory） 是美国MathWorks公司出品的商业数学软件，用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境，主要包括MATLAB和Simulink两大部分。   </p><p>​       它在数学类科技应用软件中在数值计算方面首屈一指。MATLAB可以进行矩阵运算、绘制函数和数据、实现算法、创建用户界面、连接其他编程语言的程序等，主要应用于工程计算、控制设计、信号处理与通信、图像处理、信号检测、金融建模设计与分析等领域。</p><h4 id="MATLAB系统结构"><a href="#MATLAB系统结构" class="headerlink" title="MATLAB系统结构"></a>MATLAB系统结构</h4><p>　　<strong>开发环境</strong></p><p>　　MATLAB开发环境是一套方便用户使用的MATLAB函数和文件工具集，其中许多工具是图形化用户接口。它是一个集成的 用户工作空间，允许用户输入输出数据，并提供了M文件的集成编译和调试环境，包括MATLAB桌面、命令窗口、M文件编辑调试器、MATLAB工作空间和在线帮助文档。</p><p>　　<strong>数学函数</strong></p><p>　　MATLAB数学函数库包括了大量的计算算法。从基本算法如四则运算、三角函数，到复杂算法如矩阵求逆、快速傅里叶变换等。</p><p>　　<strong>语言</strong></p><p>　　MATLAB语言是一种高级的基于矩阵/数组的语言，它有程序流控制、函数、数据结构、输入/输出和面向对象编程等特色。用这种语言能够方便快捷建立起简单运行快的程序，也能建立复杂的程序。</p><p>　　<strong>图形处理</strong></p><p>　　图形处理系统使得MATLAB能方便的图形化显示向量和矩阵，而且能对图形添加标注和打印。它包括强大的二维三维图形函数、图像处理和动画显示等函数。</p><p>　　<strong>程序接口</strong></p><p>　　MATLAB应用程序接口（API）是一个使MATLAB语言能与C、Fortran等其它高级编程语言进行交互的函数库。该函数库的函数通过调用动态链接库（DLL）实现与MATLAB文件的数据交换，其主要功能包括在MATLAB中调用C和Fortran程序，以及在MATLAB与其它应用程序间建立客户、服务器关系。</p><h4 id="MATLAB界面介绍"><a href="#MATLAB界面介绍" class="headerlink" title="MATLAB界面介绍"></a>MATLAB界面介绍</h4><p>打开MATLAB可见如下<strong>主界面</strong></p><p><img src="/2019/11/09/MATLAB1/1573254849370.png" alt="1573254849370"></p><p>主界面分为五个区域：工具栏、文件路径，当前文件夹，命令行窗口以及工作变量区域</p><p><strong>工具栏</strong> </p><p><img src="/2019/11/09/MATLAB1/1573255424804.png" alt="1573255424804"></p><p>工具栏区域包括文件、变量、代码、simulink、坏境设置和资源六大部分 </p><p><strong>文件路径</strong></p><p>文件路径是当前文件夹的地址，在该区域可以实现文件路径的切换 </p><p><img src="/2019/11/09/MATLAB1/1573255646816.png" alt="1573255646816"></p><p><strong>当前文件夹</strong></p><p>当前文件夹是显示当前文件路径下所有文件的窗口，可以在此双击打开所需要的不同格式文件</p><p><img src="/2019/11/09/MATLAB1/1573255901880.png" alt="1573255901880"></p><p><strong>命令行窗口</strong></p><p>命令窗口是进行一系列命令输入的地方，当有指令输入并按下Enter键时，软件会自动执行该条指令，并显示出该命令的结果 </p><p><img src="/2019/11/09/MATLAB1/1573256069978.png" alt="1573256069978"></p><p><strong>工作变量区</strong></p><p>工作变量区域是存放所执行程序中涉及到的所有变量值的空间，可以在该区域双击某变量查看其具体的变量表示情况  </p><p><img src="/2019/11/09/MATLAB1/1573256148715.png" alt="1573256148715"></p><h4 id="MATLAB的变量、运算符与表达式、常用命令"><a href="#MATLAB的变量、运算符与表达式、常用命令" class="headerlink" title="MATLAB的变量、运算符与表达式、常用命令"></a>MATLAB的变量、运算符与表达式、常用命令</h4><p><strong>MATLAB中的变量</strong></p><p>MATLAB并不要求事先对所使用的变量进行声明，也不需要指定变量类型，MATLAB语言会自动依据所赋予变量的值或对变量所进行的操作来识别变量的类型。在赋值过程中如果赋值变量已存在时，MATLAB语言将使用新值代替旧值，并以新值类型代替旧值类型。</p><p>在MATLAB语言中变量的<strong>命名应遵循如下规则</strong>：</p><p>（1）变量名区分大小写，myvar和myVar表示两个不同的变量。</p><p>（2）变量名长度不超63位，第31个字符之后的字符将被MATLAB语言所忽略。</p><p>（3）变量名以字母开头，可以是字母、数字、下划线组成，但不能使用标点和空格。</p><p>与其他的程序设计语言相同，在MATLAB语言中也存在变量作用域的问题。在未加特殊说明的情况下，MATLAB语言将所识别的一切变量视为局部变量，即仅在其使用的M文件内有效。若要将变量定义为全局变量，则应当对变量进行说明，即在该变量前加关键字global。一般来说全局变量均用大写的英文字符表示。</p><p><strong>MATLAB 中的运算符与表达式</strong></p><p><img src="/2019/11/09/MATLAB1/1573258784375.png" alt="1573258784375"></p><p><strong>MATLAB中的常用命令</strong></p><ul><li><code>clc</code> 清空命令窗口</li><li><code>clear</code> 清空工作区数据</li><li>clf  清除当前图形窗口内容</li><li>close all  关闭所有打开的图形窗口</li><li>who/whos  显示MATLAB工作空间中的变量/变量及信息</li><li>type&lt;文件名.m&gt;  显示指定m文件内容</li><li>help&lt;命令名&gt;  查询所列命令的帮助信息 </li><li><code>exit/quit</code> 关闭软件</li></ul><h3 id="MATLAB-M文件知识"><a href="#MATLAB-M文件知识" class="headerlink" title="MATLAB  M文件知识"></a>MATLAB  M文件知识</h3><p><strong>脚本式m文件</strong><img src="/2019/11/09/MATLAB1/1573261008198.png" alt="1573261008198"></p><p>脚本就是自动执行逐条命令的文件。如果编写了一个脚本式M文件，点击run就会自动一条一条命令顺序执行。和在命令窗写一条命令、执行一次的效果相同，过程中的变量都会被保存。 </p><p><strong>函数式m文件</strong><img src="/2019/11/09/MATLAB1/1573261054626.png" alt="1573261054626"></p><p>函数式m文件封装好特定功能的函数以供调用。此类m文件开头一般为如下格式，用以表明该m文件为函数式m文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[输出参数形式]</span> = 函数名 （函数形参表）</span></div><div class="line"></div><div class="line"><span class="comment">%注释说明语句段</span></div><div class="line"></div><div class="line"><span class="comment">%程序语句段</span></div></pre></td></tr></table></figure><p><strong>新建m文件的方法</strong></p><p>1.直接在命令行窗口输入edit</p><p>即可新建一个Untitled  m文件并直接编写</p><p>2.点击工具栏中的New Script新建脚本，或者点击New 选择New Script或者New Function</p><h3 id="MATLAB绘图知识"><a href="#MATLAB绘图知识" class="headerlink" title="MATLAB绘图知识"></a>MATLAB绘图知识</h3><h4 id="二维图形绘制"><a href="#二维图形绘制" class="headerlink" title="二维图形绘制"></a>二维图形绘制</h4><p><strong>常用基本函数</strong></p><p><code>plot()</code></p><p><code>(1)plot(x,y)</code>(其中，x和y分别用于存储x坐标和y坐标数据。通常，x和y为长度相同的向量。）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">例<span class="number">1</span>  绘制一条折线。</div><div class="line">    x=[<span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">    y=[<span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">1</span>, <span class="number">1.5</span>];</div><div class="line">    plot(x, y)</div></pre></td></tr></table></figure><p>(2)最简单的plot函数调用格式<br><code>plot(x)</code> 当plot函数的参数x是复数向量时，则分别以该向量实部和虚部为横、纵坐标绘制出一条曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x=[<span class="number">2.5</span>,<span class="number">3.5</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">y=[<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1.5</span>];</div><div class="line">cx=x+y*<span class="built_in">i</span>;     <span class="comment">%也可写为cx=complex(x,y);</span></div><div class="line">plot(cx)</div></pre></td></tr></table></figure><p>(3)plot(x,y)函数参数的变化形式</p><ul><li><p><strong>当x是向量，y是矩阵时</strong><br>1.如果矩阵y的列数等于x的长度，则以向量x为横坐标，以y的每个行向量为纵坐标绘制曲线，<strong>曲线的条数等于y的行数</strong>。<br>2.如果矩阵y的行数等于x的长度，则以向量x为横坐标，以y的每个列向量为纵坐标绘制曲线，<strong>曲线的条数等于y的列数</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">例<span class="number">2</span>  绘制<span class="built_in">sin</span>(x)、<span class="built_in">sin</span>(<span class="number">2</span>x)、<span class="built_in">sin</span>(x/<span class="number">2</span>)的函数曲线。</div><div class="line"> x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);              <span class="comment">%创建一个0到2pi的含有100个元素的列向量</span></div><div class="line"> y=[sin(x); sin(<span class="number">2</span>*x); sin(<span class="number">0.5</span>*x)];    <span class="comment">%y为含有三个元素的行向量</span></div><div class="line"> plot(x,y)</div></pre></td></tr></table></figure></li><li><p><strong>当x,y为同型矩阵时</strong><br>以x、y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数。</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;     </div><div class="line">t1=t';                 <span class="comment">%创建创建一个0到2pi的含有100个元素的列向量（每个元素之间间隔为0.01）</span></div><div class="line">x=[t1, t1, t1];</div><div class="line">y=[sin(t1), sin(<span class="number">2</span>*t1), sin(<span class="number">0.5</span>*t1)];</div><div class="line">plot(x,y)</div></pre></td></tr></table></figure><p>(4)含多个输入参数的plot函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(x1,y1,x2,y2,...,xn,yn)</div></pre></td></tr></table></figure><p>其中，每一向量对构成一组数据点的横、纵坐标，绘制一条曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">例<span class="number">3</span>  采用不同个数的数据点绘制正弦函数曲线，观察曲线形态。</div><div class="line">t1=<span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">10</span>);</div><div class="line">t2=<span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">20</span>);</div><div class="line">t3=<span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">100</span>);</div><div class="line">plot(t1, <span class="built_in">sin</span>(t1), t2,<span class="built_in">sin</span>(t2)+<span class="number">1</span>, t3, <span class="built_in">sin</span>(t3)+<span class="number">2</span>)</div></pre></td></tr></table></figure><p>（5）含选项的plot函数</p><p>plot函数可以增加一个参数用于指定曲线的线型、颜色和数据点标记。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">plot(x,y,<span class="string">'s'</span>)</div><div class="line"></div><div class="line">例<span class="number">4</span></div><div class="line">plot(x1, y1, <span class="string">'k:'</span>, x2, y2, <span class="string">'b--'</span>, x3, y3, <span class="string">'rp'</span>)</div></pre></td></tr></table></figure><table><thead><tr><th>线型</th><th>—</th><th>实线</th></tr></thead><tbody><tr><td></td><td>：</td><td>虚线</td></tr><tr><td></td><td>—.</td><td>点划线</td></tr><tr><td></td><td><em> </em></td><td>双划线</td></tr><tr><td>颜色</td><td>r</td><td>红色</td></tr><tr><td></td><td>g</td><td>绿色</td></tr><tr><td></td><td>b</td><td>蓝色</td></tr><tr><td></td><td>w</td><td>白色</td></tr><tr><td></td><td>k</td><td>黑色</td></tr><tr><td>数据点标记</td><td>*</td><td>星号</td></tr><tr><td></td><td>o</td><td>圆圈</td></tr><tr><td></td><td>s</td><td>方块</td></tr><tr><td></td><td>p</td><td>五角星</td></tr><tr><td></td><td>^</td><td>朝上三角符号</td></tr></tbody></table><p><strong>坐标轴调整</strong></p><p>axis函数：    </p><p><code>1.基本函数：</code>axis（[xmin,xmax,ymin,ymax,zmin,zmax]）` 用于控制坐标轴的选择范围       </p><p> 2.常用指令： axis equal:纵横坐标轴采用等长的刻度         axis square：产生正方形坐标系（默认为矩形）          axis auto：使用默认设置           axis off：取消坐标轴             axis on：显示坐标轴               grid on/grid off/grid box on/box off/box ：给坐标系加网络、边框     hold on/hold off/hold ：图形保持</p><p><strong>窗口分割</strong></p><p><code>subplot(m,n,p)</code>,其中m和n指定将图形窗口分成m*n个绘图区，p指定当前活动区。 默认顺序从左到右，自上而下。</p><p><strong>图形标识</strong></p><p>在title（）、xlabel（）、ylabel（）、zlabel（）、text () 等函数中填入正确参数为绘制的图形添加标题、坐标轴标注 、文本标注。</p><p><img src="/2019/11/09/MATLAB1/1573269906162.png" alt="1573269906162"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">title(<span class="string">'图形标题'</span>,<span class="string">'属性名'</span>,<span class="string">'属性值'</span>)</div><div class="line">text(x,y,<span class="string">'说明'</span>)   xy为文本的坐标位置</div><div class="line">xlabel(<span class="string">'x轴说明'</span>)</div><div class="line">ylabel(<span class="string">'y轴说明'</span>)</div><div class="line">z轴同理</div><div class="line"></div><div class="line">例<span class="number">5</span></div><div class="line">title(<span class="string">'y=cos&#123;\omega&#125;t'</span>,<span class="string">'FontSize'</span>,<span class="string">'24'</span>)</div><div class="line">text(<span class="number">3</span>, <span class="number">0.28</span>, <span class="string">'\leftarrow sin(x)'</span>)</div></pre></td></tr></table></figure><p><strong>坐标系选取</strong></p><p><code>极坐标系</code></p><p>polar(theta, rho, ‘选项’)     </p><p>其中，theta为极角，rho为极径，选项的内容与plot函数相同。 </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">例<span class="number">6</span> 按极坐标方程ρ=<span class="number">1</span>-<span class="built_in">sin</span> t绘制心形曲线。</div><div class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</div><div class="line">r = <span class="number">1</span>-<span class="built_in">sin</span>(t);</div><div class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line">polar(t,r)</div><div class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">t1 = t-<span class="built_in">pi</span>/<span class="number">2</span>;</div><div class="line">r1 = <span class="number">1</span>-<span class="built_in">sin</span>(t1);</div><div class="line">polar(t,r1)</div></pre></td></tr></table></figure><p><code>对数坐标</code></p><p>通信仿真中常用于绘制误码率曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">semilogx(x1, y1, <span class="string">'选项1'</span>, x2, y2, <span class="string">'选项2'</span>, …) </div><div class="line"></div><div class="line">semilogy(x1, y1, <span class="string">'选项1'</span>, x2, y2, <span class="string">'选项2'</span>, …) </div><div class="line"></div><div class="line">loglog(x1, y1, <span class="string">'选项1'</span>, x2, y2,<span class="string">'选项2'</span>, …) </div><div class="line"></div><div class="line">plotyy(x1,y1,<span class="string">'选项'</span>)双y轴坐标绘图</div><div class="line"></div><div class="line">例<span class="number">7</span> </div><div class="line">semilogy(ebno,th161_01_bit_err_ratio,<span class="string">'-*'</span>,ebno,th161_05_bit_err_ratio,<span class="string">'r-o'</span>,ebno,th161_075_bit_err_ratio,<span class="string">'k-&gt;'</span>);</div><div class="line">xlabel(<span class="string">'比特信噪比'</span>);</div><div class="line">ylabel(<span class="string">'误码率 '</span>);</div></pre></td></tr></table></figure><p><img src="/2019/11/09/MATLAB1/1573276068497.png" alt="1573276068497"></p><h3 id="MATLAB流程控制"><a href="#MATLAB流程控制" class="headerlink" title="MATLAB流程控制"></a>MATLAB流程控制</h3><p>if switch for while语句结构和C语言基本一致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>  表达式<span class="number">1</span></div><div class="line"></div><div class="line">执行语句<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">elseif</span> 表达式<span class="number">2</span></div><div class="line"></div><div class="line">执行语句<span class="number">2</span></div><div class="line"></div><div class="line"><span class="keyword">else</span></div><div class="line"></div><div class="line">    语句n</div><div class="line"></div><div class="line"><span class="keyword">end</span>    </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">switch</span>   表达式</div><div class="line"></div><div class="line">   <span class="keyword">case</span>  常量表达式<span class="number">1</span></div><div class="line"></div><div class="line">         语句块<span class="number">1</span></div><div class="line"></div><div class="line">   <span class="keyword">case</span>   常量表达式<span class="number">2</span></div><div class="line"></div><div class="line">         语句块<span class="number">2</span></div><div class="line"></div><div class="line">   <span class="keyword">case</span>   &#123;常量表达式n，常量表达式n+<span class="number">1</span>，…&#125;</div><div class="line"></div><div class="line">         语句块n</div><div class="line"></div><div class="line"><span class="keyword">otherwise</span></div><div class="line"></div><div class="line">语句块n+<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">while</span> 表达式</div><div class="line"></div><div class="line">循环体语句</div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span>=表达式</div><div class="line"></div><div class="line">循环体语句</div><div class="line"></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>另外还有一种流控结构：试探结构</p><p>这种结构可自查错误并提前做好预备方案</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">   尝试执行的语句块</div><div class="line"><span class="keyword">catch</span> 用于存储错误的变量</div><div class="line">   出错后执行语句块</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>用例详见matlab帮助文档中的try-catch页面</p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/try.html" target="_blank" rel="external">https://ww2.mathworks.cn/help/matlab/ref/try.html</a></p><h3 id="MATLAB文件操作"><a href="#MATLAB文件操作" class="headerlink" title="MATLAB文件操作"></a>MATLAB文件操作</h3><p>matlab可对音频文件进行采样、也可对图像、视频文件进行处理，可以在这些文件基础上运用数字信号处理的知识以及进行算法研究。</p><p>以下给出基础文件操作函数，需要用时使用help&lt;函数名&gt;查询matlab帮助文档。</p><p><img src="/2019/11/09/MATLAB1/1573281160936.png" alt="1573281160936"></p><p><strong>此处新版本可用audioread()函数读取多种格式的音频文件</strong></p><p><img src="/2019/11/09/MATLAB1/1573281242703.png" alt="1573281242703"></p><p><img src="/2019/11/09/MATLAB1/1573281110649.png" alt="1573281110649"></p><p><img src="/2019/11/09/MATLAB1/1573281091952.png" alt="1573281091952"></p><p><img src="/2019/11/09/MATLAB1/1573281068402.png" alt="1573281068402"></p>]]></content>
      
      
      <categories>
          
          <category> 通信仿真 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>树莓派3b+ opencv3.4.1 QT USB摄像头 串口配置</title>
      <link href="/2019/02/26/rasp/"/>
      <url>/2019/02/26/rasp/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派3b-OpenCV3-4-1-USB摄像头-串口配置教程"><a href="#树莓派3b-OpenCV3-4-1-USB摄像头-串口配置教程" class="headerlink" title="树莓派3b+   OpenCV3.4.1    USB摄像头 串口配置教程"></a>树莓派3b+   OpenCV3.4.1    USB摄像头 串口配置教程</h1><p>本来这个教程写了个开头不打算写完的，感觉没啥意思。结果周末的时候配串口把系统搞崩了，所以重装就顺便记一下了。</p><p>首先记一下出错：配串口的时候在config文件里加了一行代码之后重启出现了kernel panic-not syncing:attempted to kill init!之后科协的同学教我把存储卡里的boot文件夹在PC上打开找到config.txt删掉多加的那行代码就可以重启了。不过后来始终配不起来串口，一改config就开始崩，反反复复操作了好几次最后直接boot文件夹都windows不可识别了。树莓派也重启不了啦。一直重装一直爽，愿天堂不需要编译OpenCV。</p><h2 id="材料及软件清单："><a href="#材料及软件清单：" class="headerlink" title="材料及软件清单："></a>材料及软件清单：</h2><p>Raspberry Pi 3b+     TF存储卡（大于8G）  读卡器    /     DiskImager    VNCViewer（csdn上都有安装包)</p><h2 id="树莓派系统-Paspbian-下载及烧录："><a href="#树莓派系统-Paspbian-下载及烧录：" class="headerlink" title="树莓派系统(Paspbian)下载及烧录："></a>树莓派系统(Paspbian)下载及烧录：</h2><p>1.进入<a href="https://www.raspberrypi.org/" target="_blank" rel="external">https://www.raspberrypi.org/</a></p><p>  点击导航栏Downloads</p><p><img src="/2019/02/26/rasp/1550199513711.png" alt="1550199513711"></p><p>2.选择Raspbian</p><p><img src="/2019/02/26/rasp/1550199744281.png" alt="1550199744281"></p><p>3.下载系统镜像压缩包（Dwonload ZIP），左上为带图形界面及推荐软件版，右上带图形界面，左下纯命令行</p><p><img src="/2019/02/26/rasp/1550199826769.png" alt="1550199826769"></p><p>4.下载后解压至任意路径（<strong>注意不能含有中文路径</strong>）</p><p>​    得到后缀为img的镜像文件</p><p>5.接下来打开 DiskImager烧录系统</p><p>   Device选择读卡器的U盘、ImageFile选择刚刚解压img镜像文件路径</p><p>   点击Write</p><p><img src="/2019/02/26/rasp/1550200210722.png" alt="1550200210722"></p><p>等待出现Write Successfully弹窗</p><p>6.插入烧录好Paspbian的存储卡，连接电源和显示器，等待开机。</p><p><strong>注意：</strong>初始系统设置弹窗注意看提示语，别一路NEXT，赶时间最后一步需要下载东西的check for update可以跳过</p><h2 id="vnc-server远程PC桌面登录树莓派（如果有需要的话）"><a href="#vnc-server远程PC桌面登录树莓派（如果有需要的话）" class="headerlink" title="vnc server远程PC桌面登录树莓派（如果有需要的话）"></a>vnc server远程PC桌面登录树莓派（如果有需要的话）</h2><p>其实vnc后期不能远程显示摄像头的图像框的，而且有时候画面还会卡。</p><p>1.首先确保PC和树莓派处在同一个网络下，在树莓派的命令行里输入vncserver</p><p>2.打开PC端的vncviewer输入树莓派显示的ip地址</p><p><img src="/2019/02/26/rasp/1551107426897.png" alt="1551107426897"></p><p>3.输入用户名和密码，用户名默认pi,密码为第一次开机自己设定的登录密码。</p><p><img src="/2019/02/26/rasp/1551107469951.png" alt="1551107469951"></p><p>4.获得PC远程图形桌面登录。</p><p><img src="/2019/02/26/rasp/1551107570897.png" alt="1551107570897"></p><h2 id="系统汉化教程（不存在的，这样编译报错都报中文我怎么查解决方案）"><a href="#系统汉化教程（不存在的，这样编译报错都报中文我怎么查解决方案）" class="headerlink" title="系统汉化教程（不存在的，这样编译报错都报中文我怎么查解决方案）"></a>系统汉化教程（不存在的，这样编译报错都报中文我怎么查解决方案）</h2><h2 id="NEXT——-gt"><a href="#NEXT——-gt" class="headerlink" title="NEXT——-&gt;"></a>NEXT——-&gt;</h2><h2 id="完整更新镜像源"><a href="#完整更新镜像源" class="headerlink" title="完整更新镜像源"></a>完整更新镜像源</h2><h4 id="1-备份"><a href="#1-备份" class="headerlink" title="1.备份"></a>1.备份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</div><div class="line">sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</div></pre></td></tr></table></figure><hr><h4 id="2-修改软件更新源，用中科大站点："><a href="#2-修改软件更新源，用中科大站点：" class="headerlink" title="2.修改软件更新源，用中科大站点："></a>2.修改软件更新源，用中科大站点：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/apt/sources.list</div></pre></td></tr></table></figure><p>修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free</div><div class="line"># Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;</div><div class="line">#deb-src http://archive.raspbian.org/raspbian/ stretch main contrib non-free rpi</div></pre></td></tr></table></figure><p>ctrl+o 保存 → 回车 确认 → ctrl+x 退出</p><hr><h4 id="3-再修改系统更新源："><a href="#3-再修改系统更新源：" class="headerlink" title="3.再修改系统更新源："></a>3.再修改系统更新源：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/apt/sources.list.d/raspi.list</div></pre></td></tr></table></figure><p>同样修改首行网址，修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui</div><div class="line"># Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;</div><div class="line">#deb-src http://archive.raspberrypi.org/debian/ stretch main ui</div></pre></td></tr></table></figure><p>ctrl+o 保存 → 回车 确认 → ctrl+x 退出</p><hr><h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update ; sudo apt-get upgrade ; sudo apt-get dist-upgrade ; sudo rpi-update</div></pre></td></tr></table></figure><p>此处为更新软件源列表、软件版本和内核版本，因为更新内容比较多，所以耗时长些（中间会需要多次选择y/n,10分钟警告+意外中断风险，需要关掉vnc）</p><h2 id="qt5下载及编译工具配置"><a href="#qt5下载及编译工具配置" class="headerlink" title="qt5下载及编译工具配置"></a>qt5下载及编译工具配置</h2><p>​           </p><ol><li>树莓派安装QT非常简单，只需要两句话，打开终端，输入以下命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install qt5-default</div><div class="line">sudo apt-get install qtcreator</div></pre></td></tr></table></figure><ol><li>一定要确保第一个安装成功了再输入第二个命令，如果安装第一个时提示需要xx依赖于xx，那么就把第一个命令改为</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo aptitude install qt5-default</div></pre></td></tr></table></figure><p>3.然后再输入上面的第二个命令</p><p>4.之后按下图进行编译工具配置</p><p><img src="/2019/02/26/rasp/70.png" alt="img"> </p><p><img src="/2019/02/26/rasp/1551144134510.png" alt="1551144134510"></p><p>compiler path: /usr/bin/arm-linux-gnueabihf-gcc</p><p><img src="/2019/02/26/rasp/1551144086897.png" alt="1551144086897"></p><h2 id="wiringpi配置"><a href="#wiringpi配置" class="headerlink" title="wiringpi配置"></a>wiringpi配置</h2><p>1.安装git工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git-core</div></pre></td></tr></table></figure><p>2.克隆wiringpi源码到本地并编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git://git.drogon.net/wiringPi</div><div class="line"></div><div class="line">cd wiringPi</div><div class="line"></div><div class="line">./build</div></pre></td></tr></table></figure><p>3.更新wiringpi库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd wiringPi</div><div class="line"></div><div class="line">git pull origin</div></pre></td></tr></table></figure><h2 id="串口配置（把这个放在前面，崩了我也不心疼，OpenCV编译放后面）"><a href="#串口配置（把这个放在前面，崩了我也不心疼，OpenCV编译放后面）" class="headerlink" title="串口配置（把这个放在前面，崩了我也不心疼，OpenCV编译放后面）"></a>串口配置（把这个放在前面，崩了我也不心疼，OpenCV编译放后面）</h2><p>1.将树莓派的硬件串口与mini串口默认映射对换</p><p>简单来说：硬件串口由硬件实现，有单独波特率时钟源，性能高，可靠，而mini串口要依附CPU内核提供时钟。因此我们要用硬件串口，但是树莓派3b的硬件串口默认连接的是蓝牙，所以我们要改一下，把蓝牙映射到mini串口上，而释放硬件串口。</p><p>首先查看有没有相关文件</p><p>命令行 cd /boot/overlays</p><p>可以看到有 README 和 pi3-miniuart-bt-overlay.dtb 或者是 pi3-miniuart-bt.dtb ，后面的缺了(overlay)但是在README中的解释是相同的，因此，认为是同一文件。如果没有的话，参考博客 给出链接点击 <a href="http://ukonline2000.com/wp-content/uploads/2016/03/" target="_blank" rel="external">http://ukonline2000.com/wp-content/uploads/2016/03/</a> 下载。</p><p><img src="/2019/02/26/rasp/20180401182317939" alt="img"> </p><p><img src="/2019/02/26/rasp/20180401182328507" alt="img"> </p><p>README文件中说明了此文件的功能是将树莓派3的蓝牙切换到mini串口(ttyS0),并且恢复硬件串口(ttyAMA0)到GPIO14&amp;15引脚中。</p><p>2.查看并修改串口映射关系</p><p> 终端输入  ls -l /dev</p><p>红框里面表示串口映射，有的可能只显示1个，没关系，修改之后两个就都显示出来了。</p><p><img src="/2019/02/26/rasp/20180401183514718" alt="img"> </p><p>现在来修改</p><p>命令行sudo nano /boot/config.txt</p><p>在该文件中加一行代码  dtoverlay=pi3-miniuart-bt</p><p><img src="/2019/02/26/rasp/2018040118404049" alt="img"> </p><p>然后保存文件，重启树莓派。</p><p>然后我们再次查看 命令行 ls -l /dev  此时两个都有了并且对调了</p><p><img src="/2019/02/26/rasp/20180401184314320" alt="img"> </p><p>可以看出，硬件串口(ttyAMA0)映射到了GPIO Tx(14) Rx(15) 引脚上。</p><p>3.禁用串口的控制台功能。</p><p>前面步骤已经交换了硬件串口与mini串口的映射关系，但是，现在还不能使用树莓派串口模块与电脑进行通信，因为，树莓派io口引出串口默认是用来做控制台使用的，即是为了用串口控制树莓派，而不是通信。所以我们要禁用此默认设置。</p><p>两个命令</p><p>sudo systemctl stop serial-getty@ttyAMA0.service<br>sudo systemctl disable serial-getty@ttyAMA0.service</p><p>然后命令行</p><p>sudo nano /boot/cmdline.txt<br>删除语句 console=serial0,115200</p><p>保存之后内容如下，有的可能不一样</p><p><img src="/2019/02/26/rasp/20180401185342112" alt="img"> </p><p>然后重启树莓派，</p><p>配置结束。</p><p>接下来我们先配视觉处理环境，最后进行OpenCV、QT和串口的联合测试。</p><h2 id="OpenCV和摄像头配置"><a href="#OpenCV和摄像头配置" class="headerlink" title="OpenCV和摄像头配置"></a>OpenCV和摄像头配置</h2><p>首先安装构建OpenCV的相关工具:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential cmake git pkg-config</div></pre></td></tr></table></figure><p>  之后安装常用图像工具包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 安装jpeg格式图像工具包</span></div><div class="line">sudo apt-get install libjpeg8-dev </div><div class="line"><span class="comment">// 安装tif格式图像工具包</span></div><div class="line">sudo apt-get install libtiff5-dev </div><div class="line"><span class="comment">// 安装JPEG-2000图像工具包</span></div><div class="line">sudo apt-get install libjasper-dev </div><div class="line"><span class="comment">// 安装png图像工具包</span></div><div class="line">sudo apt-get install libpng12-dev</div></pre></td></tr></table></figure><p>  再安装视频I/O包:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</div></pre></td></tr></table></figure><p>  下面安装gtk2.0(此处如果不换源的话几乎100%失败,所以安装好系统后马上更换源):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libgtk2.0-dev</div></pre></td></tr></table></figure><p>  然后是优化函数包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libatlas-base-dev gfortran</div></pre></td></tr></table></figure><p>  到此为止,需要安装的依赖项全部完成了,接下来开始安装Opencv,我们采用源码编译的方式安装:（要很久= =）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#下载OpenCV</div><div class="line">wget -O opencv-3.4.1.zip https://github.com/Itseez/opencv/archive/3.4.1.zip  </div><div class="line"> </div><div class="line"># 解压OpenCV</div><div class="line">unzip opencv-3.4.1.zip</div></pre></td></tr></table></figure><p>  前面已经把源代码解压了,所以现在要切换到源码的文件夹:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd opencv-3.4.1</div></pre></td></tr></table></figure><p>  新建一个名为build的文件夹用来存放cmake编译时产生的临时文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir build</div><div class="line">// 进入builf文件夹</div><div class="line">cd build</div></pre></td></tr></table></figure><p>  设置cmake编译参数，安装目录默认为/usr/local，在终端输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..</div></pre></td></tr></table></figure><p>   此过程中会下载部分文件,由于是外网,所以往往耗费较长时间,预计在十五分钟左右,请耐心等待</p><p>   cmake没问题的话,就可以继续下面的步骤,正式编译,继续输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 编译，以管理员身份，否则容易出错,-j4用来加快编译速度</div><div class="line">sudo make -j4</div><div class="line">// 安装</div><div class="line">sudo make install</div><div class="line">// 更新动态链接库</div><div class="line">sudo ldconfig</div></pre></td></tr></table></figure><p> 在用opencv调用前，请先完成以下操作</p><p><img src="/2019/02/26/rasp/1551143333503.png" alt="1551143333503"></p><p><img src="/2019/02/26/rasp/1551143406955.png" alt="1551143406955"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/modules-load.d/rpi-camera.conf</div></pre></td></tr></table></figure><p> 之后在最后一行上加上bcm2835-v4l2，这样就可以在opencv中调用官方的摄像头了</p><h2 id="OpenCV、QT和串口联合测试"><a href="#OpenCV、QT和串口联合测试" class="headerlink" title="OpenCV、QT和串口联合测试"></a>OpenCV、QT和串口联合测试</h2><p>   打开QtCreator，点击File，选择New File or Project，选择None-Qt Project,选择Plain C++ Project，点击choose ，然后基本都选默认的就行</p><p><img src="/2019/02/26/rasp/1547461824827032.png" alt="树莓派3B+安装QT及配置Opencv过程-杨幽科技"></p><p>  项目建立完成后在左栏就会看到一个*.pro文件，修改.pro文件中的内容，如下(直接复制即可)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">QT += core</div><div class="line">QT -= gui</div><div class="line"> </div><div class="line">TARGET = opencv_test</div><div class="line">CONFIG += console</div><div class="line">CONFIG -= app_bundle</div><div class="line"> </div><div class="line">INCLUDEPATH += /usr/local/include \</div><div class="line">                /usr/local/include/opencv \</div><div class="line">                /usr/local/include/opencv2</div><div class="line"> </div><div class="line">LIBS += /usr/local/lib/libopencv_calib3d.so //usr/local/lib/libopencv_core.so //usr/local/lib/libopencv_features2d.so //usr/local/lib/libopencv_flann.so //usr/local/lib/libopencv_highgui.so //usr/local/lib/libopencv_imgcodecs.so //usr/local/lib/libopencv_imgproc.so //usr/local/lib/libopencv_ml.so //usr/local/lib/libopencv_objdetect.so //usr/local/lib/libopencv_photo.so //usr/local/lib/libopencv_shape.so //usr/local/lib/libopencv_stitching.so //usr/local/lib/libopencv_superres.so //usr/local/lib/libopencv_videoio.so //usr/local/lib/libopencv_video.so //usr/local/lib/libopencv_videostab.so</div><div class="line"> </div><div class="line"> </div><div class="line">TEMPLATE = app</div><div class="line"> </div><div class="line">SOURCES += main.cpp</div><div class="line"></div><div class="line">LIBS +=-lwiringPi    #这个是wiringPi的库</div></pre></td></tr></table></figure><p>main.cpp内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wiringPi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wiringSerial.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </div><div class="line"> </div><div class="line"><span class="comment">//-----------------------------------【main( )函数】--------------------------------------------</span></div><div class="line"><span class="comment">//      描述：控制台应用程序的入口函数，我们的程序从这里开始</span></div><div class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span>  </span></div><div class="line">&#123;  </div><div class="line">   </div><div class="line">     <span class="keyword">int</span> fd;</div><div class="line">     <span class="keyword">char</span> str[<span class="number">6</span>],str1[<span class="number">6</span>];</div><div class="line">     <span class="keyword">if</span>(wiringPiSetupSys()&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//初始化wiringPi</span></div><div class="line"></div><div class="line">     <span class="built_in">sprintf</span>(str,<span class="string">"%s%s%s"</span>,<span class="string">"X"</span>,<span class="string">"110"</span>,<span class="string">"R"</span>);</div><div class="line">     <span class="built_in">sprintf</span>(str1,<span class="string">"%s%s%s"</span>,<span class="string">"Y"</span>,<span class="string">"220"</span>,<span class="string">"R"</span>);<span class="comment">//字串拼接，%s可替換成int/float</span></div><div class="line">    <span class="comment">//【1】从摄像头读入视频</span></div><div class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line">   </div><div class="line">    <span class="comment">//【2】循环显示每一帧</span></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </div><div class="line">    &#123;  </div><div class="line">   </div><div class="line">    </div><div class="line">     Mat frame;  <span class="comment">//定义一个Mat变量，用于存储每一帧的图像</span></div><div class="line">     capture&gt;&gt;frame;  <span class="comment">//读取当前帧</span></div><div class="line">     imshow(<span class="string">"读取视频"</span>,frame);  <span class="comment">//显示当前帧</span></div><div class="line">     waitKey(<span class="number">10</span>); </div><div class="line">    </div><div class="line">    </div><div class="line">     <span class="keyword">if</span>((fd=serialOpen(<span class="string">"/dev/ttyAMA0"</span>,<span class="number">9600</span>))&lt;<span class="number">0</span>)</div><div class="line">       &#123;</div><div class="line">        <span class="keyword">int</span> time = millis();</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"serial doesn't open,return -1,time is %d"</span>,time);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">         &#125;</div><div class="line">    serialPrintf(fd,str); </div><div class="line">    serialPrintf(fd,str1);</div><div class="line">    </div><div class="line">        </div><div class="line">    <span class="keyword">int</span> c = waitKey(<span class="number">10</span>);</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="number">27</span>) &#123; <span class="keyword">break</span>; &#125; <span class="comment">// escape</span></div><div class="line"></div><div class="line">    </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结果：测试成功！！！"><a href="#结果：测试成功！！！" class="headerlink" title="结果：测试成功！！！"></a>结果：测试成功！！！</h2><p>硬件连接不赘述，演示效果自己瞧，总之成功！！！</p><p>好了终于复活了。啊我活了，啊我又死了。过一会还要跑操，不过早上的课这周还没开始，所以要继续摸图像处理。我写这篇东西有啥意思呢？我现在就备份镜像，以后再也不白手又起家，卷土再重来了。配完环境的人，真的还能撑住写代码吗？？？</p><p>附备份镜像教程：</p><p>1.先右键新建一个文本文档，把它后缀名改成img。</p><p>2.使用diskimager软件选中刚刚新建的img文件路径。</p><p>3.点击read键将镜像读出。</p><p>参考网址：<a href="https://ayangyou.com/2019/01/24/raspberrypi_qt_opencv/" target="_blank" rel="external">https://ayangyou.com/2019/01/24/raspberrypi_qt_opencv/</a></p><p>​                  <a href="https://blog.csdn.net/qq_29781403/article/details/85093062" target="_blank" rel="external">https://blog.csdn.net/qq_29781403/article/details/85093062</a></p><p>​                  <a href="https://blog.csdn.net/u014415522/article/details/80645651" target="_blank" rel="external">https://blog.csdn.net/u014415522/article/details/80645651</a></p><p>​                   <a href="https://blog.csdn.net/qq_36326623/article/details/79780061" target="_blank" rel="external">https://blog.csdn.net/qq_36326623/article/details/79780061</a> </p><p>​                   <a href="https://www.itread01.com/content/1546097048.html" target="_blank" rel="external">https://www.itread01.com/content/1546097048.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>uCOSIII（二）</title>
      <link href="/2018/12/10/ucosiii2/"/>
      <url>/2018/12/10/ucosiii2/</url>
      
        <content type="html"><![CDATA[<h1 id="UCOSIII知识点小结"><a href="#UCOSIII知识点小结" class="headerlink" title="UCOSIII知识点小结"></a>UCOSIII知识点小结</h1><p>1、其中最有用的功能应该是时间片轮转法（ roundrobin), 这个是 uC/OS-II 中不支持的，但是现在已经是 uC/OS-III 的一个功能了 </p><p>2、uC/OS-III 被设计用于 32 位处理器， 但是它也能在 16 位或 8 位处理器中很好地工作。</p><p>3、一共有 2 种类型的实时系统：软实时系统和硬实时系统。硬实时系统中，运算超时是不允许发生的，运算超时会导致严重后果。但是在软实时系统中 ， 超时不会导致严重后果  </p><p>4、前后台系统：包含一个无限循环的模块实现需要的操作（后台）。中断处理程序实现异步事件（前台）。前台也叫做中断级，后台也叫作任务级。 </p><p>5、临界操作应该在任务级中被执行，不可避免地必须在中断处理程序中执行也要确保是在很短的时间内完成。 因为这会导致 ISR 占用更长的时间。 通常的， ISR 中使能相关的信息而在后台程序中执行相应的操作。 </p><p>6、ucos-iii中的任务（也叫做线程） 是一段简单的程序， 运行时完全地占用 CPU 。在单 CPU 中，任何时候只有 1 个任务被执行。 </p><p>7、内核的责任是管理任务，协调和切换多个任务依次享用 CPU 。让我们感觉是多个 CPU 在同时运行，也有利于处理模块化的应用 它也负责管理任务间的交流， 系统资源的管理（内存 和I/O ）等。 </p><p>8、uC/OS-III 是一个抢占式内核， 这意味着 uC/OS-III 总是执行最</p><p>重要的就绪任务 </p><p>9、ISR 响应中断请求设备， 但是 ISR 只做非常少的工作。 ISR </p><p>应该标记或发送消息到一个高优先级的任务， 让中断能够快速处理完毕 </p><p>10、系统中加入内核需要额外的支出，因为内核提供服务时需要时间</p><p>去处理。内核占用 CPU 的时间介于 2% 到 4% 之间。 因为 uC/OS-III是一个软件，添加到目标系统中需要额外的 ROM 和 RAM 。 </p><p>11、。 uC/OS-III 内核需要 1K 到 4K 之间的 RAM ， 加上每个任务自己所需的堆栈空间。 至少有 4K 大小 RAM 的处理器才有可能成功移植 uC/OS-III 。 </p><p>12、： uC/OS-III 允许多个任务拥有相同的优先级。 当多个相同优先级的任务就绪时， 并且这个优先级是目前最高的uC/OS-III 会分配用户定义的时间片给每个任务去运行。 每个任务可以定义不同的时间片 。</p><p>13、uC/OS-III 保护临界段可以通过锁定调度器代替关中断。 因此关中断的时间会非常少。这样就使 uC/OS-III 可以响应一些非常快的中断源了。 </p><p>14、 uC/OS-III 允许用户在运行时配置内核。特别的，所有的内核对象如任务、堆栈、信号量、事件标志组、消息队列、 消息、 互斥信号量、 内存分区、 软件定时器等都是在运行时分配的 , 以免在编译时的过度分配。 </p><p>15、uC/OS-III 对任务数量、任务大小、优先级数量无限制。每一个任务需要有自己的堆栈空间。实际上， 任务的数量和大小限制于处理器能提供的内存大小。 </p><p>16、uC/OS-III 支持任何数量的任务、信号量、 互斥信号量、 事件标志组、 消息队列、 软件定时器、 内存分区。 用户在运行时分配所有的内核对象。 </p><p>17、互斥信号量用于资源管理。它是一个内置优先级的特殊类型信号量， 用于消除优先级反转。 互斥信号量可以被嵌套，因此，任务可申请同一个互斥信号量多达 250 次。当然， 互斥信号量的占有者需要释放同等次数。 </p><p>18、： uC/OS-III 允许任务停止自身或者停止另外的任务。 停止一个任务意味着这个任务将不再执行直到被其他的任务复。 停止可以被嵌套到 250 级。 换句话说， 一个任务可以停止另外的任务多达 250 次。 当然， 这个任务必须被恢复同等次数才有资格再次获得 CPU 。 </p><p>19、可以定义任意数量的一次性的、周期性的、或者两者兼有的软件定时器。 定时器是倒计时的， 执行用户定义的行为一直到计数减为 0 。 每一个定时器可以有自己的行为， 如果一个定时器是周期性的，计数减为 0 时会自动重装计数值并执行用户定义的行为。 </p><p>20、： uC/OS-III 允许任务等待多个事件的发生。等待中的任务在所有事件发生后被唤醒 </p><p>21、 uC/OS-III 允许 ISR 或者任务直接地发送信号量给其它任务。 这样就避免了必须产生一个中间级内核对象如一个信号量或者事件标志组只为了标记一个任务。提高了内核性能。 </p><p>22、：每一个任务可以拥有用户可定义的任务寄存器，不同于 CPU 寄存器。uC/OS-III 能检测指针是否为 NULL 、 在 ISR 中调用的</p><p>任务级服务是否允许、 参数在允许范围内、 配置选项的有效性、 函数的执行结果等。每一个 uC/OS-III 的 API 函数返回一个对应于函数调用结果的错误代号 </p><p>23： uC/OS-III 有内置性能测量功能。 能测量每一个任务的执行时间 , 每个任务的堆栈使用情况， 任务的执行次数， CPU的使用情况， ISR 到任务的切换时间 , 任务到任务的切换时间， 列表中的对象的峰值数，关中断、锁调度器平均时间等。 </p><p>24 、uC/OS-III 被设计于能够根 CPU 的架构被优化 uC/OS-III 所用的大部分数据类型能够被改变， 以更好地适应 CPU 固有的字大小。 优先级调度法则可以通过编写一些汇编语言而获益于一些 特 殊 的 指令如位设置、位清除、计数器清零指令（ CLZ ）、find-first-one(FF1) 指令</p><p>25、uC/OS-III 中所有的挂起服务都可以有时间限制， 预防死锁。</p><p>26、uC/OS-III 有时基任务， 时基 ISR 触发时基任务。 uC/OS-III 使27、uC/OS-III使用了哈希列表结构， 可以大大减少处理延时和任务超时所产生的开支。 </p><p>28、uC/OS-III 允许程序员定义 hook 函数。hook 函数允许用户扩展 uC/OS-III 的功能。 </p><p>29、为了测量时间， uC/OS-III 需要一个 16 位或者 32 位的时时间戳计数器。 </p><p>30、 每个 uC/OS-III 的内核对象有一个相关联的名字。 这样</p><p>就能很容易的识别出对象所指定的作用。对象的名字长度没有限制，但是必须以空字符结束。 </p><p>31、每个任务需要创建自己的堆栈。 堆栈的数据类型 CPU_STK 。堆栈可以被静态地分配或者通过 malloc() 动态地分配。若任务将不会被删除，堆栈将一直被使用。 </p><p>32、在大部分处理器中， 中断在启动时是关闭的。 无论如何， 在启动时关闭所有的外设中断是最安全的。 </p><p>33、uC/OS-III 须创建空闲任务 OS_IdleTask （）， 当没有其他任务运行时就运行空闲任务。根 据 配 置 文 件 中 所 uC/OS-III 会 创 建 统 务OS_StatTask() 、 定 时 器任务 OS_TmrTask() 、 中 断队 列 处 理任务OS_IntQTask() 。</p><p>34、 OSTaskCreate() 的第四个参数， 第一次被调用时OSTaskCreate() 接收这个变量， 传递给所创建的任务中的唯一参数”p_arg”。该参数可以是任意类型的指针。 </p><p>35、参数值越小优先级越高。 可以设置优先级数值为 1 到 OS_CFG_PRIO_MAX-2 。 要避免使用优先级 #0 和优先级 </p><p>OS_CFG_PRIO_MAX-1 。 因 为 这些是为 uC/OS-III保留的。</p><p>36、任务的堆栈大 ( 以 CPU_STK 为数据类型而不是字节 ) 。 例如， 如果要分配 1KB 大小的堆栈空间，因为 CPU_STK 是 32 位的，所以这个其值为 256. </p><p>37、）所有的 uC/OS-III 任务需要被设置为无限循环。 </p><p>38、互斥信号量（ mutex ）是一个内核对象，用于保护共享资源。 任务要访问共享资源就必须先获得 mutex 。mutex的拥有者使用完这个资源后就必须释放这个 mutex 。 </p><p>39、消息队列是一个内核对象， ISR 或任务可以直接发送消息到另一个任务。 发送者制定一个消息并将其发送到目标任务的消息 队列。 目标任务等待消息的到达。 </p><p>40、定义消息队列可接受消息的个数。 这个值必须大于 0 。如果</p><p>消息者发送消息数超过了消息接收任务的承受能力。那么消息将会被丢失。可以通过增加消息队列的大小或者提供消息接收任务的优先级提升其承受能力。 </p><p>41、uC/OS-III 定义了一个进入临界段的宏和两个出临界段的宏（退出临界段后是否调用调度器）。 </p><p>42、测得消息是什么时候被发送的， 用户就能测得任务接收这</p><p>个消息所用的时间。 读取现在的时间戳并减去消息被发送时的时</p><p>戳。需注意的是， 消息被发送时， 等待消息的任务可能不会立即接收到消息，因为 ISR 或更高优先级的任务可能抢占了当前任务。显然，测出的时间还包括了测量时消耗的额外时间。 然而减掉测量时所耗时间就是实际上的时间。 </p><p>43、时间戳的控制单元位于 CPU_TS 中。 例如， 如果 CPU 速率为 1MHz ， 时间戳的速率为 1MHz 。 那么CPU_TS 的分辨率为 1 微秒 </p><p>44、当任务第一次执行时， 会传入一个变量 “p_arg” 。这是一个指向 void的指针。 用于变量的地址、 结构体地址、 或者函数的地址等。 如果需要，可以创建多个相同的任务，使用相同的代码（相同任务体），而产生有不同的运行结果。</p><p>45、只运行一次的任务结束时必须通过调用 OSTaskDel() 删除自己。 这样可以使系统中的任务数减少。 </p><p>46、一个任务可以创建其它任务（ 调 OSTaskCreate() ）、 停止或者恢复其它 ( 调用 OSTaskSuspned() 和 OSTaskResume()) 、 提交信号量到其它任务、 发送消息到其它任务、 提供共享资源等。 换句话说， 任务不是只被限制于“等待事件”。 </p><p>47、在嵌入式系统中动态地分配堆栈是被允许的，但是，一旦堆栈被动态分配，它就不能被回收。 换句话说， 对于有些不需要被删除的任务， 动态分配它们的堆栈是一种很好的解决方法。</p><p>48、可以人工地计算出任务需要的堆栈空间大小，逐级嵌套所有可能</p><p>被调用的函数， 添加被调用函数中所有的参数， 添加上下文切换时的CPU 寄存器空间， 添加切换到中断时所需的 CPU 寄存器空间，添加处理 ISRs 所需的堆栈空间。 把上述的全部相加， 得到的值定义为最小的需求空间。 因为我们不可能计算出精确的堆栈空间。 通常是再乘以 1.5 以确保任务的安全运行。</p><p>49、另一种防止堆栈溢出的方法是分配的空间远大于可能需要的。  首先， 当任务创建时其堆栈被清零。 程序运行一段时间后，通过一个低优先级任务， 计算该任务整个堆栈中值为 0 的内存大小。 这是一种非常有效的方法。 注意的是， 程序需用运行很长的时间以让堆栈达到其需要的最大值。 </p><p>50、从用户的观点来看，任务可以是有 5 种状态，休眠状态，就绪状态，运行状态，挂起状态，中断状态 。</p><p>51、调用 OSTaskSuspend() 会任务无条件地停止运行。 有些时候调用 OSTaskSuspend() 不是为了等待某个事件的发生，而是等待另一个任务调用 OSTaskResume() 函数恢复这个任务。 </p><p>52、任务控制块是被 uC/OS-III 用于维护任务的一个结构体。 每个任务都必须有自的己 TCB 。TCB 中的一些变量可以根据具体应用进行裁剪。用户程序不应该访问这些变量（尤其不能更改它们） </p><p>53、有些处理器有硬件寄存器可以自动地检测并确保堆栈不发生溢出， 如果处理器没有这些硬件施，ucos-iii的堆栈检测可以用软件模拟。 然而， 软件模拟不如硬件可靠。</p><p>54、在 uC/OS-III 初始化的时候，它会创建至少 2 个内部的任务 (OS_IdleTask() 和 OS_TickTask()) ， 3 个可选择的任务（ OS_StatTask() ，OS_TmrTaks() ， OS_IntQTask() ）。这些可选择的任务在编译时由OS_CFG.H 中的配置决定。 </p><p>55、当 CPU 中没有其它就绪任务运行时，空闲会被运行。空闲任务是一个无限循环的不会等待任何事件的任务。空闲任务的每次循环，都会调用 OSIdleTaskHook() 函数，这个函数提供给用户扩展应用，如让处理器进入低功耗模式等。</p><p>56、） 使用硬件定时器并被设置为以 10 到 1000Hz 之间的频率</p><p>产生时基中断，时基中断并不是一定要用 CPU 产生， 事实上， 它可以从其他的具有较精确的周期性时间源中获得，比如电源线（ 50-60Hz ）等。 </p><p>57、当时基任务执行时，它会遍历挂起队列中所有等待期满的任务或等待事件超时的任务。 它会就绪时基列表中的那些期满、超时的任务。使用轮转法遍历队列（此队列为二维数组的形式）大大减少了遍历队列所占用CPU的时间。</p><p>58、统计任务能够统计总的 CPU 使用率, 每个任务的 CPU使用率，每个任务的堆栈使用量。 </p><p>59软件定时器通常需要的频率可由用户设置， 通过软件将时基分频。 换句话说如果时基速率为 1000Hz, 但是想要的定时器速率为 10Hz, 软件定时器任务会每 100 个时基被标记一次。时基任务的优先级要高于定时器任务，定时器任务的优先级需要于统计任务 </p><p>60、当一个任务创建了一个具有相同优先级的任务，这个新任务会被</p><p>添加到该优先级队列的尾部（因为具有相同优先级情况下， 没有理由让新任务先运行）。然而，当一个任务创建了一个具有不同优先级的任务时，这个新的任务就会放到对应优先级列表中的首部。注意：正在运行的任务也被放在就绪列表中。 </p><p>61会发生调度的调度点：任务被标记或发送消息给另一个任务 </p><p>、任务调用 OSTimeDly() 或 OSTimeDlyHMSM()、任务所等待的事件发生或超时、任务被取消挂起 、新任务被创建 、任务被删除 、内核对象被删除 、任务改变自身的优先级或其它任务的优先级 、任务通过调用OSTaskSuspend() 停止自身、任务调用OSTaskResume() 恢复其它停止了的任务、退出中断服务程序 、通过调用 OSSchedUnlock() 调度器被解锁、调用OSSchedRoundRobinYield() 任务放弃了分配给它的时间片、用户调用OSSched() </p><p>62、任务提交一个事件后调用调度器。 当然， 任务可以一次性提交多个事件， 但在最后一个事件提交后才调用调度器。 </p><p>63、uC/OS-III 有 2 种调度方式： OSSched() 被用于任务级。 OSIntExit()被用于中断级。由于中断产生时已经将任务 A 的状态保存在任务 A 的堆栈中，所以 ISR 返回时无需再保存任务 A 的状态，而是直接载入任务 B 的 CPU 寄存器到硬件CPU 寄存器中即可 </p><p>64、当 uC/OS-III 转向执行另一个任务的时候，它保存了当前任务的 CPU 寄存器到堆栈。并从新任务堆栈中 相关内容载入CPU 寄存器。这个过程叫做上下文切换。上下文切换需要一些开支。 CPU 的寄存器越多， 开支越大。 上下文切换的时间基本取决于有多少个 CPU 寄存器需要被存储和载人。保存状态寄存器和程序指针寄存器到当前的任务堆栈。保存的顺序与中断发生时 CPU 保存寄存器的顺序相同。</p><p>65、CPU 处理中断有两种模式： 1 所有的中断指向同一个 ISR2 每个中断指向各自的 ISR 。） ISR 的工作完成后， 用户必须调用 OSIntExit() 告诉 uC/OS-III中断服务程序已经完成。</p><p>66、uC/OS-III 有两种方法处理来自于中断的时间； 直接提交和延迟提交。其区别在于如何处置中断中所产生的事件。延迟提交的方式为事件不是直接发送给任务， 而是先发送到中断队列。 然后中断处理任务（其优先级为0）被就绪，这样，事件的提交便可在任务级完成，从而减少了ISR处理的时间。</p><p>67、uC/OS-III 必须有系统时基是普遍的误解。 事实上， 很多低功耗应用中没有系统时基，因为需额外的能量用于维护时基源。换句话说 ，将能量用于维护时基源是不合理的。因为 uC/OS-III 是一个可抢占式内核， 一个事件可以唤醒进入低功耗模式处理器（按键或其它事件）没有时基意味着用户不能再对任务进行延时或超时设置。 用户在研发低功耗产品时可以考虑这个特性。 </p><p>68、任务在挂起队列中是根据优先级分类的。 高优先级任务被</p><p>放置在队列的头部，低优先级任务被放置在队列的尾部。 </p><p>69、任务不是直接链接到挂起队列中， 而是通过叫OS_PEND_DATA 的结构体作为媒介。 这个媒介在任务被挂起时分配到任务堆栈的。挂起队列中的对应指针指向该结构体。</p><p>70、延时函数OSTimeDly()，任务调用这个函数后就会被挂起直到期满。以时基为单位，但需注意，当任务在时基中断将要到来时被挂起，那么实际的延时时基会少 1 个时基。这个函数可以有设置为三种模式：相对延时模式，周期性延时模式，绝对延时模式（用于对时间要求很高的应用）。 </p><p>71、uC/OS-III 定 时 器 的 分 辨 率 决 定 于 时 基 频率。定时器可以被设置为 3 种模式：一次性定时模式， 无初始定时周期模式，有初始定时周期模式 。如果定时器被停止， 那其定时值也将被停止， 直到定时器被恢复时，定时器值继续被递减。不能在定时器的执行代码中等待事件发生。否则定时器任务会被挂起，导致定时器任务崩溃。 </p><p>72、uC/OS-III 可能要维护上百个定时器。 使用定时器列表会大大降低更新定时器列表所占用的 CPU 时间。 定时器列表类似于时基列表，以二维数组的形式存储记录。</p><p>73、uC/OS-III提供关中断方式、锁调度器方式、、信号量方式、mutex方式保护共享资源。只有任务才允许使用信号量，ISR是不允许的。用信号量保护共享资源不会导致中断延迟。当任务在执行信号量所保护的共享资源时，ISR或高优先级任务可以抢占该任务。</p><p>74、信号量经常被过度使用。很多情况下，访问一个简短的共享资源时不推荐使用信号量，请求和释放信号量会消耗CPU时间。通过关/开中断能更有效地执行这些操作。信号量会导致一种严重的问题：优先级反转。</p><p>75、优先级反转是实时系统中的一个常见问题，仅存在于基于优先级的抢占式内核中。uC/OS-III支持一种特殊类型的二值信号量叫做mutex，用于解决优先级反转问题。</p><p>76、死锁，就是两个任务互相等待对方所占用的资源的情况。除一般的防死锁方式外，uC/OS-II还可以在申请信号量或mutex时允许设置其期限，这样能防止死锁，但是同样的死锁可能稍后再次出现。</p><p>77、uC/OS-III中用于同步的两种机制：信号量和事件标志组。两个任务间可以用一个信号量实现单向同步，用两个信号量实现双向同步。当任务要与多个事件同步时可以使用事件标志。若其中的任意一</p><p>个事件发生时任务被就绪，叫做逻辑或(OR)。若所有的事件都发生时任务被就绪，叫做逻辑与（AND）。</p><p>78、有些情况下任务或ISR与另一个任务间进行通信，这种信息交换叫做作业间的通信。可以有两种方法实现这种通信：全局变量、发送消息。需注意的是：任务与ISR通信只能通过全局变量。如果全局变量被ISR改变，任务将不会知道全局变量被改变，除非该任务检测该变量或者ISR标记任务告知该变量被改变。</p><p>79、消息可以被发送到媒介—消息队列中，也可以直接发送给任务，因为uC/OS-III中每个任务都有其内建的消息队列。如果多个任务等待这个消息时建议将该消息发送到外部的消息队列。当只有一个任务等待该消息时建议直接将消息发送给任务。</p><p>80、消息中包含一个指向数据的指针、该数据的大小、时间戳变量。该指针可以指向数据区域甚至是一个函数。当然，消息的发送方和消息的接收方都应该知道消息所包含的意义。</p><p>81、消息队列是先入先出模式（FIFO）。然而，uC/OS-III也可以将其设置为后入先出模式（LIFO）。若任务或ISR发送紧急消息给另一个任务时，后入先出模式是非常有用的，在这种情况下，该紧急消息绕过消息队列中的其他消息。</p><p> 82、任务A发送多个消息给任务B，如果更高优先级的任务抢占了任务B，那么任务A所存放在消息队列中的数据就可能被溢出。解决这个问题的一种方法是在处理中添加流量控制：所有任务在发送消息给任务B之前必须获得信号量。任务B消息队列的空余量为多少，信号量计数值就为多少。</p><p>83、任务可以等待多个内核对象。然而，uC/OS-III只允许任务同时等待多个信号量或消息队列。换句话说，不能同时等待多个事件标志组或mutex。但这将花费uC/OS-III较多时间去处理。</p><p>84、可以通过使用编译器提供的函数malloc()和free()动态地分配和释放内存快。然而，在嵌入式实时系统中使用malloc()和free()可能是非常危险的。因为它可能会导致很多内存碎片。</p><p>85、ucos-iii可以创建多个大小不同的内存分区，一个内存分区可被设置为多个大小相同的任务块，用于存储临时性的数据。根据需求设置，但内存块被分配后必须返回给它所在的内存分区，这种管理方式仅会导致内存块块内的碎片。从而减少了内存碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vivadoHLS（二）</title>
      <link href="/2018/12/09/hls2/"/>
      <url>/2018/12/09/hls2/</url>
      
        <content type="html"><![CDATA[<h1 id="HLS学习"><a href="#HLS学习" class="headerlink" title="HLS学习"></a>HLS学习</h1><p><img src="/2018/12/09/hls2/1539354344835.png" alt="1539354344835"></p><p>上图是HLS完整工作过程，其中Contraints/Directives是在软件里设置的，可以对同一份C语言转电路设计的时候实现全并行或全串行设计等设置。HLS最后生成IP核，可以在Vivado里打开。</p><h2 id="部分HLS-C语言约束（不完全版）"><a href="#部分HLS-C语言约束（不完全版）" class="headerlink" title="部分HLS C语言约束（不完全版）"></a>部分HLS C语言约束（不完全版）</h2><p><strong>HLS C语言体系中不支持的元素</strong></p><p>虽然在HLS中C语言的大部分特性被广泛支持，但是仍存在一部分不可综合的C语言代码。这些代码在向底层的设计转化过程中会产生错误。接下来将讨论HLS中C语言代码设计时的可综合性和在器件中的可执行性。</p><p>可综合的C语言代码具有以下特性：</p><p>1、C语言程序的组成部分全部为函数。</p><p>2、对操作系统层面有需求的函数不能被综合。</p><p>3、C语言构造必须是定长或者有边界的。</p><p>4.C语言构造的设计面对FPGA硬件执行层面是明确的。</p><p><strong>System Calls 系统调用</strong></p><p>系统调用的函数不能被综合的原因在于它们往往会在C语言程序执行的过程中执行基于操作系统层面的任务,而在FPGA底层不存在操作系统。</p><p>Vivado HLS在综合的时候自动忽视掉对算法不产生影响的常用系统调用函数，这些函数不需要在综合之前被移除，例如：</p><p>• abort()  • atexit()  • exit()  • fprintf()  • printf() </p><p>• perror()  • putchar()  • puts()  • time()  • sleep()  • getc()</p><p>不过通常来说，不可综合的代码理应在综合前被移除。可以利用如下的宏，确保不可综合的C代码不会被vivado HLS综合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macro:  __SYNTHESIS__</div></pre></td></tr></table></figure><p>具体例子，参见如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func4.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsub_func</span><span class="params">(<span class="keyword">din_t</span> *in1, <span class="keyword">din_t</span> *in2, <span class="keyword">dint_t</span> *outSum, <span class="keyword">dint_t</span> *outSub)</span></span></div><div class="line">&#123;</div><div class="line">*outSum = *in1 + *in2;</div><div class="line">*outSub = *in1 - *in2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_func</span><span class="params">(<span class="keyword">dint_t</span> *in1, <span class="keyword">dint_t</span> *in2, <span class="keyword">dout_t</span> *outA, <span class="keyword">dout_t</span> *outB)</span></span></div><div class="line">&#123;</div><div class="line">*outA = *in1 &gt;&gt; <span class="number">1</span>;</div><div class="line">*outB = *in2 &gt;&gt; <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func4</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">dint_t</span> apb, amb;</div><div class="line">sumsub_func(&amp;A,&amp;B,&amp;apb,&amp;amb);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYNTHESIS__</span></div><div class="line">FILE *fp1;<span class="comment">// The following code is ignored for synthesis</span></div><div class="line"><span class="keyword">char</span> filename[<span class="number">255</span>];</div><div class="line"><span class="built_in">sprintf</span>(filename,Out_apb_%<span class="number">03</span>d.dat,apb);</div><div class="line">fp1=fopen(filename,w);</div><div class="line"><span class="built_in">fprintf</span>(fp1, %d \n, apb);</div><div class="line">fclose(fp1);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">shift_func(&amp;apb,&amp;amb,C,D);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>值得注意的是</strong>：上述的宏仅作用于被综合的C代码，不适用于 test bench。因为这个宏不遵循C仿真和C/RTL仿真的规则。</p><p><strong>Dynamic Memory Usage 动态内存使用</strong></p><p>调用内存分配管理函数都是基于系统层面的，例如malloc(),alloc(),和free()函数都是在程序运行过程中利用操作系统内存的资源去创建和释放存储空间。为了可被综合，在硬件执行的设计上必须脱离操作系统支持，并且明确资源需求。</p><p>内存分配的系统调用代码必须在综合之前被移除。因为动态内存操作在设计流程中属于特有功能点，它们必须被转化为等价的有边界构造。接下来的例程将会展示如何设计一段可被综合的malloc()代码，顺带重点提示一下两点十分有用的代码设计技巧：</p><p>1.例程设计没有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__SYNTHESIS__    这个宏</div></pre></td></tr></table></figure><p>用户自定义宏NO_SYNTH用于选择可综合和不可综合代码版本。这样子就可以用同样的代码进行C仿真和Vivado HLS综合。</p><p>2.原本设计中用于malloc()函数的指针不用修改就可以指向有定长的数据结构。</p><p>有定长的数据结构可以被创建，现存的指针用于指向新的数据结构即可。这个技巧可以避免人为地对代码进行大篇幅改动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"malloc_removed.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="comment">//#define NO_SYNTH</span></div><div class="line"><span class="keyword">dout_t</span> malloc_removed(<span class="keyword">din_t</span> din[N], <span class="keyword">dsel_t</span> width) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_SYNTH</span></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> *out_accum = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</div><div class="line"><span class="keyword">int</span>* array_local = <span class="built_in">malloc</span> (<span class="number">64</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> _out_accum;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> *out_accum = &amp;_out_accum;</div><div class="line"><span class="keyword">int</span> _array_local[<span class="number">64</span>];</div><div class="line"><span class="keyword">int</span>* array_local = &amp;_array_local[<span class="number">0</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="keyword">int</span> i,j;</div><div class="line">LOOP_SHIFT:<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>; i++) &#123;</div><div class="line"><span class="keyword">if</span> (i&lt;width)</div><div class="line">*(array_local+i)=din[i];</div><div class="line"><span class="keyword">else</span></div><div class="line">*(array_local+i)=din[i]&gt;&gt;<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">*out_accum=<span class="number">0</span>;</div><div class="line">LOOP_ACCUM:<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>; j++) &#123;</div><div class="line">*out_accum += *(array_local+j);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> *out_accum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Pointer Limitations 指针限制</strong></p><p><strong><em>General Pointer Casting常规指针类型转换</em></strong>  </p><p>Vivado HLS 不支持常规意义上的指针类型转化。例如，当一个结构体被初始化，且其中的成员变量被定义为有符号数据类型时，结构体指针不能被转换为无符号数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line"><span class="keyword">short</span> first;</div><div class="line"><span class="keyword">short</span> second;</div><div class="line">&#125; pair;</div><div class="line"><span class="comment">// Not supported for synthesis</span></div><div class="line">*(<span class="keyword">unsigned</span>*)pair = <span class="number">-1</span>U;</div></pre></td></tr></table></figure><p>在这种情况下，结构体指针只能用原定义数据类型。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line"><span class="keyword">short</span> first;</div><div class="line"><span class="keyword">short</span> second;</div><div class="line">&#125; pair;</div><div class="line"><span class="comment">// Assigned value</span></div><div class="line">pair.first = <span class="number">-1</span>U;</div><div class="line">pair.second = <span class="number">-1</span>U;</div></pre></td></tr></table></figure><p>指针数组也能被综合，见下面例程：此例程中的指针数组用于存储一个全局数组第二维度的起始地址。指针数组的指针只能指向标量或标量数组，而不能指向其他指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pointer_array.h"</span></span></div><div class="line"><span class="keyword">data_t</span> A[N][<span class="number">10</span>];</div><div class="line"><span class="keyword">data_t</span> pointer_array(<span class="keyword">data_t</span> B[N*<span class="number">10</span>]) &#123;</div><div class="line"><span class="keyword">data_t</span> i,j;</div><div class="line"><span class="keyword">data_t</span> sum1;</div><div class="line"><span class="comment">// Array of pointers</span></div><div class="line"><span class="keyword">data_t</span>* PtrA[N];</div><div class="line"><span class="comment">// Store global array locations in temp pointer array</span></div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line">PtrA[i] = &amp;(A[i][<span class="number">0</span>]);</div><div class="line"><span class="comment">// Copy input array using pointers</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10</span>; ++j)</div><div class="line">*(PtrA[i]+j) = B[i*<span class="number">10</span> + j];</div><div class="line"><span class="comment">// Sum input array</span></div><div class="line">sum1 = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10</span>; ++j)</div><div class="line">sum1 += *(PtrA[i] + j);</div><div class="line"><span class="keyword">return</span> sum1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Recursive Functions递归函数</strong></p><p>无穷递归的递归函数不可被综合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">foo</span> <span class="params">(<span class="keyword">unsigned</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> (foo(n<span class="number">-2</span>) + foo(n<span class="number">-1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Vivado HLS不支持对数值进行无尽调用的尾递归函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">foo</span> <span class="params">(<span class="keyword">unsigned</span> m, <span class="keyword">unsigned</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</div><div class="line"><span class="keyword">return</span> foo(n, m%n);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>C Test Bench C测试台</strong></p><p>任何模块综合的第一步都是验证C函数的功能是否正确。这个步骤由测试台完成。设计一个好的测试台代码能极大程度上增加你的效率。</p><p>C函数执行比RTL仿真快。在综合之前使用C语言去开发和验证算法比开发RTL级代码更有效率。</p><p>Vivado HLS 重复利用C测试台去验证RTL设计。在使用Vivado HLS时不需要设计任何RTL测试台代码。如果测试台验证过了顶层函数的结果，RTL仿真也会同时通过验证。  </p><p><strong>注意：</strong>为测试台代码提供参数的时候，选择 Project &gt; Project Settings,点击Simulation ,使用Input Arguments 选项。Test Bench文件不支持交互式用户输入。Vivado HLS图形界面没有命令行控制台，也不支持在测试台程序执行的过程中接收用户输入。</p><p>Xilinx建议在综合的时候从测试台文件中将顶层函数分离出来，可以使用头文件。接下来的例程中hier_func函数对两个子函数进行调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsub_func</span><span class="params">(<span class="keyword">din_t</span> *in1, <span class="keyword">din_t</span> *in2, <span class="keyword">dint_t</span> *outSum, <span class="keyword">dint_t</span> *outSub)</span></span></div><div class="line">&#123;</div><div class="line">*outSum = *in1 + *in2;</div><div class="line">*outSub = *in1 - *in2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_func</span><span class="params">(<span class="keyword">dint_t</span> *in1, <span class="keyword">dint_t</span> *in2, <span class="keyword">dout_t</span> *outA, <span class="keyword">dout_t</span> *outB)</span></span></div><div class="line">&#123;</div><div class="line">*outA = *in1 &gt;&gt; <span class="number">1</span>;</div><div class="line">*outB = *in2 &gt;&gt; <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">dint_t</span> apb, amb;</div><div class="line">sumsub_func(&amp;A,&amp;B,&amp;apb,&amp;amb);</div><div class="line">shift_func(&amp;apb,&amp;amb,C,D);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顶层函数可以包含多个子函数。只能有一个顶层函数被综合。为了综合多个函数，可以把这些函数都放在一个顶层函数里调用。</p><p>为了综合hier_func这个函数：</p><p>1.添加上述例程到Vivado HLS工程里作为设计文件。</p><p>2.声明hier_func为顶层函数。</p><p>综合之后：</p><p>• 传递给顶层函数的参数被综合为RTL引脚。</p><p>• 顶层函数里包含的子函数被综合成分层次的模块。</p><p>下述头文件为上述例程的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HIER_FUNC_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _HIER_FUNC_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_TRANS 40</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">din_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">dint_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">dout_t</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hier_func</span><span class="params">(<span class="keyword">din_t</span> A, <span class="keyword">din_t</span> B, <span class="keyword">dout_t</span> *C, <span class="keyword">dout_t</span> *D)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>这个头文件包含了很多原设计文件里面没有的定义（比如NUM_TRANS）。这些定义是用于测试台文件，测试台文件同样包含这个头文件。</p><p>下述代码是这个工程里的测试台文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hier_func.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// Data storage</span></div><div class="line"><span class="keyword">int</span> a[NUM_TRANS], b[NUM_TRANS];</div><div class="line"><span class="keyword">int</span> c_expected[NUM_TRANS], d_expected[NUM_TRANS];</div><div class="line"><span class="keyword">int</span> c[NUM_TRANS], d[NUM_TRANS];</div><div class="line"><span class="comment">//Function data (to/from function)</span></div><div class="line"><span class="keyword">int</span> a_actual, b_actual;</div><div class="line"><span class="keyword">int</span> c_actual, d_actual;</div><div class="line"><span class="comment">// Misc</span></div><div class="line"><span class="keyword">int</span> retval=<span class="number">0</span>, i, i_trans, tmp;</div><div class="line">FILE *fp;</div><div class="line"><span class="comment">// Load input data from files</span></div><div class="line">fp=fopen(tb_data/inA.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">a[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line">fp=fopen(tb_data/inB.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">b[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line"><span class="comment">// Execute the function multiple times (multiple transactions)</span></div><div class="line"><span class="keyword">for</span>(i_trans=<span class="number">0</span>; i_trans&lt;NUM_TRANS<span class="number">-1</span>; i_trans++)&#123;</div><div class="line"><span class="comment">//Apply next data values</span></div><div class="line">a_actual = a[i_trans];</div><div class="line">b_actual = b[i_trans];</div><div class="line">hier_func(a_actual, b_actual, &amp;c_actual, &amp;d_actual);</div><div class="line"><span class="comment">//Store outputs</span></div><div class="line">c[i_trans] = c_actual;</div><div class="line">d[i_trans] = d_actual;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Load expected output data from files</span></div><div class="line">fp=fopen(tb_data/outC.golden.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">c_expected[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line">fp=fopen(tb_data/outD.golden.dat,r);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TRANS; i++)&#123;</div><div class="line"><span class="built_in">fscanf</span>(fp, %d, &amp;tmp);</div><div class="line">d_expected[i] = tmp;</div><div class="line">&#125;</div><div class="line">fclose(fp);</div><div class="line"><span class="comment">// Check outputs against expected</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_TRANS<span class="number">-1</span>; ++i) &#123;</div><div class="line"><span class="keyword">if</span>(c[i] != c_expected[i])&#123;</div><div class="line">retval = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(d[i] != d_expected[i])&#123;</div><div class="line">retval = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Print Results</span></div><div class="line"><span class="keyword">if</span>(retval == <span class="number">0</span>)&#123;</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line"><span class="built_in">printf</span>( Results are good \n);</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line"><span class="built_in">printf</span>( Mismatch: retval=%d \n, retval);</div><div class="line"><span class="built_in">printf</span>( *** *** *** *** \n);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Return 0 if outputs are correct</span></div><div class="line"><span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="池化和卷积HLS-C语言代码"><a href="#池化和卷积HLS-C语言代码" class="headerlink" title="池化和卷积HLS C语言代码"></a>池化和卷积HLS C语言代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//池化代码main函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pool_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE 0<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_WIDTH 6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_HEIGHT 6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_CH 1</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_WIDTH 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_HEIGHT 3</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_WIDTH (IN_WIDTH/KERNEL_WIDTH)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_HEIGHT (IN_HEIGHT/KERNEL_HEIGHT)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">Dtype_f feature_in[IN_HEIGHT][IN_WIDTH][IN_CH];</div><div class="line">Dtype_f feature_out[OUT_HEIGHT][OUT_WIDTH][IN_CH];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;IN_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;IN_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line">feature_in[i][j][<span class="built_in">cin</span>]=i*IN_WIDTH+j;</div><div class="line"></div><div class="line">Pool(IN_CH,IN_HEIGHT,IN_WIDTH,</div><div class="line">KERNEL_WIDTH,KERNEL_HEIGHT,MODE,</div><div class="line">feature_in[<span class="number">0</span>][<span class="number">0</span>],feature_out[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">);<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;OUT_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;OUT_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;IN_CH;<span class="built_in">cout</span>++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OUT[%d][%d][%d]=%f\n"</span>,i,j,<span class="built_in">cout</span>,feature_out[i][j][<span class="built_in">cout</span>]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//池化代码池化函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pool_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a&gt;b)?a:b)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a&gt;b)?b:a)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pool</span><span class="params">(ap_uint&lt;<span class="number">16</span>&gt; CHin,ap_uint&lt;<span class="number">16</span>&gt; Hin,ap_uint&lt;<span class="number">16</span>&gt; Win,</span></span></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; Kx,ap_uint&lt;<span class="number">8</span>&gt; Ky,ap_uint&lt;<span class="number">2</span>&gt; mode,</div><div class="line">Dtype_f feature_in[],Dtype_f feature_out[]</div><div class="line">)<span class="comment">//mode: 0:MEAN, 1:MIN, 2:MAX</span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_out offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_in offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Win</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Kx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Hin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=mode</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Ky</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=return</span></div><div class="line">ap_uint&lt;<span class="number">16</span>&gt; Hout,Wout;</div><div class="line">Wout=Win/Kx;</div><div class="line">Hout=Hin/Ky;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;CHin;c++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hout;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Wout;j++)</div><div class="line">&#123;</div><div class="line">Dtype_f sum;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)</div><div class="line">sum=<span class="number">99999999999999999</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">sum=<span class="number">-99999999999999999</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;Ky;ii++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;Kx;jj++)</div><div class="line">&#123;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; h=i*Ky+ii;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; w=j*Kx+jj;</div><div class="line"><span class="keyword">switch</span>(mode)</div><div class="line">&#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;sum+=feature_in[h*CHin*Win+w*CHin+c];<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;sum=min(sum,feature_in[h*CHin*Win+w*CHin+c]);<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;sum=max(sum,feature_in[h*CHin*Win+w*CHin+c]);<span class="keyword">break</span>;&#125;</div><div class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">sum=sum/(Kx*Ky);</div><div class="line">feature_out[i*Wout*CHin+j*CHin+c]=sum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//卷积代码main函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conv_core.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_WIDTH 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_HEIGHT 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_CH 16</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_WIDTH 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_HEIGHT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> X_STRIDE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_STRIDE 1</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RELU_EN  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE     0          <span class="comment">//0:VALID, 1:SAME</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> X_PADDING (MODE?(KERNEL_WIDTH-1)/2:0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_PADDING (MODE?(KERNEL_HEIGHT-1)/2:0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_CH 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_WIDTH ((IN_WIDTH+2*X_PADDING-KERNEL_WIDTH)/X_STRIDE+1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_HEIGHT ((IN_HEIGHT+2*Y_PADDING-KERNEL_HEIGHT)/Y_STRIDE+1)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">Dtype_f feature_in[IN_HEIGHT][IN_WIDTH][IN_CH];</div><div class="line">Dtype_w W[KERNEL_HEIGHT][KERNEL_WIDTH][IN_CH][OUT_CH];</div><div class="line">Dtype_w bias[OUT_CH];</div><div class="line">Dtype_f feature_out[OUT_HEIGHT][OUT_WIDTH][OUT_CH];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;IN_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;IN_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line">feature_in[i][j][<span class="built_in">cin</span>]=i*IN_WIDTH+j;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;KERNEL_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;KERNEL_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;IN_CH;<span class="built_in">cin</span>++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">W[i][j][<span class="built_in">cin</span>][<span class="built_in">cout</span>]=i*KERNEL_WIDTH+j;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">bias[<span class="built_in">cout</span>]=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"1234\n"</span>);</div><div class="line"></div><div class="line">Conv(IN_CH,IN_HEIGHT,IN_WIDTH,OUT_CH,</div><div class="line">KERNEL_WIDTH,KERNEL_HEIGHT,X_STRIDE,Y_STRIDE,MODE,RELU_EN,</div><div class="line">feature_in[<span class="number">0</span>][<span class="number">0</span>],W[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>],bias,feature_out[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;OUT_HEIGHT;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;OUT_WIDTH;j++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;OUT_CH;<span class="built_in">cout</span>++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OUT[%d][%d][%d]=%f\n"</span>,i,j,<span class="built_in">cout</span>,feature_out[i][j][<span class="built_in">cout</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//卷积代码卷积函数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conv_core.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//Feature: [H][W][C]</span></div><div class="line"><span class="comment">//kernel: [Ky][Kx][CHin][CHout]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conv</span><span class="params">(ap_uint&lt;<span class="number">16</span>&gt; CHin,ap_uint&lt;<span class="number">16</span>&gt; Hin,ap_uint&lt;<span class="number">16</span>&gt; Win,ap_uint&lt;<span class="number">16</span>&gt; CHout,</span></span></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; Kx,ap_uint&lt;<span class="number">8</span>&gt; Ky,ap_uint&lt;<span class="number">8</span>&gt; Sx,ap_uint&lt;<span class="number">8</span>&gt; Sy,ap_uint&lt;<span class="number">1</span>&gt; mode,ap_uint&lt;<span class="number">1</span>&gt; relu_en,</div><div class="line">Dtype_f feature_in[],Dtype_w W[],Dtype_w bias[],Dtype_f feature_out[]</div><div class="line">)<span class="comment">//mode: 0:VALID, 1:SAME</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//#pragma HLS PIPELINE enable_flush</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_out offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=bias offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=W offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE m_axi depth=4294967295 port=feature_in offset=slave</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=relu_en</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHout</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Sx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Hin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=CHin</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Kx</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=mode</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Sy</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Ky</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=Win</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> HLS INTERFACE s_axilite port=return</span></div><div class="line"></div><div class="line">ap_uint&lt;<span class="number">8</span>&gt; pad_x,pad_y;</div><div class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">pad_x=<span class="number">0</span>;pad_y=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">pad_x=(Kx<span class="number">-1</span>)/<span class="number">2</span>;pad_y=(Ky<span class="number">-1</span>)/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">ap_uint&lt;<span class="number">16</span>&gt; Hout,Wout;</div><div class="line">Wout=(Win+<span class="number">2</span>*pad_x-Kx)/Sx+<span class="number">1</span>;</div><div class="line">Hout=(Hin+<span class="number">2</span>*pad_y-Ky)/Sy+<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span>=<span class="number">0</span>;<span class="built_in">cout</span>&lt;CHout;<span class="built_in">cout</span>++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hout;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Wout;j++)</div><div class="line">&#123;</div><div class="line">Dtype_acc sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;Ky;ii++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;Kx;jj++)</div><div class="line">&#123;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; h=i*Sy-pad_y+ii;</div><div class="line">ap_int&lt;<span class="number">16</span>&gt; w=j*Sx-pad_x+jj;</div><div class="line"><span class="keyword">if</span>(h&gt;=<span class="number">0</span> &amp;&amp; w&gt;=<span class="number">0</span> &amp;&amp; h&lt;Hin &amp;&amp; w&lt;Win)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cin</span>=<span class="number">0</span>;<span class="built_in">cin</span>&lt;CHin;<span class="built_in">cin</span>++)</div><div class="line">&#123;</div><div class="line"><span class="comment">//Feature [H][W][C]</span></div><div class="line"><span class="comment">//kernel: [Ky][Kx][CHin][CHout]</span></div><div class="line"><span class="comment">//Dtype_mul tp=feature_in[h][w][cin]*w[ii][jj][cin][cout];</span></div><div class="line"><span class="comment">//std::cout&lt;&lt;"h:"&lt;&lt;h&lt;&lt;",w"&lt;&lt;w&lt;&lt;",cin"&lt;&lt;cin&lt;&lt;"\n";</span></div><div class="line"><span class="comment">//std::cout&lt;&lt;"feature_in["&lt;&lt;h*CHin*Win+w*CHin+cin&lt;&lt;"]*W["&lt;&lt;ii*Kx*CHin*CHout+jj*CHin*CHout+cin*CHout+cout&lt;&lt;"]\n";</span></div><div class="line">Dtype_mul tp=feature_in[h*CHin*Win+w*CHin+<span class="built_in">cin</span>]*W[ii*Kx*CHin*CHout+jj*CHin*CHout+<span class="built_in">cin</span>*CHout+<span class="built_in">cout</span>];</div><div class="line">sum+=tp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sum+=bias[<span class="built_in">cout</span>];</div><div class="line"><span class="keyword">if</span>(relu_en &amp; sum&lt;<span class="number">0</span>)</div><div class="line">sum=<span class="number">0</span>;</div><div class="line"><span class="comment">//feature_out[i][j][cout]=sum;</span></div><div class="line">feature_out[i*Wout*CHout+j*CHout+<span class="built_in">cout</span>]=sum;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VivadoHLS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>四旋翼PID调参笔记</title>
      <link href="/2018/10/30/%E5%9B%9B%E6%97%8B%E7%BF%BCPID%E8%B0%83%E5%8F%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/30/%E5%9B%9B%E6%97%8B%E7%BF%BCPID%E8%B0%83%E5%8F%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="飞行器PID整定学习"><a href="#飞行器PID整定学习" class="headerlink" title="飞行器PID整定学习"></a>飞行器PID整定学习</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>以下仅为学习笔记整理，资料整理自 <a href="http://www.yanjuntech.cn/" target="_blank" rel="external">http://www.yanjuntech.cn/</a> 以及 <a href="http://blog.sina.com.cn/antinformation" target="_blank" rel="external">http://blog.sina.com.cn/antinformation</a></p><h2 id="一、PID控制器的简介"><a href="#一、PID控制器的简介" class="headerlink" title="一、PID控制器的简介"></a>一、PID控制器的简介</h2><p>目前工业自动化水平已经成为衡量各行各业现代化水平的一个重要标志。同时控制理论的发展也经历了古典控制理论-现代控制理论-智能控制理论三个阶段。自动控制系统可分为开环控制系统和闭环控制系统。整个控制系统包括：控制器（CPU）、传感器、输入输出接口、执行机构等部分组成。</p><p>工业生产过程中，对于生产装置的温度、压力、流量、液位等工艺变量常常要求维持在恒定的数值上，或按一定的规律变化，以满足生产工艺的要求。PID控制器是根据PID控制原理对整个控制系统进行偏差调节，从而使被控变量的实际值与工艺要求的给定值一致。</p><p>而PID的是英文Proportion（比例）-Integral（积分）-Differential（微分）的英文首字母，其中文名称是：比例-积分-微分控制器。</p><p>PID 可谓是相当经典的一种控制策略，据我所知目前涉及到自动控制的很多场景都在使用 PID 控制器。（也有其他高级控制器，比如自抗扰ADRC控制算法）PID控制器的问世至今已有70年历史，它以结构简单、稳定性好、工作可靠、调整方便而成为工业控制的主要技术之一。而当被控对象的结构和参数不能完全掌握，或者说得不到精确的数学模型的时候，控制理论的其他技术将难以采用，系统控制器的结构和参数必须依靠经验和现场调试来确定时，PID控制技术可能是比较理想的控制方案。也就是说当我们不了解一个系统和被控制对象，或者不能通过有效的手段来获得系统参数时，最适用使用PID控制技术。PID控制技术根据实际需要还可以分为P控制PI控制PD控制以及其他的优化变形。PID控制器其实就是根据系统的偏差，利用比例环节、积分环节、微分环节计算出控制量进行控制的。</p><p>PID控制器的算法实现不是难点，难点是 PID参数的整定调试。一般工程人员采用的都是经验法调试，如果经验不足则可能很难找到合适的参数。本文我们将使用微型四轴以及自平衡小车为PID调试载体，带大家了解PID的参数整定过程。</p><h2 id="二、PID相关名词解释"><a href="#二、PID相关名词解释" class="headerlink" title="二、PID相关名词解释"></a>二、PID相关名词解释</h2><p>首先给大家解释一下相关的名词，我们下面会用到这些东西。</p><p><strong>1.PID</strong></p><p>PID的是英文Proportion（比例）-Integral（积分）-Differential（微分）的英文首字母，其中文名称是：比例-积分-微分控制器。</p><p><strong>2.被控对象</strong></p><p>在本篇文章中的控制对象就是微型四轴和我们的自平衡小车。我们将在第5部分和第六部分带着大家整定微型四轴和自平衡小车的PID参数。</p><p><strong>3.开环系统</strong></p><p>开环系统指的是被控对象的输出（被控制量）对控制器的输出没有影响， 在这种控制系统中，没有形成闭环回路。本次输出量没有进行反馈，不影响下次输出量。</p><p><strong>4.闭环系统</strong></p><p>闭环系统的特点是系统被控对象的输出（被控制量），会通过反馈通道返送回来影响控制器的输出，形成一个或者多个闭环系统（单环就是一个闭环，串级一般就是指两个闭环。而我们的微型四轴和自平衡小车使用的均是串级双环PID，其内环为角速度环，其外环为角度环）。闭环控制系统有正反馈和负反馈，如果反馈回来的信号数值符号与给定的信号相反，则称为负反馈。如果极性相同就称为正反馈，一般的闭环控制系统使用的都是负反馈。闭环控制系统用处特别特别的多，其不仅仅局限在技术领域，非技术领域比如一个团队的管理，一个公司的组织运营等等都离不开闭环系统。</p><p><strong>5.阶跃信号</strong></p><p>如下图，在t0时刻突然给一个信号，让其稳定在另一个值，这就是阶跃信号。信号从0变到1然后稳定为1，我们就称这个信号为单位阶跃信号。而当这个阶跃信号输入到一个系统中，我们会得到相应的输出而这个输出我们就称之为阶跃响应。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID2.jpg" alt="img"></p><p>图2.1 阶跃信号</p><p><strong>6.期望值</strong></p><p>期望值又称为给定值，或者说是目标值。在我们的四轴中期望值就是遥控器给定的值，我们四轴中遥控器的给定值就是目标角度和目标角速度。我们自平衡小车中的给定值也是给定的目标角度和目标角速度。与其对应的就是我们的传感器测量得出的实际值。</p><p><strong>7.偏差</strong></p><p>上述说到的目标值减去实际值就是我们的偏差值。</p><p><strong>8.系统中的稳态误差</strong></p><p>&amp;emsp&amp;emsp系统的稳态误差，我们平常又称之为静差。稳态误差指的是系统的响应进入问题后，系统的期望输出与实际输出之差。比如说我们的期望输出是1，但是输入信号经过了系统之后稳定下来的输出是0.9左右，这里的0.9就是实际值，而1就是期望的目标值。图2.2中，这三条响应曲线稳定后的输出均没有达到期望值，图上从5s之后的，期望值减去实际值就是系统的稳态误差又称静差。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID3.jpg" alt="img"></p><p>图2.2 稳态误差示意图</p><p><strong>9.控制系统的性能</strong></p><p>&amp;emsp&amp;emsp控制系统的性能可以用稳、准、快三个字来描述。稳指的是系统的稳定性，一个系统要能正常工作首要条件就是必须是稳定的。从阶跃响应来看应该是收敛的。准指的是系统的准确性，控制系统的精确度，通常我们使用稳态误差来描述，稳态误差越小其精确度越高也就是我们说的比较准确。快指的是控制系统响应的快速性，通常用上升时间来定量描述，下面这个图3种参数下的系统性能。</p><p>我们在进行PID参数整定的目的其实就是为了调节系统的稳、准、快这三个特性。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID4.jpg" alt="img"></p><p>图2.3不同参数下的系统性能</p><p>红线：</p><p>​    从图上，我们可以看出红线的超调比较大也就是稳定性最差，但是响应速度最快，稳态误差也很小。所以总结一下就是红线稳定性比较差，快速性很好，稳定性也很好。</p><p>紫线：</p><p>​    快速性还不错，就是稳态误差很大说明其准确性不好，其超调不大说明稳定性还不错。</p><p>绿线：</p><p>​    快速性最差，稳定性比较好，准确性也比较好。</p><p><strong>10.上升时间</strong></p><p>这里我们直接认为是 从一开始0% 到第一次达到目标值的时间100%。</p><h2 id="三、PID的理论基础"><a href="#三、PID的理论基础" class="headerlink" title="三、PID的理论基础"></a>三、PID的理论基础</h2><p>连续-时间PID控制系统如图3-1所示。图中D(s)为控制器，在PID控制系统中，D(s)完成PID控制规律，称之为PID控制器。PID控制器是一种线性控制器，PID控制器是偏差的时间函数。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID5.png" alt="img"></p><p>图3.1连续-时间PID控制系统</p><p>图3.1中的比例（Proportion）、积分（Integrate）、微分（Differentiation）的线性组合，构成控制量u(t),称为比例-积分-微分控制，简称PID控制。实际应用中，可以根据受控对象的特性和控制的性能要求，灵活的采用不同的控制组合。比如：</p><p>比例（P）控制器</p><p>​    u(t) = Kp e(t)        (公式-1)</p><p>比例+积分（PI）控制器</p><p>比例+积分+微分（PID）控制器</p><p>当然我们平常控制电机的时候也经常使用PD控制器，这里就不给大家列公式了。</p><p>​    上述公式是连续时间的函数，而我们的单片机运行程序实际上都是离散化的。我们在微型四轴和自平衡小车中调用PID函数调用周期就是2ms调用一次，也就是2ms离散化采样运算。</p><h2 id="四、数字PID算法"><a href="#四、数字PID算法" class="headerlink" title="四、数字PID算法"></a>四、数字PID算法</h2><p>在数字计算机直接数字控制中，PID控制器是通过计算机或者单片机实现的。计算机直接数字控制系统大多数都是采样-数据控制系统。进入计算机的连续-时间信号，必须经过采样和量化处理后，编程数质量，才能进入计算机的存储器和寄存器，而在数字计算机中的计算和处理，不论是积分还是微分，智能用数值计算去逼近。</p><p>在数字计算机中，PID控制规律的实现，也必须用数值逼近的方法。当采样周期相当短的时候，可以用求和代替积分，用差商代替微分，使PID算法离散化，将描述连续-时间PID算法的微分方程，变为描述离散-时间PID算法的差分方程。</p><p>A、位置式PID控制算法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID6.png" alt="img"></p><p>图4.1位置式PID控制算法的简化示意图</p><p>上式中我们使用替换法，用矩形积分时有：</p><p>​    如下图4.2所示，上式中就是矩形面积之和，得到的值近似于下图所示图形的面积。同时我们能知道只要Ts足够小，那么我们得到的近似值就越精确这就是积分的思想。</p><p>​    我们知道，微分实际上就是斜率，用差分代替微分有：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID7.jpg" alt="img"></p><p>图 4.2 矩形积分示意图</p><p>将上述积分和微分的代换公式代入PID控制器的全公式有：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID8.png" alt="img"></p><p>图4.3离散化PID公式1</p><p>或者写成如下形式：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID9.png" alt="img"></p><p>图4.4离散化PID公式2</p><p>式中u0—控制系统的控制量基准值，既k0时刻的控制量</p><p>u(k)    —— 第k时刻的控制量</p><p>Kp    —— 比例系数</p><p>Ki    —— 积分系数</p><p>Kd    —— 微分系数</p><p>Ts    —— 采样周期</p><p>​    上式中是数字位置式PID形式，称为全量算法。算法中为了积分求和，我们需要在程序中设置一个变量将系统过去的所有偏差都加起来。这种控制算法得出的控制量是全量输出u(k),是控制量的绝对数值。在控制系统中，这种控制量确定了执行机构的位置例如阀门控制中，这种算法的输出对应的就是阀门开关的位置角度。所以我们称这种算法为”位置式PID”</p><p>B、增量式PID控制算法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID10.png" alt="img"></p><p>图4.5增量式PID控制算法的简化示意图</p><p>​    由位置式算法可以求出u(k)：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID11.png" alt="img"></p><p>​    我们接下来再求出u(k-1)</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID12.png" alt="img"></p><p>两式相减，得到控制量的增量算法：</p><p>代入并化简合并得：</p><p>从上式可以看出，上式已经看不出P、I、D左右的直接关系。我们只要储存最近的三个误差采样值e(k)、e(k-1)、e(k-2)就够了</p><h2 id="五、改进的PID控制器"><a href="#五、改进的PID控制器" class="headerlink" title="五、改进的PID控制器"></a>五、改进的PID控制器</h2><p>在实际的应用中，基本的PID控制器往往效果不够完美。我们需要使用改进型的PID控制器，下面将给大家介绍几种实用的PID控制器的变形。这里我们YJ团队常用的就是位置式PID控制器</p><p><strong>A、PID输出饱和限幅</strong></p><p>实际的系统中，存在着饱和特性。当输入量达到一定值之后，控制系统的输出将不再增长，系统进入饱和区。这就要求控制系统的输出必须在谋和范围之内，也就是：</p><p>Umin &lt; U &lt; Umax</p><p>在程序中，在最后输出时使用if-else判断即可实现上述的PID输出饱和限幅。代码如下：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID13.png" alt="img"></p><p>图4.6 PID输出饱和限幅</p><p><strong>B、积分饱和</strong></p><p>在位置式PID中，”饱和”主要是由积分项过大引起的。这里我们称之为”积分饱和”，通常积分项不应该太大，我们应该限制其值。这里我们使用的是抗饱和积分法：</p><p>当我们的积分项大于最大的积分值的时候，我们的积分项只负责累加负的偏差值。而当我们的积分项小于最小的积分值的时候，我们的积分项只负责累加正的偏差值。从而实现抗饱和积分。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID14.png" alt="img"></p><p>图4.7PID抗饱和积分</p><p><strong>C、积分分离</strong></p><p>在偏差较大的时候不进行积分作用，只有当偏差在一定的范围时才进行积分作用。这里我们采用的就是积分分离的方法。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/E:/FileRecv\hexo\PortableHexo\hexo\source\_posts\四旋翼PID调参笔记\070118_0724_PID15.png" alt="img"></p><p>式中，我们K1就是计算的输出结果是否需要积分的标志位。</p><p>式中就是偏差的阈值。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID16.png" alt="img"></p><p>图4.8积分分离效果图</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID17.png" alt="img"></p><p>4.9积分分离c语言代码1</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID18.png" alt="img"></p><p>图4.10积分分离c语言代码2</p><h2 id="六、PID的c语言实现"><a href="#六、PID的c语言实现" class="headerlink" title="六、PID的c语言实现"></a>六、PID的c语言实现</h2><p>这里我建议大家根据位置式离散化的PID公式读一下下面的代码，很简单的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*                               YanJunFly V1.0 - Copyright (c) 2017</div><div class="line">* All rights reserved.More information please browse www.yanjun.tech</div><div class="line">*                  燕骏智控——以极客技术推进工程教育</div><div class="line">*             手把手教你，如何从头开始做一个电子设计类项目。</div><div class="line">* 我们将以 四轴飞行器 为项目载体，带领大家进行项目式学习,做出属于自己的四旋翼。</div><div class="line">*</div><div class="line">* 文件名称：Pid.c, Pid.h</div><div class="line">* 文件摘要：无</div><div class="line">* 注意事项：无</div><div class="line">*                       </div><div class="line">* 当前版本：v1.0</div><div class="line">* 当前作者：石雄涛</div><div class="line">* 完成日期：2017-3-16 17:45:05</div><div class="line">* 改动说明：创建文件</div><div class="line">*</div><div class="line">* 取代版本：无</div><div class="line">* 原 作 者：石雄涛</div><div class="line">* 完成日期：2017-3-16 17:45:05</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Pid/pid.h"</span></span></div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*函数名称：void vCleanxp_Pid(PID_Typedef * xp_Pid)</div><div class="line">*函数功能：xp_Pid清除函数,把历史的xp_Pid计算值，清零</div><div class="line">*</div><div class="line">*使用说明：无</div><div class="line">*入口参数：xp_Pid:要进行清零的xp_Pid指针</div><div class="line">*返 回 值：无</div><div class="line">*</div><div class="line">*当前作者：石雄涛</div><div class="line">*创建日期：2017-3-16 17:45:12</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCleanPid</span><span class="params">(PID_Typedef * xp_Pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* 清除偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除上一次的偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err_last = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除上上次的偏差值 */</span></div><div class="line">    xp_Pid-&gt;f_err_last_last = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除微分值 */</span></div><div class="line">    xp_Pid-&gt;f_differential = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除积分值 */</span></div><div class="line">    xp_Pid-&gt;f_integral = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除是否需要积分标志位 */</span></div><div class="line">    xp_Pid-&gt;ui_isNeedKi = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 清除PID输出值 */</span></div><div class="line">    xp_Pid-&gt;f_OUT = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line">***********************************************************************</div><div class="line">*函数名称：void vCalculatexp_Pid(PID_Typedef * xp_Pid)</div><div class="line">*函数功能：pid计算函数</div><div class="line">*</div><div class="line">*使用说明：无</div><div class="line">*入口参数：xp_Pid计算函数</div><div class="line">                    在调用这个函数之前 xp_Pid 应该提前准备好</div><div class="line">                    1.偏差值</div><div class="line">                    2.微分值</div><div class="line">                    在这个函数里面不再进行计算，在外面直接计算好</div><div class="line">                    关于xp_Pid参数正负的说明</div><div class="line">                    假如现在偏差值是5，上次偏差值是10，这是调节器在作用，这是真实的情况</div><div class="line">                    假如P参数是+的</div><div class="line">                    那么I参数是+的</div><div class="line">                    那么D参数是-的</div><div class="line">*返 回 值：无</div><div class="line">*</div><div class="line">*当前作者：石雄涛</div><div class="line">*创建日期：2017-3-16 17:45:12</div><div class="line">***********************************************************************</div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCalculatexp_Pid</span><span class="params">(PID_Typedef * xp_Pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* 先来判断是否要使用微分先行 微分先行使用与输入经常性的变动的xp_Pid控制 */</span></div><div class="line">    <span class="keyword">if</span>(xp_Pid-&gt;ui_isUseDifferentialAhead)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 使用微分先行策略 积分分离 抗饱和积分 */</span></div><div class="line">        <span class="comment">/* 暂时还没有实现 微分先行 因为 这块 一直没有用到 */</span></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 不使用微分先行策略 积分分离 抗饱和积分 */</span></div><div class="line">        </div><div class="line">        <span class="comment">/* 如果此时的偏差值太大了，那么取消积分项 */</span></div><div class="line">        <span class="keyword">if</span>(((xp_Pid -&gt;f_err) &gt; (xp_Pid -&gt; f_IntegralSeparation)) || ((xp_Pid -&gt; f_err) &lt; (-(xp_Pid -&gt; f_IntegralSeparation))))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 取消积分项 */</span></div><div class="line">            xp_Pid -&gt; ui_isNeedKi = <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 保留积分项 */</span></div><div class="line">            xp_Pid -&gt; ui_isNeedKi = <span class="number">1</span>;</div><div class="line">           <span class="comment">/*-------------------积分分离和抗饱和积分----------------------------*/</span></div><div class="line">            <span class="comment">/* xp_Pid积分达到最大值，如果xp_Pid的输出大于抗饱和积分的输出了 */</span></div><div class="line">            <span class="keyword">if</span>((xp_Pid -&gt; f_integral) &gt; (xp_Pid -&gt; f_AntiSaturationIntegral))                                                   </div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 抗饱和积分 */</span></div><div class="line">                <span class="keyword">if</span>((xp_Pid -&gt; f_err) &lt; <span class="number">0</span>)                                           </div><div class="line">                &#123;</div><div class="line">                    <span class="comment">/* 只累加负值 */</span></div><div class="line">                    xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                          </div><div class="line">                &#125;</div><div class="line">            <span class="comment">/* xp_Pid积分达到负的最大值，如果xp_Pid的输出大于负的抗饱和积分的输出了 */</span></div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((xp_Pid -&gt; f_integral) &lt; -(xp_Pid -&gt; f_AntiSaturationIntegral))</div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 抗饱和积分 */</span></div><div class="line">                <span class="keyword">if</span>((xp_Pid -&gt; f_err) &gt; <span class="number">0</span>)                                           </div><div class="line">                &#123;</div><div class="line">                    <span class="comment">/* 只累加正值 */</span></div><div class="line">                    xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                          </div><div class="line">                &#125;</div><div class="line">            <span class="comment">/* xp_Pid积分正常，如果xp_Pid的输出正常 */</span></div><div class="line">            &#125;<span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 积分值得大小正常，累加误差积分 */</span></div><div class="line">                xp_Pid -&gt; f_integral += (xp_Pid -&gt; f_err);                              </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/* 计算xp_Pid输出 */</span></div><div class="line">        <span class="keyword">if</span>(xp_Pid -&gt; ui_isNeedKi)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* xp_Pid输出 = 比例*偏差 + 积分*偏差积分 + 微分*偏差微分 */</span></div><div class="line">            xp_Pid -&gt; f_OUT = (((xp_Pid -&gt; f_Kp) * (xp_Pid -&gt; f_err)) + ((xp_Pid -&gt; f_Ki) * (xp_Pid -&gt; f_integral)) + ((xp_Pid -&gt; f_Kd) * (xp_Pid -&gt; f_differential)));</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* xp_Pid输出 = 比例*偏差 + 微分*偏差微分 */</span></div><div class="line">            xp_Pid -&gt; f_OUT = (((xp_Pid -&gt; f_Kp) * (xp_Pid -&gt; f_err)) + ((xp_Pid -&gt; f_Kd) * (xp_Pid -&gt; f_differential)));                                   </div><div class="line">        &#125;   </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/* xp_Pid输出限幅 */</span></div><div class="line">    <span class="keyword">if</span>(xp_Pid-&gt;ui_isNeedLimitPidOut)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/* 判断PID输出和正负限幅值之间的关系 */</span></div><div class="line">        <span class="keyword">if</span>((xp_Pid-&gt;f_OUT) &gt; (xp_Pid-&gt;f_pidOutLimitPlus)) </div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果大于正限幅值 就让PID输出值是正限幅值 */</span></div><div class="line">            xp_Pid-&gt;f_OUT = xp_Pid-&gt;f_pidOutLimitPlus;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((xp_Pid-&gt;f_OUT) &lt; (xp_Pid-&gt;f_pidOutLimitMinus))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果小于负限幅值 就让PID输出值是负限幅值 */</span></div><div class="line">            xp_Pid-&gt;f_OUT = (xp_Pid-&gt;f_pidOutLimitMinus);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* end of file cppyright reserve by team of yanjun ,More information please browse www.yanjun.tech */</span></div></pre></td></tr></table></figure><p>头文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PID_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _PID_H</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Sys/system.h"</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Kp;                                                   <span class="comment">//比例系数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Ki;                                                   <span class="comment">//积分系数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_Kd;                                                   <span class="comment">//微分系数</span></div><div class="line">    <span class="keyword">float</span> f_integral;                                                   <span class="comment">//积分值</span></div><div class="line">    <span class="keyword">float</span> f_err;                                                                <span class="comment">//本次偏差</span></div><div class="line">    <span class="keyword">float</span> f_err_last;                                                       <span class="comment">//上次偏差</span></div><div class="line">    <span class="keyword">float</span> f_err_last_last;                                          <span class="comment">//上上次偏差</span></div><div class="line">    <span class="keyword">uint32_t</span> ui_isNeedKi;                                               <span class="comment">//是否需要积分，用于积分分离</span></div><div class="line">    <span class="keyword">float</span> f_differential;                                               <span class="comment">//本次微分值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_IntegralSeparation;                       <span class="comment">//积分分离阈值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_AntiSaturationIntegral;               <span class="comment">//抗饱和积分阈值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> ui_isUseDifferentialAhead;       <span class="comment">//是否使用微分先行的PID策略</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> ui_isNeedLimitPidOut;                    <span class="comment">//是否需要限制PID输出幅度</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_pidOutLimitPlus;                          <span class="comment">//PID正限幅值</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f_pidOutLimitMinus;                         <span class="comment">//PID负限幅值</span></div><div class="line">    <span class="keyword">float</span>   f_OUT;                                                              <span class="comment">//PID输出</span></div><div class="line">&#125;PID_Typedef;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCleanPid</span><span class="params">(PID_Typedef * xp_Pid)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vCalculatexp_Pid</span><span class="params">(PID_Typedef * xp_Pid)</span></span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="comment">/* end of file cppyright reserve by team of yanjun ,More information please browse www.yanjun.tech */</span></div></pre></td></tr></table></figure><h2 id="七、PID的各参数规律"><a href="#七、PID的各参数规律" class="headerlink" title="七、PID的各参数规律"></a><strong>七、PID的各参数规律</strong></h2><p>这里以前我写过一篇博文不够完善，在这篇文章中我重新分析一遍。同时在我们文件夹中也提供了一个PID算法模拟软件，大家可以玩一下。原博客链接在这里：</p><p><a href="http://blog.csdn.net/zzw5945/article/details/53998859" target="_blank" rel="external">http://blog.csdn.net/zzw5945/article/details/53998859</a></p><p>这里先推荐大家看一个PID参数整定的gif，很形象生动大家一定要看。链接如下：</p><p><a href="https://en.wikipedia.org/wiki/PID_controller" target="_blank" rel="external">https://en.wikipedia.org/wiki/PID_controller#/media/File:PID_Compensation_Animated.gif</a></p><p><strong>A、Kp比例系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID19.jpg" alt="img"></p><p>图 7.1 分析Kp参数对系统响应的影响</p><p>如图：当Ki,Kd保持为常量时，改变Kp。图上在t = 1s时，给系统一个阶跃信号，然后调节Kp比例项的值。图中红线为Kp = 0.5时候的响应曲线，绿线为Kp = 1.1时候的响应曲线，紫线为Kp = 1.6时的响应曲线。（注：我认为上图有问题，纯比例Kp环节我认为是存在静差的。所以上图稳定的时候 应该和期望值之间有一定的稳态误差，如下图7.2所示。但是我没找到合适的图所以就用这个了）</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID20.png" alt="img"></p><p>图7.2 纯比例环节系统输出响应曲线</p><p>从图7.1进行分析，可以得到以下信息：</p><p>红线：</p><p>当Kp比例项较小时，响应无超调无震荡，上升时间较长，但是稳定时间很长，延时时间长。</p><p>绿线：</p><p>当Kp比例项增大时，响应有较小超调，上升时间明显缩短，稳定时间缩短。</p><p>紫线：</p><p>当Kp比例项足够大时，响应曲线超调较大，震荡很多次，上升时间继续缩短，但是稳定时间却增长了。</p><p>如果继续增大Kp值呢？？这里图上没有反应，但是我们可以推测一下：上升时间继续减小，超调继续增大，震荡次数增大，最终系统失控发散，系统性能恶化。所以调PID参数时一定要小心，Kp值不能过大。总结以下：Kp在一定范围内可以调节系统的快速性，但是会影响系统的稳定性，Kp也会影响到系统的准确性。</p><p><strong>B、Ki积分系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID21.png" alt="img"></p><p>图7.3 Kp = 5 Ki = 0时系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID22.png" alt="img"></p><p>图7.4 Kp = 5 Ki = 0.4时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID23.png" alt="img"></p><p>图7.5 Kp = 5 Ki = 1.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID24.png" alt="img"></p><p>图7.6 Kp = 5 Ki = 2.9时的系统输出响应</p><p>​    从图7.3、7.4、7.5、7.6这四幅图中，我们能从图上可以看出Ki是用来消除静差的。静差其实就是我们名词解释中的稳态误差。我们这里几幅图都使用的是控制变量法，控制Kp一致然后在不同的Ki参数下观察曲线的变化规律。我们可以看出在一定范围内，Ki增大将减小稳态误差（静差），但是从上面几幅图中我们也能看出Ki其实和Kp的作用类似，属于”+”作用，ki虽然在能减小静差，但是系统也会不稳定。总结一下ki的作用如下：</p><p>​    Ki在一定范围内调节能减小系统静差，增加系统的快速性，但是会降低系统的稳定性。当Ki过大时会引起系统的不稳定。</p><p><strong>C、Kd微分系数对系统响应的影响：</strong></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID25.png" alt="img"></p><p>图7.7 Kp Ki为定值，kd = 0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID26.png" alt="img"></p><p>图7.8 Kp Ki为定值，kd = 0.5时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID27.png" alt="img"></p><p>图7.9 Kp Ki为定值，kd = 1.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID28.png" alt="img"></p><p>图7.10 Kp Ki为定值，kd = 3.0时的系统输出响应</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID29.png" alt="img"></p><p>图7.11 Kd对系统输出响应影响</p><p>Kd的作用总结：Kd可以理解成阻尼系数。也就是在一定程度上可以抑制超调，减小超调量。但是能增强系统的稳定性，但是会稍微延长一定的上升时间也就是说会影响一点快速性。</p><h2 id="八、四轴与自平衡小车PID参数整定调试台"><a href="#八、四轴与自平衡小车PID参数整定调试台" class="headerlink" title="八、四轴与自平衡小车PID参数整定调试台"></a>八、四轴与自平衡小车PID参数整定调试台</h2><p><strong>A.微型四轴PID调试设备</strong></p><p>需要大家购买：6<em>6mm内径万向节</em>1如图8.1所示、M3<em>10mm铜柱</em>2个（外径是4.7mm），2020型材或者碳杆。要求2020型材中间的孔径能插入一个4.7mm外径的M3铜柱。这里型材至少买一根，如果买的多的话还应该买点2020型材角件进行固定，然后可以搭出一个底座架如图8.4所示。这里我们买的万向节是二维运动的，我们在做我们的微型四轴PID调试台的时候，调PID应该是单轴运动的。所以我们要通过铜柱将万向节的其中一个轴固定住，只让它一个轴运动（让铜柱抵住万向节，就能实现）如下图8.5所示，连接四轴和万向节使用的就是铜柱和螺母，连接万向节和型材使用的也是铜柱。</p><p>我们这调试台是为了微型四轴的调试而搭建的，如果是其他大型的四轴可能不能适用。得想其他办法</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID30.png" alt="img"></p><p>图8.1万向节</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID31.png" alt="img"></p><p>图8.2型材</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID32.png" alt="img"></p><p>图8.3 2020角件型材铝</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID33.png" alt="img"></p><p>图8.4型材架</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID34.png" alt="img"></p><p>图8.5微型四轴PID调试架示意图</p><p><strong>B.Qav250穿越机PID调试设备</strong></p><p>这里我们的QAV250算是小型无人机，但是用上面那种调试设备就不是特别适合了。这里我们使用的是如下图所示的调试架，我们买了一个丝杠，然后将四轴绑在丝杠上进行调试的。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID35.jpg" alt="img"></p><p>图8.6 QAV250穿越机PID调试架示意图</p><p><strong>C.自平衡小车PID调试设备</strong></p><p>自平衡小车的调试最简单方便，不需要购买任何配件。调试的时候我们直接用腿直接夹住自平衡小车的车轮，让车的上部分运动就可以进行PID调试了。</p><h2 id="九、单级PID参数整定经验"><a href="#九、单级PID参数整定经验" class="headerlink" title="九、单级PID参数整定经验"></a>九、单级PID参数整定经验</h2><p>单级PID由于效果不如串级PID完美，我们以前使用过单级PID。但是自从串级PID玩习惯了之后一直都在用串级PID，所以我们讲解的重点是串级pid的调试方法。关于单级PID的整定经验，我这里简单给大家讲讲：（单级PID没有留下调试图片，所以不是特别好描述）。</p><p>​    调试PID时，我们需要使用电脑串口上位机显示出实际值曲线和目标给定值曲线。这里我们使用的上位机是YJ_Chart YJ串口上位机，单片机的串口与电脑YJ_Chart上位机通信的接口程序详见我们的debug.c文件。或者大家打开我们提供的四轴驱动工程代码，找到debug驱动工程即可进行学习了解。更多资料请访问我们的网站——www.yanjuntech.cn下载了解。</p><p>​    先总结一下我们的PID参数整定方法：</p><ol><li>如果只需要调节一个环的PID，也就是所谓的单级PID，我们直接使用下面这几点经验即可。如果是串级PID我们需要先调试内环，再调试外环。</li><li>首先我们通过写程序以及搭硬件调试设备，先单独的调试一个轴的PID参数</li><li>调节PID参数之前，我们需要明确我们的PID结构，需要明确输入量期望值，实际值的物理意义。比如四轴单级PID，输入量就是遥控器给定的目标角度，实际值就是通过姿态传感器解算出来的姿态角度。</li><li>调试PID参数之前，最最重要的就是一定要确定反馈回来的数据是正确的，如果反馈值不正确，再怎么调试PID参数都是徒劳的。所以调试之前一定要确定反馈量正确。</li><li>调节PID参数的时候，我们需要看 具体现象以及 实际值与目标期望值的曲线。（使用串口上位机，将数据发送到电脑上位机上打印曲线）</li><li>在调试Kp Ki Kd的时候，第一步要做的就是要确定好Kp Ki Kd参数的”+-“必须先确定正负，然后再开始调节PID参数。我们常用2种方法分析”+-“号，一种是理性分析法，一种是经验调试法。</li><li>理性分析法，比如四轴，总共4个电机，顺时针方向分别为1.2.3.4，也就是23和14在x轴方向上，12和34在y轴方向上。先假设四轴只单方向运动，假设按x轴方向运动，也就是向23或者14边运动。假设向23边偏此时实际的x轴角度数据为+23度，目标值是0度，那么偏差就是-23度。飞行器想稳定到0度，也就是23边的电机需要转动快一点，14边要慢一点。由比例环节就是kp*偏差，那么这时候就能根据这一点和最后的控制量输出来确定Kp的”+-“号。另一种方法就是 参数经验法了，直接控制其他两个系数为0，然后设置一个比较大一点的大概合理的值然后根据实际现象确定正负号。</li><li>单轴PID参数先从Kp进行调节，调节方法是1-2-4-8-16……先二倍法，然后使用二分法调节。观察现象如果发现Kp大了就减小一半，然后再在新的范围内调节。</li><li>Kp调试完成后再考虑是否调节Ki，是否需要消除静差。</li><li>微型四轴单级姿态环PID调试经验</li></ol><p>这里我们仅仅给大家介绍姿态环PID的调试经验，可能有的还需要高度环和位置环PID。我们在讲解的时候仅给大家讲解姿态环PID。</p><p>首先，我们微型四轴单级PID控制框图，了解一下基本的控制原理。这里输入的是期望角度，这个在实际应用中对应的是遥控器给定的目标角度（遥控器遥杆给定的值）。而反馈通道反馈回来的就是实际的姿态角度。然后目标角度和实际角度就存在偏差，偏差送入PID调节器进行调节，调节输出量作用在PWM电机上，电机的转速不同又间接影响到我们四轴的飞行姿态从而实现单级的闭环控制。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID36.png" alt="img"></p><p>图9.1 微型四轴的单级PID框图</p><ol><li>在调试PID参数之前，我们应该把要用到的程序都要搞好，同时确定好反馈量确实正确。也就是说已经做好了调试PID参数的所有准备工作。（再说一句：调试PID参数之前一定要确定好反馈量一定是正确的，这个很重要很重要）。</li><li>将微型四轴固定在我们准备好的硬件调试台上（只能绕一个轴运动，我们调试PID的时候都是一个轴一个轴调试-分轴调试），然后连接上jlink下载器和USB转串口线，打开YJ_Chart（我们将YJ_Chart也完全开源了）用于显示实际值和期望值曲线。在调试的过程中可以参考。</li><li>写好调试程序，可以将实际值和目标期望值打印到电脑上位机上这样我们就能定性的观看参数调试的效果曲线了。同时我们应该写好相应的基础程序，包括PID运算相关的程序。</li><li>我们要修改程序，调试四轴PID的时候，我们调试经验是一个轴一个轴的调试，所以我们需要注释掉其他轴代码，或者在最后的输出的时候，不加上其他轴的PID输出如下：</li></ol><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID37.png" alt="img"></p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID38.png" alt="img"></p><p>图9.2 单轴PID代码片段</p><p>​    上面这个+-号实际是根据四轴的空气动力学来确定的，关于四轴中的空气动力学请见本文的第11部分。</p><p>​    整定四轴的姿态环PID，实际上整定的就是三轴姿态角的PID——俯仰角、横滚角、偏航角。整定时正如我们上面说的修改程序固定到调试架上用串口打印曲线，然后一个轴一个轴的调试。</p><p>单级PID参数整定举例——x轴参数整定</p><p>​    下面我拿x轴举例子，来进行PID调试。</p><p>​    我们的实际值其实就是遥控器给定的值，也就是所谓的期望值x_AttitudeTargetData.f_X（也要写相应的程序，用来获取遥控器的设定值）。而我们的实际值其实就是我们四轴的实际姿态x_AttitudeNow.x_AngleNow.f_X。计算PID运算伪代码就如下：</p><p>​    本次偏差 = 目标值 – 实际值;</p><p>​    本次微分 = 本次偏差 – 上次偏差;</p><p>​    上次偏差 = 本次偏差;</p><p>​    PID计算()函数，传入上述参数;</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID39.png" alt="img"></p><p>图9.3PID参数结构体</p><p>​    如图9.3所示，红框中的参数都是我们都是能进行手动设定的。最上面三个参数分别是Kp、Ki、Kd——比例积分微分系数。如果我们需要使用积分分离功能，则还要设置积分分离阈值同时也应该设置抗饱和积分阈值。最后的PID输出，我们应该设置好PID的输出阈值。</p><p>​    微型四轴的单级PID调试经验如下所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID40.png" alt="img"></p><p>图9.4微型四轴调试设备</p><ol><li>调试之前，一定要确定反馈值（实际值）是正确无误的。如果反馈信号有问题，根本就调不出来参数。</li><li>修改好程序，打开串口调试曲线软件。（单级的我没留调试过程中的图片，单级就简单口头说说，大家去看下面我写的串级的PID参数整定经验，那篇比较全）</li><li>目标值由遥控器设定的值，实际值是四轴的实际姿态角，修改Kp，使用2倍2分法。先确定好Kp的”+-“号。然后按1-2-4-8-16-32-64…这样二倍法调试，然后比如64的时候参数效果有点小，但是改成128的时候，发现效果有点过头了。那么我们需要使用二分法进行调试，找64和128的中间值：96然后再64-96内调试确定如果小了，在96-128中间进行二分法调试。</li><li>Kp调试效果简述：四轴调试角度应该是-30度–+30度范围内，如果角度比较大的时候，受到重力的影响比较大，参数整定就不准确效果不好了。我们把四轴放到-20度方向，然后改Kp参数，当Kp比较小的时候四轴表现的效果是软趴趴，到不了目标值0。当Kp比较大的时候，也就是快速超过目标值，停不下来。当参数比较合适的时候会在中心位置震荡（0度附近运动）。</li><li>大概能在目标值附近停住或者震荡，此时我们稍微再加Kd微分系数（也要确定好±），注意Kd效果是阻尼的效果，实际四轴效果是：当只有Kd比较大的时候，向x轴正方向运动假如4个电机顺时针分别是1.2.3.4号电机。假如向23电机方向快速运动，那么Kd正确的效果应该是 使电机的2.3号电机转动。以此确定Kd的方向。然后开始调试Kd的值，如果微分项没有除以采样时间（我们用的是0.002s采样时间），那么Kd值就比较大可能上百上千。如果微分项除以了采样时间，那么Kd值就比较小了。不加Kd，只有合适的Kp能在平衡位置震荡。而加上Kd之后，效果就很好了，能比较稳定了。</li><li>大家在上面的调试过程中，将目标值曲线和实际值曲线打印出来。来看看PID的整定规律。看曲线看看稳定后的实际值和目标值之间的静差（稳态误差）是否比较大。如果比较大，可能就需要加Ki参数，来调试。Ki调试过程实际看的是，稳定后的目标值与实际值之间静差的大小。把曲线打印出来，就能很好的观察调试参数。</li></ol><p>好了关于单级PID整定方法，我们就讲简单分享到这里。没有留下太多图片可能大家不是特别好理解，下面的串级PID参数整定，我留下的图片比较多，大家去看看串级PID参数的整定，相信你会有很大收获的。</p><ol><li><p>自平衡小车单级PID调试经验</p><p>自平衡小车的单级PID和微型四轴的单级PID参数调试经验差不多，这里不过多介绍了。自平衡小车的姿态环单级PID（自立PID） 目标值一般情况下都是0度，实际值就是小车的实际角度。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID41.png" alt="img"></p></li></ol><p>图9.2 自平衡小车的单级PID框图</p><h2 id="十、串级PID参数整定经验"><a href="#十、串级PID参数整定经验" class="headerlink" title="十、串级PID参数整定经验"></a>十、串级PID参数整定经验</h2><p>调试PID时，我们需要使用电脑串口上位机显示出实际值曲线和目标给定值曲线。这里我们使用的上位机是YJ_Chart YJ串口上位机，单片机的串口与电脑YJ_Chart上位机通信的接口程序详见我们的debug.c文件。或者大家打开我们提供的四轴驱动工程代码，找到debug驱动工程即可进行学习了解。更多资料请访问我们的网站——www.yanjuntech.cn下载了解</p><p>​    建议大家先读一下单级PID上面总结的一些实用经验。</p><ol><li>自平衡小车串级PID调试经验</li></ol><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID44.png" alt="img"></p><p>图10.1 自平衡小车串级PID框架</p><p>​    首先我们已经写好了所有基础程序，做好了准备工作。这里自平衡小车的PID整定过程中的效果曲线我记录的比较完整，所以这部分可以比较清晰的看明白。如图10.1所示，自平衡小车的姿态环串级PID有两个闭环，分别是内环——角速度环、外环角度环。我们在整定的时候是先整定内环角速度环，整定好了之后再来整定外环角度环的。</p><p>​    当然如果想实现自平衡小车稳定自立以及前进和拐弯的话，除了姿态环PID还需要速度环和转向环PID。这里我们为了省事，就拿姿态环的PID参数整定过程给大家讲解PID参数的整定经验。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID45.png" alt="img"></p><p>图10.2两轮自平衡小车实物图</p><p>​    我们插上USB线（板子上已经集成USB转串口芯片了），修改程序准备开调PID参数。我们调试的时候是先调内环也就是角速度环的PID参数，调试好后再调外环的PID参数。</p><ol><li>角速度内环整定经验</li></ol><p>首先改代码，改成内环调试用的代码。如下图10.3所示，内环调试时PID的内环给定设置成遥控器的给定值，也就是遥控器的给定设置成目标角速度。而实际值就是我们自平衡小车的实际运动角速度（陀螺仪测量出来的经过低通滤波的角速度）。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID46.png" alt="img"></p><p>图10.3角速度内环参数调试</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID47.png" alt="img"></p><p>图10.4角速度环发送到上位机</p><p>​    图10.4就是我们将目标角速度（遥控器设定的值）和实际角速度发送到电脑上位机上用曲线显示出来便于我们调试用。见下图10.5所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID48.png" alt="img"></p><p>图10.5遥控器给定值曲线-蓝线</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID49.png" alt="img"></p><p>图10.6小车实际角速度-黄线</p><p>​    如上图10.5和10.6所示，蓝线为遥控器控制的值也就是我们所说的目标值。黄线为平衡小车的实际角速度值打印出来的曲线也就是我们所说的实际值。看10.6，我们遥控器没有设置给定值，目标期望也就为0弧度/s，实际值是我们晃动小车，小车打印出来的实际角速度值。下面我们用腿夹住平衡小车的两个轮子，我们要开始调试平衡小车的内环角速度环的PID参数了如图10.7所示：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID50.png" alt="img"></p><p>图10.7用腿夹住小车两轮</p><p>​    我们下面开始调PID参数，先调Kp确定好Kp的符号，其他值保持为0：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID51.png" alt="img"></p><p>图10.8Kp = 10实际值与目标值曲线</p><p>​    当Kp = 10，太小了，改变目标期望值的时候，实际的角速度并没有变化，所以是Kp太小，效果太软。我们继续加Kp = 20；二倍法，如下图10.9所示：发现Kp = 20时，改变目标角速度，但是实际的角速度也并没有任何变化。所以值还是小，我们继续增大Kp 的值。继续使用二倍法，增加到Kp = 40；</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID52.png" alt="img"></p><p>图10.9 Kp = 20内环角速度调试</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID53.png" alt="img"></p><p>图10.9 Kp = 40内环角速度调试</p><p>​    我们可以看到Kp = 40，有效果了，但是力量依然不够还是小我们继续加大Kp = 80：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID54.png" alt="img"></p><p>图10.9 Kp = 80内环角速度调试</p><p>​    从图上我们可以看出，Kp = 80时还是有点小。我们继续增大一倍到160：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID55.png" alt="img"></p><p>图10.9 Kp = 160内环角速度调试</p><p>​    感觉效果有点过头，有点大了我们需要使用二分法砍到120然后看看效果。不够我们先继续增大到320，看看Kp过大是什么效果：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID56.png" alt="img"></p><p>图10.9 Kp = 320内环角速度调试</p><p>​    可以看到，Kp = 320时。系统已经很不稳定了崩溃了……，我们将Kp改小然后调试，我们发现的不错的效果值是Kp = 130。然后让我们加一点Kd，看看实际效果</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID57.png" alt="img"></p><p>图10.10 Kp = 130 Kd = 500内环角速度调试</p><p>​    当然大家如果再好好调调参数，效果比这个还好还是有可能的毕竟我们这里只是粗略的调试，到这个程度实际的效果就是用遥控器控制平衡小车，小车能按遥控器设置的角速度运动，我们可以通过遥控器控制小车停在竖直位置。下</p><p>​    到这个程度，就说明我们的内环就已经调试完毕了，下面我们要开始调试外环的角度环PID参数。</p><ol><li><p>角度外环参数整定经验</p><p>首先也是改程序，改成外环角度环调试的代码。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID58.png" alt="img"></p></li></ol><p>图10.11 角度外环调试代码</p><p>发送目标角度和实际角度数据到上位机。然后下面我们要开始调试了：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID59.png" alt="img"></p><p>图10.12 角度发送到上位机代码</p><p>​    首先要确定是外环的Kp系数的符号，外环一般只需要Kp比例系数就可以了。Kp可以增加系统的快速性，合适的外环Kp参数可以快速稳定到目标角度。一般外环的Kp比较小，内环的Kp比较大（系统有关和程序写的方式有关），大家可以使用PID的输出除以大概的偏差大致的得到PID的Kp参数的数量级。比如PID输出量是300，而偏差大概是3左右，那么Kp的数量级就是100左右（内环的数量级），而外环数量街：PID的输出量是2.0左右，偏差为20度的话，则kp的范围大致为0.1左右，所以在调试PID的时候可以首先通过简单计算确定出参数的大致范围。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID60.png" alt="img"></p><p>图10.13 角度外环Kp = 0.1时的目标角度和实际角度</p><p>​    由图可以看出，参数有点小，实际值追不上目标值的变化。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID61.png" alt="img"></p><p>图10.14 角度外环Kp = 0.2时的目标角度和实际角度</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID62.png" alt="img"></p><p>图10.15 角度外环Kp = 0.3时的目标角度和实际角度</p><p>​    由图可以看出，Kp = 0.3的时候效果很好，快速性很高响应速度很快。跟随给定的效果很好，而且没有太多超调。效果很好，于是姿态环外环角度环的PID参数就调试出来了。当外环角度环Kp过大的时候，效果如下图所示10.16：</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID63.jpg" alt="img"></p><p>图10.16外环Kp比较大系统崩溃</p><p>​    </p><p>​    总结一下：有的串级PID的参数整定还是比较容易的，借用串口显示曲线的软件将比较方便的的调试我们的PID参数。</p><ol><li>先调试内环，再调试外环</li><li>修改程序，使用串口助手打印曲线</li><li>自平衡小车电机控制内环使用PD，外环使用P就能实现很好效果</li><li>调试PID参数的时候先调试P参数再调试D参数最后根据效果调试I参数</li><li></li></ol><p>B、微型四轴串级PID调试经验</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID64.png" alt="img"></p><p>图10.17四轴串级PID框架</p><p>四轴的串级PID参数调试，过程和上面差不多。只不过四轴的姿态是3个姿态角，而自平衡小车的姿态角只有1个。但是我们在调试的时候，实际上也是使用调试架控制四轴只能绕一个轴运动。</p><p><img src="/2018/10/30/四旋翼PID调参笔记/070118_0724_PID65.png" alt="img"></p><p>图10.18单轴PID调试架</p><p>​    然后我们先调试x轴的PID参数，y轴参数和x轴差不多可以直接复制。调试步骤也是先调P再调D最后调I。</p><h2 id="十一、飞控姿态角调试台和数据分析"><a href="#十一、飞控姿态角调试台和数据分析" class="headerlink" title="十一、飞控姿态角调试台和数据分析"></a>十一、飞控姿态角调试台和数据分析</h2><p><img src="http://s8.sinaimg.cn/mw690/001aRpVkzy77PfzHCppf7&amp;690" alt="åæç¿¼é£äºäºï¼äºï¼ï¼é£æ§å§¿ææ§å¶å°æ¶è¯éª(四旋翼PID调参笔记\001aRpVkzy77PfzHCppf7&amp;690)"></p><p>在飞控自稳飞行之前，都需要在这个台架上对Roll、Pitch的内环（速度闭环）、外环（位置闭环）进行反复的调试，直到性能非常稳定以后，才可会给它解绑，让它飞向天空。</p><p>​        以下仅以 roll 角为例进行性能分析，pitch测试类同。</p><p><strong>1 Roll 内环测试</strong></p><p>​        roll角控制分为外环和内环，内环为速度跟踪环，外环为位置跟踪环。调试时，一般先将内环跟踪调试好，再调试外环。</p><p>​        以下是roll角内环测试时的速度跟踪曲线（目标跟踪速度正负90°/s）。</p><p><img src="http://s2.sinaimg.cn/mw690/001aRpVkzy77PfH49Lr91&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfH49Lr91&amp;690)"></p><p>​        上图我们发现当给定一个期望角速度，实际角速度从0°/s上升到90°/s花费的时间大约为350ms。这个跟踪时间稍微有点长，这个有待进一步优化。</p><p>​        同时通过上图发现角速度往正向跟踪时稍显缓慢，这和试验测试的场景有一定的关系，试验测试场景描述如下：</p><p>​        正向运转测试时，飞行器roll角从-60°经过0°（水平位置）再到+60°位置停下。</p><p>​        反向运转测试时，飞行器roll角从+60°经过0°（水平位置）再到-60°位置停下。 </p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PfPebiYe4&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfPebiYe4&amp;690)"></p><p>​        上图为roll角的变化曲线，基本上roll角的变化斜率（速率）是一定的。由于roll角变化角度非常大，以至于飞行器重心波动非常大，所以给速度跟踪带来了一定影响。下图为速度跟踪时记录的系统阻尼曲线。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PfS15nC84&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PfS15nC84&amp;690)"></p><p>​        我们发现正向运动时阻尼大概是0.2，反向运转时阻尼为0.1。这导致正向运转跟踪速度受到一定的影响。</p><p><strong>2 roll外环测试</strong></p><p>​        以下是roll外环测试的曲线（目标跟踪角度正负45°）。</p><p><img src="http://s7.sinaimg.cn/mw690/001aRpVkzy77Pg119Nc56&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pg119Nc56&amp;690)"></p><p><img src="http://s14.sinaimg.cn/mw690/001aRpVkzy77Pg0uAcldd&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pg0uAcldd&amp;690)"></p><p>​        上图我们可以看到，roll角跟踪非常良好，正向跟踪最大2.4°的超调。反向跟踪时最大5°的超调。</p><p>​        下图是角速度的曲线，同时可以看到角度跟踪延时有330ms。这个延时与前面提到的350ms角速度延时基本一致，这个是需要进一步优化的。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy77PhL14HOb4&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77PhL14HOb4&amp;690)"></p><p><strong>3 电机特性分析</strong></p><p>​        在最初开发阶段，我们对飞行器响应特性进行了测试。测试时发现电调、电机的综合响应性能并不理想。以下是我们实验记录的一组指令扭矩与电机角速度响应曲线。</p><p><img src="http://s6.sinaimg.cn/mw690/001aRpVkzy77Pi5kntj25&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Pi5kntj25&amp;690)"></p><p>​        我们每5ms采集一个点，从上图曲线中我们发现电机角速度相对指令扭矩之间有100ms左右的相位延时。</p><p>通过多次实验，我们最终确定该电机、电调和螺旋桨的综合响应延时时间100ms，惯性时间常数约40ms（响应频率4hz）。这个参数指标有点让人意外，这样的特性严重降低了我们控制调节的带宽和频率。（关于电机、电调准确延时时间，我暂时还没有做非常严格的测试，严格的测试需要用到我们前不久制作的无刷电机拉力测试台，请参考另外一篇文章：<a href="http://blog.sina.com.cn/s/blog_402c071e0102wyji.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_402c071e0102wyji.html</a>）</p><p>​        由于受现有电调固有特性的限制，电调的调节频率目前为50hz。我们的姿态控制算法运行在200hz频率下，实际电机指令输出频率50hz。</p><p><strong>4 另附一组数据</strong></p><p>​        这是Pitch角的测试结果，下图包含了目标角速度与目标角度的跟踪结果。</p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77Rkuqtpme8" target="_blank" rel="external"><img src="http://s9.sinaimg.cn/mw690/001aRpVkzy77Rkuqtpme8&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Rkuqtpme8&amp;690)"></a><br>        下图为内环（角速度跟踪）<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77RkuXiyide" target="_blank" rel="external"><img src="http://s15.sinaimg.cn/mw690/001aRpVkzy77RkuXiyide&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77RkuXiyide&amp;690)"></a><br>        下图为外环（角度跟踪）<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x06g&amp;url=http://album.sina.com.cn/pic/001aRpVkzy77Rkv5uiA00" target="_blank" rel="external"><img src="http://s1.sinaimg.cn/mw690/001aRpVkzy77Rkv5uiA00&amp;690" alt="四旋翼那些事（五）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy77Rkv5uiA00&amp;690)"></a></p><p>  <strong>5 yaw测试</strong></p><p>相对roll、pitch测试，Yaw的测试更为容易，所以也没专门为Yaw角测试整一个专业 的台架。刚好手里有一个伺服电机做的圆盘，就地取材，将就着做了个简单测试。（整个测试时间不超过十分钟就搞定了。）</p><p>​      下图中，为一伺服电机，电机固定在一个 长方形的板子上。电机轴上安装一个圆盘，圆盘可以绕电机轴自由旋转。</p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T0aX9E662" target="_blank" rel="external"><img src="http://s3.sinaimg.cn/mw690/001aRpVkzy78T0aX9E662&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0aX9E662&amp;690)"></a></p><p>​      这里做测试并 没有用到电机，只用到了电机的旋转轴和这个圆盘而已。下图黑色的是伺服电机。<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T0bfBTy00" target="_blank" rel="external"><img src="http://s1.sinaimg.cn/mw690/001aRpVkzy78T0bfBTy00&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0bfBTy00&amp;690)"></a></p><p>​      将四旋翼捆绑在圆盘上。轻轻拨动一下机架，基本上可以自由无阻碍的旋转。<br><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x1vw&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78T08vGcled" target="_blank" rel="external"><img src="http://s14.sinaimg.cn/mw690/001aRpVkzy78T08vGcled&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T08vGcled&amp;690)"></a></p><p>​      下面开始实际测试。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy78T0TvCvO84&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0TvCvO84&amp;690)"></p><p>​      测试最大跟踪角速为200°/s。从上图 情况来看，反向目标角速度跟踪比较好，正向跟踪较为缓慢。具体原因在下图中给出了解释。</p><p><img src="http://s5.sinaimg.cn/mw690/001aRpVkzy78T0VKhzCc4&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0VKhzCc4&amp;690)"></p><p>​      上图Yaw角速度调节扭矩进行了饱和限幅处理。正向运转跟踪速度慢，是因为达到了我人为设定的一个扭矩限制值。而 反向运转未达到这个饱和限制值。这就是为什么正向运转跟踪速度慢，而反向运转跟踪良好。</p><p>​      那么是什么导致了正向反向特性不一样的呢？这是因为这个旋转台带来的正反向阻尼特性不一样造成的，下图曲线给 出了进一步解释。</p><p><img src="http://s2.sinaimg.cn/mw690/001aRpVkzy78T0W4pNLb1&amp;690" alt="四旋翼那些事（六）：飞控姿态控制台架试验(四旋翼PID调参笔记\001aRpVkzy78T0W4pNLb1&amp;690)"></p><h2 id="十二、定高测试架设计"><a href="#十二、定高测试架设计" class="headerlink" title="十二、定高测试架设计"></a>十二、定高测试架设计</h2><p>  <strong>定高测试台架（一）</strong></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xti5ACR11" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xti5ACR11&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xti7QAKbe" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xti7QAKbe&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xtia26P9f" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xtia26P9f&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78Xtic6spd9" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78Xtic6spd9&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p>​      <strong>定高测试台架（二）</strong></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjGcira7" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjGcira7&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjIAWSc2" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjIAWSc2&amp;690.jpg" alt="四旋翼定高测试台架"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=402c071e0102x21v&amp;url=http://album.sina.com.cn/pic/001aRpVkzy78XtjKAba24" target="_blank" rel="external"><img src="/2018/10/30/四旋翼PID调参笔记/001aRpVkzy78XtjKAba24&amp;690.jpg" alt="四旋翼定高测试台架"></a></p>]]></content>
      
      
      <categories>
          
          <category> 四旋翼 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vivadoHLS（一）</title>
      <link href="/2018/10/06/vivadoHLS-0/"/>
      <url>/2018/10/06/vivadoHLS-0/</url>
      
        <content type="html"><![CDATA[<h1 id="HLS学习"><a href="#HLS学习" class="headerlink" title="HLS学习"></a>HLS学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>FPGA又称可编程逻辑门阵列，因为其魔法的并行计算和魔法的可编程逻辑单元阵列，让我产生了兴趣。目前在学数电和verilog。一个月前小伙伴达成共识，要做一个参赛项目。在那个项目里面要全用verilog写的话……恕我直言！太难了(Ｔ▽Ｔ)。所以就开始学这个HLS，在用C转verilog的边缘试探。讲点正经的，这些技术工具本身就是在用户体验感的路上走了！跑了！加速了！底层的东西因为不符合普通人类思维，所以越走越窄。换个角度来说，也可以看做掌握底层的人越来越少。至于这个稀少带来的是价值提升还是被边缘化，这个还是要用发展的眼光去看的。至少现在我认为verilog/VHDL是不能抛弃的，并不是说学了HLS就用不着这些了。HLS也好，verilog/VHDL也好都有其局限性。最关键的还是使用这些工具的人自身的能力和经验。</p><h2 id="HLS基础介绍"><a href="#HLS基础介绍" class="headerlink" title="HLS基础介绍"></a>HLS基础介绍</h2><p>高层次综合（HLS）是指自动综合最初用C、C++或SystemC语言描述的数字设计。工程师之所以对高层次综合如此感兴趣，不仅是因为它能让工程师在较高的抽象层面上工作，而且还因为它能方便地生成多种设计解决方案。利用HLS，您能探索各种可能性，分析面积和性能特点，最终确定一个方案在FPGA芯片上实现算法。举例来说，您能探索将存储器映射到Block RAM（BRAM）或分布式RAM上有什么不同的影响，或者分析回路展开以及其它回路相关优化有什么效果，而且不必手动生成不同的寄存器传输级（RTL）设计。您所要做的仅仅是在C/C++/SystemC设计中设置相关指令而已。</p><p>赛灵思在其最新发布的Vivado™工具套件中推出了HLS工具。Vivado HLS是AutoESL工具的品牌转型重塑，可提供众多技术帮助您优化C/C++/SystemC代码以实现目标性能。这样的HLS工具就能帮助您在FPGA上快速实现算法，无需借助基于Verilog和VHDL等硬件描述语言的非常耗时的RTL设计方法。</p><h2 id="HLS入门学习资料"><a href="#HLS入门学习资料" class="headerlink" title="HLS入门学习资料"></a>HLS入门学习资料</h2><p>第一， 手边的学习资料。</p><p>安装Vivado HLS以后， 既包含了20个design example，50个code example:</p><p><img src="/2018/10/06/vivadoHLS-0/5096-18984-tupian1.png" alt="img"></p><p>第二， step by step教程</p><p>ug871 是xilinx公开提供的HLS教程， 包括11个例子：</p><p>C Validation<br>Interface Synthesis<br>Arbitrary Precision Types<br>Design Analysis<br>Design Optimization<br>RTL Verification<br>Using HLS IP in IP Integrator<br>Using HLS IP in a Zynq Processor Design<br>Using HLS IP in System Generator for DSP</p><p>ug871 ： <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx2013_1/ug871-vivado-high-level-synthesis-tutorial.pdf" target="_blank" rel="external">http://www.xilinx.com/support/documentation/sw_manuals/xilinx2013_1/ug87…</a></p><p>参考设计源代码： <a href="http://www.xilinx.com/cgi-bin/docs/rdoc?v=2013.2;t=vivado+tutorials" target="_blank" rel="external">http://www.xilinx.com/cgi-bin/docs/rdoc?v=2013.2;t=vivado+tutorials</a></p><p><img src="/2018/10/06/vivadoHLS-0/5096-18985-tupian2.png" alt="img"></p><p>第三， 13个Xilinx专家讲解视频， 包括讲座和演示</p><p>地址： <a href="http://www.xilinx.com/training/vivado" target="_blank" rel="external">www.xilinx.com/training/vivado</a></p><p>1.<a href="http://www.origin.xilinx.com/csi/training/vivado/getting-started-with-vivado-high-level-synthesis.htm" target="_blank" rel="external">Getting Started with Vivado High-Level Synthesis</a></p><p>2.<a href="http://www.origin.xilinx.com/csi/training/vivado/verifying-your-vivado-hls-design.htm" target="_blank" rel="external">Verifying your Vivado HLS Design</a></p><p>3.<a href="http://www.origin.xilinx.com/csi/training/vivado/packaging-vivado-hls-ip-for-use-from-vivado-ip-catalog.htm" target="_blank" rel="external">Packaging Vivado HLS IP for use from Vivado IP Catalog</a></p><p>4.<a href="http://www.origin.xilinx.com/csi/training/vivado/generating-vivado-hls-block-for-use-in-system-generator-for-dsp.htm" target="_blank" rel="external">Generating Vivado HLS block for use in System Generator for DSP</a></p><p>5.<a href="http://www.origin.xilinx.com/csi/training/vivado/generating-vivado-hls-pcore-for-use-in-xilinx-platform-studio.htm" target="_blank" rel="external">Generating Vivado HLS pcore for use in Xilinx Platform Studio</a></p><p>6.<a href="http://www.origin.xilinx.com/csi/training/vivado/analyzing-your-vivado-hls-design.htm" target="_blank" rel="external">Analyzing your Vivado HLS design</a></p><p>7.<a href="http://forums.xilinx.com/t5/forums/replypage/board-id/cn-vivado/message-id/%C2%A7%09http:/www.origin.xilinx.com/csi/training/vivado/specifying-axi4-interfaces-for-your-vivado-hls-design.htm" target="_blank" rel="external">Specifying AXI4 interfaces for your Vivado HLS design</a></p><p>8.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-c-in-system-generator.htm" target="_blank" rel="external">Using Vivado HLS C/C++/SystemC block in System Generator</a></p><p>9.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-c-based-pcores-in-xps.htm" target="_blank" rel="external">Using Vivado HLS C/C++/SystemC based pcores in XPS</a></p><p>10.<a href="http://www.origin.xilinx.com/csi/training/vivado/floating-point-design-with-vivado-hls.htm" target="_blank" rel="external">Floating-Point Design with Vivado HLS</a></p><p>11.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-software-libraries-in-your-c-code.htm" target="_blank" rel="external">Using Vivado HLS SW libraries in your C, C++, SystemC code</a></p><p>12.<a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-tcl-interface.htm" target="_blank" rel="external">Using the Vivado HLS Tcl </a><a href="http://www.origin.xilinx.com/csi/training/vivado/using-vivado-hls-tcl-interface.htm" target="_blank" rel="external">interface</a></p><p>13.<a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external">Leveraging </a><a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external">OpenCV</a><a href="http://www.xilinx.com/csi/training/vivado/leveraging-opencv-and-high-level-synthesis-with-vivado.htm" target="_blank" rel="external"> and High Level Synthesis with Vivado</a></p><p>第四， 不停更新的武林秘籍</p><p><a href="http://www.xilinx.com/hls" target="_blank" rel="external">www.xilinx.com/hls</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp745-processor-control-vhls.pdf" target="_blank" rel="external">XAPP745 Processor Control of Vivado HLS Designs</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp793-memory-structures-video-vivado-hls.pdf" target="_blank" rel="external">XAPP793 Implementing Memory Structures for Video Processing in the Vivado HLS Tool</a></p><p><a href="http://www.xilinx.com/support/index.htm" target="_blank" rel="external">XAPP599 </a><a href="http://www.xilinx.com/support/index.htm" target="_blank" rel="external">Floating Point Design with Vivado HLS</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp890-zynq-sobel-vivado-hls.pdf" target="_blank" rel="external">XAPP890 Zynq All Programmable SoC Sobel Filter Implementation Using the Vivado HLS </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp890-zynq-sobel-vivado-hls.pdf" target="_blank" rel="external">Tool</a></p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1163.pdf" target="_blank" rel="external">XAPP1163 - Floating-Point PID Controller Design with Vivado HLS and System Generator for </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1163.pdf" target="_blank" rel="external">DSP</a>、</p><p><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1167.pdf" target="_blank" rel="external">XAPP1167 </a><a href="http://www.xilinx.com/support/documentation/application_notes/xapp1167.pdf" target="_blank" rel="external">Accelerating OpenCV Applications with Zynq using Vivado HLS Video Libraries</a></p><p><img src="/2018/10/06/vivadoHLS-0/5096-18986-tupian4.png" alt="img"></p><h2 id="第一个Vivado-HLS工程"><a href="#第一个Vivado-HLS工程" class="headerlink" title="第一个Vivado HLS工程"></a>第一个Vivado HLS工程</h2><p><a href="http://xilinx.eetrend.com/d6-xilinx/webinar/2016-07/10340.html" target="_blank" rel="external">http://xilinx.eetrend.com/d6-xilinx/webinar/2016-07/10340.html</a></p><p><a href="http://xilinx.eetrend.com/d6-xilinx/blog/2016-12/10734.html" target="_blank" rel="external">http://xilinx.eetrend.com/d6-xilinx/blog/2016-12/10734.html</a></p><p>对于Vivado Hls来说，输入包括Tesbench，C/C++源代码和Directives，相应的输出为IP Catalog，DSP和SysGen，特别的，一个工程只能有一个顶层函数用于综和，这个顶层函数下面的子函数也是可以被综合的，会生成相应的VHDL和Verilog代码，所以，C综合后的RTL代码结构通常是跟原始C描述的结构是一致的，除非是子函数功能很简单，所需要的逻辑量很小。 通常在main函数以下的函数都可以被综合，也就是说，并不是所有的C/C++都可以被综合，动态内存分配和涉及到操作系统层面的操作不可以被综合。 </p><h3 id="本部分结构框架："><a href="#本部分结构框架：" class="headerlink" title="本部分结构框架："></a>本部分结构框架：</h3><p>Creat New Project新建文档</p><p>C simulation</p><p>C systhesis</p><p>RTL级仿真</p><p>IP封装</p><p>总结</p><h3 id="1-Creat-New-Project新建文档"><a href="#1-Creat-New-Project新建文档" class="headerlink" title="1.Creat New Project新建文档"></a>1.Creat New Project新建文档</h3><p><img src="/2018/10/06/vivadoHLS-0/10734-27136-vivado_-1.png" alt="img"></p><p>​          新建一个Project name，点next（这里选取简单的4选1数据选择器为例，主要是说明流程）</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27137-vivado_-2.png" alt="img"></p><p>​    在Add Files里添加mux41.c文件，点next</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27138-vivado_-3.png" alt="img"></p><p>​    添加mux41_test测试文件，点next</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27139-vivado_-4.png" alt="img"></p><p>点Part，这里选择Board下面的Zedboard Zynq开发板，然后点OK和finish</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27140-vivado_-5.png" alt="img"></p><p>注释：<br>mux41.c代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mux41.h"</span></span></div><div class="line"><span class="function">int1 <span class="title">mux41</span><span class="params">(int1 sig_a, int1 sig_b,int1 sig_c,int1 sig_d, <span class="keyword">int</span> select)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(select==<span class="number">0</span>)</div><div class="line">       <span class="keyword">return</span> sig_a;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">1</span>)</div><div class="line">       <span class="keyword">return</span> sig_b;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">2</span>)</div><div class="line">       <span class="keyword">return</span> sig_c;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(select==<span class="number">3</span>)</div><div class="line">       <span class="keyword">return</span> sig_d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>mux41.h代码：(头文件)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ap_cint.h&gt;</span></span></div></pre></td></tr></table></figure><p>mux41_tb代码：(testbench)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mux41.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> res1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res2 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res3 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res4 = <span class="number">0</span>;</div><div class="line">  res1=mux41(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    res2=mux41(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">    res3=mux41(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);</div><div class="line">    res4=mux41(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>);</div><div class="line">    <span class="keyword">if</span>(res1 &amp;&amp; res2 &amp;&amp; res3 &amp;&amp; res4)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"test passed, well done!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-C-simulation"><a href="#2-C-simulation" class="headerlink" title="2.C simulation"></a>2.C simulation</h3><p>在菜单里Project&gt;Run C simulation，C simulation可以得到csim文件</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27141-vivado-6.png" alt="img"></p><p>从图中看到，可以看到test passed,well done!，证明结果是正确的：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27142-vivado-7.png" alt="img"></p><h3 id="3-C-systhesis"><a href="#3-C-systhesis" class="headerlink" title="3.C systhesis:"></a>3.C systhesis:</h3><p><img src="/2018/10/06/vivadoHLS-0/10734-27143-vivado_-8.png" alt="img"></p><p>注意综合得到的verilog代码的可读性很差，不需要读懂，所以大多数优化都在C这个层面去做的，下面是综合后的verilog代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// ==============================================================</div><div class="line">// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC</div><div class="line">// Version: 2016.3</div><div class="line">// Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved.</div><div class="line">// </div><div class="line">// ===========================================================</div><div class="line">`timescale 1 ns / 1 ps </div><div class="line">(* CORE_GENERATION_INFO="mux41,hls_ip_2016_3,&#123;HLS_INPUT_TYPE=c,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=1,HLS_INPUT_PART=xc7z020clg484-</div><div class="line">1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=5.258000,HLS_SYN_LAT=0,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=0,HLS_SYN_LUT=41&#125;" *)</div><div class="line">module mux41 (</div><div class="line">        ap_start,</div><div class="line">        ap_done,</div><div class="line">        ap_idle,</div><div class="line">        ap_ready,</div><div class="line">        sig_a,</div><div class="line">        sig_b,</div><div class="line">        sig_c,</div><div class="line">        sig_d,</div><div class="line">        select_r,</div><div class="line">        ap_return</div><div class="line">);</div><div class="line">parameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;</div><div class="line">parameter    ap_const_lv32_1 = 32'b1;</div><div class="line">parameter    ap_const_lv32_2 = 32'b10;</div><div class="line">input   ap_start;</div><div class="line">output   ap_done;</div><div class="line">output   ap_idle;</div><div class="line">output   ap_ready;</div><div class="line">input  [0:0] sig_a;</div><div class="line">input  [0:0] sig_b;</div><div class="line">input  [0:0] sig_c;</div><div class="line">input  [0:0] sig_d;</div><div class="line">input  [31:0] select_r;</div><div class="line">output  [0:0] ap_return;</div><div class="line">wire   [0:0] tmp_fu_60_p2;</div><div class="line">wire   [0:0] tmp_1_fu_66_p2;</div><div class="line">wire   [0:0] sel_tmp1_fu_86_p2;</div><div class="line">wire   [0:0] sel_tmp2_fu_92_p2;</div><div class="line">wire   [0:0] sel_tmp_fu_78_p3;</div><div class="line">wire   [0:0] tmp_2_fu_72_p2;</div><div class="line">wire   [0:0] tmp7_fu_106_p2;</div><div class="line">wire   [0:0] sel_tmp5_fu_112_p2;</div><div class="line">wire   [0:0] p_0_fu_98_p3;</div><div class="line">assign ap_done = ap_start;</div><div class="line">assign ap_idle = 1'b1;</div><div class="line">assign ap_ready = ap_start;</div><div class="line">assign ap_return = ((sel_tmp5_fu_112_p2[0:0] === 1'b1) ? p_0_fu_98_p3 : sig_d);</div><div class="line">assign p_0_fu_98_p3 = ((sel_tmp2_fu_92_p2[0:0] === 1'b1) ? sig_b : sel_tmp_fu_78_p3);</div><div class="line">assign sel_tmp1_fu_86_p2 = (tmp_fu_60_p2 ^ 1'b1);</div><div class="line">assign sel_tmp2_fu_92_p2 = (tmp_1_fu_66_p2 &amp; sel_tmp1_fu_86_p2);</div><div class="line">assign sel_tmp5_fu_112_p2 = (tmp7_fu_106_p2 | tmp_fu_60_p2);</div><div class="line">assign sel_tmp_fu_78_p3 = ((tmp_fu_60_p2[0:0] === 1'b1) ? sig_a : sig_c);</div><div class="line">assign tmp7_fu_106_p2 = (tmp_1_fu_66_p2 | tmp_2_fu_72_p2);</div><div class="line">assign tmp_1_fu_66_p2 = ((select_r == ap_const_lv32_1) ? 1'b1 : 1'b0);</div><div class="line">assign tmp_2_fu_72_p2 = ((select_r == ap_const_lv32_2) ? 1'b1 : 1'b0);</div><div class="line">assign tmp_fu_60_p2 = ((select_r == ap_const_lv32_0) ? 1'b1 : 1'b0);</div><div class="line">endmodule //mux41</div></pre></td></tr></table></figure><h3 id="4-RTL级仿真"><a href="#4-RTL级仿真" class="headerlink" title="4.RTL级仿真"></a>4.RTL级仿真</h3><p>在菜单里Solution&gt;RunC/RTL cosimulation，需要对Co-similation Dialog设置如下：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27144-vivado-9.png" alt="img"></p><p>得到如下结果，我们会发现Verilog的Status是pass，证明C/RTL cosimulation成功:</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27145-vivado-10.png" alt="img"></p><p>然后我们点开波形查看窗口，此时会自动打开Vivado软件，从图中看到，mux41的功能正确：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27146-vivado-11.png" alt="img"></p><h3 id="5-IP封装"><a href="#5-IP封装" class="headerlink" title="5.IP封装"></a>5.IP封装</h3><p>在菜单里Solution&gt;Export TL，设置如下：</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27147-vivado-12.png" alt="img"></p><p>IP封装后，会得到impl文件，其中就有我们所需要的三个子文件ip，verilog，vhdl</p><p><img src="/2018/10/06/vivadoHLS-0/10734-27148-vivado-13.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，在整个流程中，用户先创建一个设计 C、C++ 或 SystemC 源代码，以及一个C的测试平台。随后需要用 GCC/G++或 Visual C++ 仿真器验证设计的系统行为。一旦行为设计运行良好，对应的测试台的问题全部解决，就可以通过 Vivado HLS Synthesis 运行设计，生成 RTL 设计，代码可以是 Verilog，也可以是 VHDL。有了 RTL 后，随即可以执行设计的 Verilog 或 VHDL 仿真，或使用工具的C封装器技术创建 SystemC 版本。然后可以进行System C架构级仿真，进一步根据之前创建的 C 测试平台，验证设计的架构行为和功能。设计固化后，就可以通过 Vivado 设计套件的物理实现流程来运行设计，将设计编程到器件上，在硬件中运行和/或使用 IP 封装器将设计转为可重用的 IP。随后使用 IP 集成器将 IP 集成到设计中，或在系统生成器 （System Generator） 中运行 IP。</p><h2 id="HLS进阶学习"><a href="#HLS进阶学习" class="headerlink" title="HLS进阶学习"></a>HLS进阶学习</h2><h3 id="初步学习计划"><a href="#初步学习计划" class="headerlink" title="初步学习计划"></a>初步学习计划</h3><p>HLS说到底是一个工具，作为工具，应用为先。</p><h4 id="第一步-利用教程和例程跑一个hls仿真"><a href="#第一步-利用教程和例程跑一个hls仿真" class="headerlink" title="第一步 利用教程和例程跑一个hls仿真"></a>第一步 利用教程和例程跑一个hls仿真</h4><p>详情参考ug871第二章 create a high-level synthesis project</p><p>以下仅对值得注意的地方进行记录</p><p>很好，我点进上文的参考代码链接，给我出现了以下界面</p><p><img src="/2018/10/06/vivadoHLS-0/1538791324962.png" alt="1538791324962"></p><p>我觉得事情不简单，下拉以后</p><p><img src="/2018/10/06/vivadoHLS-0/1538791380106.png" alt="1538791380106"></p><p>好的吧，出现最新版教程了。左边侧栏勾选tutorials,然后把document type 那边的user guides去掉。往下拉你就可以看到清纯不做作的ug871 2018.2。</p><p><img src="/2018/10/06/vivadoHLS-0/1538791548492.png" alt="1538791548492"></p><p>………………换文档肯定要跑路的啊！（不是）换文档肯定要看看有什么区别的啊！</p><p><img src="/2018/10/06/vivadoHLS-0/1538791799084.png" alt="1538791799084"></p><p>​                                                                           2018.2</p><p><img src="/2018/10/06/vivadoHLS-0/1538749785686.png" alt="1538749785686"></p><p>​                                                                              2013.1</p><p>初步判断没什么实质性区别，那好，我去看看操作。其实本来差别就不可能很大，主要是怕有一些操作不同。这个时候第一步就是打开我的<del>垃圾</del> vivado hls 2016.1，暗中观察一下初始GUI页面跟哪一版的教程更像。</p><p>然后我觉得我应该用新版教程了(っ•̀ω•́)っ✎⁾⁾。接下来这句话：详情参考ug871 2018.2 ch.2 hls introduction</p><p>哦好的吧，我本来想搞一个能看Waveforms的工程出来，然后发现ch2这章introduction的三个lab是在教软件使用方法。好吧，那我放一个我lab 2成功的截图好了。</p><p><img src="/2018/10/06/vivadoHLS-0/TIM图片201810061220.png" alt="TIM图片201810061220"></p><p>说一下体验，教程还是很详细的，基本都很顺。除了lab 2用commad prompt的时候，出了一点小问题。因为第一步要定位到introduction文件夹里，我一开始用cd 命令……然后就一点都不ok,查了才发现windows cd命令只能切当前盘内路径。</p><p>然后如果像我一样不按原设定路径安装的话，这部分修改大致如下：</p><p><img src="/2018/10/06/vivadoHLS-0/TIM图片20181006122457.png" alt="TIM图片20181006122457"></p><p>因为我混乱的路径就是……</p><p>E:\FileRecv\fpga\ug871-design-files\ug871-design-files\Introduction</p><p>这样的啊，然后我又习惯性地把fir_prj放到我平常放代码的地方，就不在lab1目录下。为了完成这个实验，那当然是！复制过来！！！</p><p>之后操作就一切正常。</p><p>总之官方教程文档很详细。只是编一个初始的小工程编译就花了不少时间，我已经感受到了来自vivado的威胁(Ｔ▽Ｔ)</p><p>心怀电路写C第一步，完成。</p><h4 id="第二步-利用手上的ug871和ug902文档研究官方例程和语法约束"><a href="#第二步-利用手上的ug871和ug902文档研究官方例程和语法约束" class="headerlink" title="第二步 利用手上的ug871和ug902文档研究官方例程和语法约束"></a>第二步 利用手上的ug871和ug902文档研究官方例程和语法约束</h4><p>ug871官方例程教程</p><p><img src="/2018/10/06/vivadoHLS-0/1538749785686.png" alt="1538749785686"></p><p>ug902语法约束</p><p><img src="/2018/10/06/vivadoHLS-0/1538789542511.png" alt="1538789542511"></p><h4 id="第三步-将hls运用在参赛项目上"><a href="#第三步-将hls运用在参赛项目上" class="headerlink" title="第三步 将hls运用在参赛项目上"></a>第三步 将hls运用在参赛项目上</h4><p>过程记录如下</p><h4 id="第四步-后期完善学习，记录一些可优化技巧"><a href="#第四步-后期完善学习，记录一些可优化技巧" class="headerlink" title="第四步 后期完善学习，记录一些可优化技巧"></a>第四步 后期完善学习，记录一些可优化技巧</h4>]]></content>
      
      
      <categories>
          
          <category> VivadoHLS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>uCOSIII(一)</title>
      <link href="/2018/10/04/uCOSIII1/"/>
      <url>/2018/10/04/uCOSIII1/</url>
      
        <content type="html"><![CDATA[<h1 id="UCOSIII学习"><a href="#UCOSIII学习" class="headerlink" title="UCOSIII学习"></a>UCOSIII学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学了一年单片机，从51到tm4以及stm32,基本都是在while(1)里面“裸奔”。18年暑假的时候突然想玩一下操作系统，就操作了一下。原来有一个官方移植的tm4c1294例程。本来是想改一改移植到tm4c123g上然后用ccs作为开发环境，研究了一天发现micrium官方对于tiva-c系列只提供了IAR和realview开发工具的startup.c。我猜直接把ccs的startup_ccs.c换掉realview的或许可以吧。不过我的首要目的是学单片机上操作系统的原理和使用方法，所以就直接用官方移植的例程上手了。</p><h2 id="基于tm4c1294的UCOSIII系统搭建"><a href="#基于tm4c1294的UCOSIII系统搭建" class="headerlink" title="基于tm4c1294的UCOSIII系统搭建"></a>基于tm4c1294的UCOSIII系统搭建</h2><h3 id="官方例程下载"><a href="#官方例程下载" class="headerlink" title="官方例程下载"></a>官方例程下载</h3><h3 id="1-进入micrium官网"><a href="#1-进入micrium官网" class="headerlink" title="1.进入micrium官网"></a>1.进入micrium官网</h3><p>国外网站打开有点慢，等个半分钟到一分钟就行。</p><p><a href="https://www.micrium.com/" target="_blank" rel="external">https://www.micrium.com/</a></p><p><img src="/2018/10/04/uCOSIII1/1538641804364.png" alt="1538641804364"></p><h3 id="2-点击导航栏的Downloads进入下载页面"><a href="#2-点击导航栏的Downloads进入下载页面" class="headerlink" title="2.点击导航栏的Downloads进入下载页面"></a>2.点击导航栏的Downloads进入下载页面</h3><p>下拉页面找到根据MCU生产商浏览，找到Texas Instrument。</p><p><img src="/2018/10/04/uCOSIII1/1538642099029.png" alt="1538642099029"></p><h3 id="3-选中tm4c1294进入下载界面"><a href="#3-选中tm4c1294进入下载界面" class="headerlink" title="3.选中tm4c1294进入下载界面"></a>3.选中tm4c1294进入下载界面</h3><p><img src="/2018/10/04/uCOSIII1/1538642588422.png" alt="1538642588422"></p><h3 id="4-直接点击资源这一栏"><a href="#4-直接点击资源这一栏" class="headerlink" title="4.直接点击资源这一栏"></a>4.直接点击资源这一栏</h3><p>值得注意的是micrium提供的keil MDK是v4，所以导入到v5会有警告提示，管它呢。反正最后不影响使用就是了。</p><p><img src="/2018/10/04/uCOSIII1/1538642688315.png" alt="1538642688315"></p><h3 id="5-登录账号并下载"><a href="#5-登录账号并下载" class="headerlink" title="5.登录账号并下载"></a>5.登录账号并下载</h3><p>注册一个micrium账号，Log in to Download</p><p><img src="/2018/10/04/uCOSIII1/1538643022452.png" alt="1538643022452"></p><h3 id="文件结构解析"><a href="#文件结构解析" class="headerlink" title="文件结构解析"></a>文件结构解析</h3><h4 id="文件夹初探"><a href="#文件夹初探" class="headerlink" title="文件夹初探"></a>文件夹初探</h4><p>文件夹解压出来如下</p><p><img src="/2018/10/04/uCOSIII1/1538643201614.png" alt="1538643201614"></p><h5 id="第一个EvalBoards就是MCU板子移植的相关代码"><a href="#第一个EvalBoards就是MCU板子移植的相关代码" class="headerlink" title="第一个EvalBoards就是MCU板子移植的相关代码"></a>第一个EvalBoards就是MCU板子移植的相关代码</h5><p>我们要找的keil工程文件在EvalBoards-&gt;TI-&gt;EK-TM4C1294XL-&gt;OS3-&gt;KeilMDK这条路径下。</p><p>在OS3那一层并列一个”BSP”的文件夹，这是micrium写的tm4c1294板子驱动的相关代码。不过我采用的是tiva-ware，这个BSP驱动后续可能只用一部分，不然会重定义然后打架。</p><p><img src="/2018/10/04/uCOSIII1/1538643385032.png" alt="1538643385032"></p><h5 id="剩下三个就是UCOSIII的资源文件"><a href="#剩下三个就是UCOSIII的资源文件" class="headerlink" title="剩下三个就是UCOSIII的资源文件"></a>剩下三个就是UCOSIII的资源文件</h5><p>这部分详细介绍参考《嵌入式实时操作系统uCOS-3》（北航出版社）。</p><p><strong>uC-CPU</strong></p><p>文件结构如下</p><p>\uC-CPU</p><p>​    \cpu_core.c(包含适用所有CPU架构的C代码 包含用来测量中断关闭时间的函数)</p><p>​    \cpu_core.h（包含用于测量中断关闭时间的变量定义）</p><p>​    \cpu_def.h（包含uC/CPU模块使用的宏定义）</p><p>​    \ARM-Cortex-M4\RealView</p><p>​        \cpu.h(包含一些数据类型定义)</p><p>​        \cpu_a.asm（汇编语言实现开关中断、计算前导零、使能缓存、建立MPUs、MMU的函数，其中函数可以直接在C代码里调用）</p><p>​        \cpu_c.c（基于特定cpu架构的代码）</p><p><strong>uC-LIB</strong></p><p>可移植库函数如下</p><p>\lib_ascii.c及其头文件（其中函数可以替代大小字母转化和数字字母互化的库函数）</p><p>\lib_def.h(定义许多常量)</p><p>\lib_math.c及其头文件（其中函数可以替代rand()、srand()）</p><p>\lib_mem.c及其头文件（其中函数可以替代memclr()、memset()、memcpy()、memcmp()）等</p><p>lib_str.c及其头文件（其中函数可以以替代strlen()、strcpy()、strcmp()）等</p><p><strong>uCOS-III</strong></p><p>其中与处理器类型无关文件如下</p><p>\Source</p><p>​    \os_cfg.app.c（根据os_cfg_app.h中宏定义定义变量和数据）</p><p>​    \os_core.c（包含uCOSIII内核功能模块）</p><p>​    \os_dbg.c（包含内核调试器）</p><p>​    \os_flag.c（包含事件标志管理代码）</p><p>​    \os_int.c（包含中断处理任务代码）</p><p>​    \os_mem.c（包含存储分区代码）</p><p>​    \os_msg.c（包含消息处理代码）</p><p>​    \os_mutex.c（包含互斥信号量代码）</p><p>​    \os_pend.multi.c（包含允许任务同时等待多个信号量和多个消息队列代码）</p><p>​    \os_prio.c（用于追踪已就绪任务）</p><p>​    \os_q.c（包含消息队列管理代码）</p><p>​    \os_sem.c（包含信号量管理代码）</p><p>​    \os_stat.c(包含统计任务代码)</p><p>​    \os_task.c（包含任务的管理代码）</p><p>​    \os_tick.c（包含可管理正在延时和超时等待任务）</p><p>​    \os_time.c（包含延时代码）</p><pre><code>\os_tmr.c（包含软件定时器代码）</code></pre><p>​    \os_var.c（包含uCOSIII的全局变量）</p><p>​    \os.h（uCOSIII主要头文件）</p><p>​    \os_type.h（包含数据类型声明）</p><h3 id="keil环境配置"><a href="#keil环境配置" class="headerlink" title="keil环境配置"></a>keil环境配置</h3><p>在第一次导入工程的时候一般会提示识别到器件为tm4c1294,直接按提示下支持包就行。</p><p>器件型号为TM4C1294NCPDT。</p><p>我记得只要器件型号对上了，其他配置在这个例程下基本都是配好的。</p><p>只需要在魔术棒的C/C++选项卡把Preprocessor Symbols的Define填上     rvmdk PART_TM4C1294NCPDT     就行。<img src="/2018/10/04/uCOSIII1/1538653394096.png" alt="1538653394096"></p><p>如果出现什么问题，参照以下文档配置keil下的tm4开发环境：</p><p><a href="https://wenku.baidu.com/view/6d23b80dbc64783e0912a21614791711cc7979f4.html" target="_blank" rel="external">https://wenku.baidu.com/view/6d23b80dbc64783e0912a21614791711cc7979f4.html</a></p><h3 id="tiva-ware联动"><a href="#tiva-ware联动" class="headerlink" title="tiva-ware联动"></a>tiva-ware联动</h3><p>tiva-ware是一个ti的软件开发包，里面有bsp板级支持以及tiva-c系列各型号开发板的库函数和例程。</p><p>在keil里面使用tiva-ware只需要将tiva-ware包里面针对realview开发工具的driverlib.lib添入工程就行。</p><p>顺便在魔术棒的C/C++选项卡里的 Include Paths一栏加入你的tiva-ware包的路径。</p><p><img src="/2018/10/04/uCOSIII1/1538653571710.png" alt="1538653571710"></p><h2 id="第一个UCOSIII工程"><a href="#第一个UCOSIII工程" class="headerlink" title="第一个UCOSIII工程"></a>第一个UCOSIII工程</h2><p>下好例程，配好环境，来试试水</p><p>软件设计如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"app_cfg.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cpu_core.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;os.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_led.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_sys.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">"..\bsp\bsp_misc.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_ascii.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_mem.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lib_str.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inc/hw_memmap.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driverlib/gpio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driverlib/sysctl.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> START_TASK_PRIO3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> START_STK_SIZE 128</span></div><div class="line">OS_TCB StartTaskTCB;</div><div class="line">CPU_STK START_TASK_STK[START_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_TASK_PRIO4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_STK_SIZE 128</span></div><div class="line">OS_TCB Task1_TaskTCB</div><div class="line">CPU_STK TASK1_TASK_STK[TASK1_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_TASK_PRIO5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_STK_SIZE 128</span></div><div class="line">OS_TCB Task2_TaskTCB;</div><div class="line">CPU_STK TASK2_TASK_STK[TASK2_STK_SIZE];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    OS_ERR  err;</div><div class="line">    CPU_SR_ALLOC();                                              <span class="comment">/* Disable all interrupts.*/</span></div><div class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</div><div class="line">    <span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF))</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0|GPIO_PIN_4);</div><div class="line">    OSInit(&amp;err);                                               <span class="comment">/* Init uC/OS-III. */</span></div><div class="line">    OS_CRITICAL_ENTER();</div><div class="line">   OSTaskCreate((OS_TCB * )&amp;StartTaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"start task"</span>, </div><div class="line">                 (OS_TASK_PTR )start_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )START_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;START_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)START_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)START_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP, </div><div class="line">                 (OS_ERR * )&amp;err);</div><div class="line">OS_CRITICAL_EXIT(); </div><div class="line">OSStart(&amp;err);      </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT32U  cpu_clk_freq;</div><div class="line">    CPU_INT32U  cnts;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   (<span class="keyword">void</span>)&amp;p_arg;</div><div class="line"></div><div class="line">    BSP_Init();                                           <span class="comment">/* Initialize BSP functions */</span></div><div class="line"></div><div class="line">    cpu_clk_freq = BSP_SysClkFreqGet();                <span class="comment">/* Determine SysTick reference freq.*/</span></div><div class="line">    cnts         = cpu_clk_freq                          <span class="comment">/* Determine nbr SysTick increments*/</span></div><div class="line">                 / (CPU_INT32U)OSCfg_TickRate_Hz;</div><div class="line"></div><div class="line">    OS_CPU_SysTickInit(cnts);</div><div class="line">    CPU_Init();  </div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line">OSTaskCreate((OS_TCB * )&amp;Task1_TaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"Task1 task"</span>, </div><div class="line">                 (OS_TASK_PTR )task1_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )TASK1_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;TASK1_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)TASK1_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)TASK1_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP,</div><div class="line">                 (OS_ERR * )&amp;err);</div><div class="line"> </div><div class="line"></div><div class="line">OSTaskCreate((OS_TCB * )&amp;Task2_TaskTCB,</div><div class="line"> (CPU_CHAR* )<span class="string">"task2 task"</span>, </div><div class="line">                 (OS_TASK_PTR )task2_task, </div><div class="line">                 (<span class="keyword">void</span>* )<span class="number">0</span>,</div><div class="line">                 (OS_PRIO  )TASK2_TASK_PRIO,     </div><div class="line">                 (CPU_STK   * )&amp;TASK2_TASK_STK[<span class="number">0</span>],</div><div class="line">                 (CPU_STK_SIZE)TASK2_STK_SIZE/<span class="number">10</span>,</div><div class="line">                 (CPU_STK_SIZE)TASK2_STK_SIZE,</div><div class="line">                 (OS_MSG_QTY  )<span class="number">0</span>,</div><div class="line">                 (OS_TICK  )<span class="number">0</span>,</div><div class="line">                 (<span class="keyword">void</span>   * )<span class="number">0</span>,</div><div class="line">                 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR|OS_OPT_TASK_SAVE_FP, </div><div class="line">                 (OS_ERR * )&amp;err); </div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"> </div><div class="line">OSTaskDel((OS_TCB*)<span class="number">0</span>,&amp;err);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT08U task1_num=<span class="number">0</span>;</div><div class="line">CPU_INT32U ui32Loop1;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line">p_arg = p_arg;</div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line"></div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">task1_num++;</div><div class="line"> <span class="comment">//BSP_LED_Toggle(1);</span></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_PIN_4);</div><div class="line">        <span class="keyword">for</span>(ui32Loop1 = <span class="number">0</span>; ui32Loop1 &lt; <span class="number">20000</span>; ui32Loop1++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, <span class="number">0x0</span>);</div><div class="line">        <span class="keyword">for</span>(ui32Loop1 = <span class="number">0</span>; ui32Loop1 &lt; <span class="number">20000</span>; ui32Loop1++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">if</span>(task1_num==<span class="number">5</span>) </div><div class="line">&#123;</div><div class="line">OSTaskDel((OS_TCB*)&amp;Task2_TaskTCB,&amp;err);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err); </div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2_task</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></div><div class="line">&#123;</div><div class="line">CPU_INT08U task2_num=<span class="number">0</span>;</div><div class="line">CPU_INT32U ui32Loop;</div><div class="line">OS_ERR err;</div><div class="line">CPU_SR_ALLOC();</div><div class="line">p_arg = p_arg;</div><div class="line"></div><div class="line"></div><div class="line">OS_CRITICAL_ENTER();</div><div class="line"></div><div class="line">OS_CRITICAL_EXIT();</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">task2_num++;</div><div class="line">     <span class="comment">//BSP_LED_Toggle(2);  </span></div><div class="line"></div><div class="line">       GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);</div><div class="line">        <span class="keyword">for</span>(ui32Loop = <span class="number">0</span>; ui32Loop &lt; <span class="number">20000</span>; ui32Loop++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, <span class="number">0x0</span>);</div><div class="line">        <span class="keyword">for</span>(ui32Loop = <span class="number">0</span>; ui32Loop &lt; <span class="number">20000</span>; ui32Loop++)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,OS_OPT_TIME_HMSM_STRICT,&amp;err); </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下载现象为：任务一运行5次后删掉任务二。所以可以看到本来是两个led几乎同时闪烁，闪烁4次后，有一个led停止闪烁，另一个继续闪烁。</p><p>至此，你就在tm4c1294上拥有了一个基于tiva-ware固件库可以跑的uCOSIII。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>阿月月，现就读于南京邮电大学，每日沉迷学习和玩技术无法自拔。作为一个琴棋（飞行棋）书画都会又能歌善舞（全国中学生广播体操——舞动青春）的女孩子，我为什么要跑来学工科呢？犹记邓布利多，邓校的那句：“你想成为什么样的人比你具备什么样的特质更能决定你的未来。”</p><p>人的一生就是个不停拾取灵魂碎片的过程。你来人间走一趟，不玩点好玩的，不做点有意思的事，不试着自己衡量世事，不去和一些有梦想的魔鬼混在一起，怎么会甘心呢？</p>]]></content>
      
    </entry>
    
  
</search>
